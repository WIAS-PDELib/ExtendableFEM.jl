
# Stationary Solvers

## Meshes and FESpaces

To solve a ProblemDescription the user needs to provide some discretisation information.
The most important one is the mesh (that should be conforming with the region information used in the problem description).

Meshes are expected in the form of an ExtendableGrid, see [ExtendableGrids.jl](https://github.com/WIAS-PDELib/ExtendableGrids.jl) for details and constructors.
Grid generators for simplex grids can be found e.g. in the external module [SimplexGridFactory.jl](https://github.com/WIAS-PDELib/SimplexGridFactory.jl).
There is also an extension to read meshes from gmsh files.

Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be
generated by
```julia
FESpace{FEType}(grid::ExtendableGrid)
```
Here, FEType denotes the type of finite element.
A [list of available FETypes](https://wias-pdelib.github.io/ExtendableFEMBase.jl/dev/fems/) can be found in the [Documentation of ExtendableFEMBase.jl](https://wias-pdelib.github.io/ExtendableFEMBase.jl/dev/).

## Solve (monolithic)
If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. 

```@docs
solve
residual
```

!!! note

    The type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all
    of them are assembled as a NonlinearOperator, this will result in a Newton scheme
    (which can be somewhat customized via the keywords arguments like damping). If all nonlinearities
    are linearized by LinearOperator and BilinearOperator, this will result in other types of
    fixed-point iterations.

## Solve (iterating subproblems)

If the problem can be solved by iterating over subproblems this can be achieved as well.
For that each subproblem must be configured separately via a SolverConfiguration
(allowing different tolerances and keyword arguments for each subproblem solve).
A SolverConfiguration can be constructed with this constructor:

```@docs
SolverConfiguration
get_unknown_id
```

If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered
with this function:

```@docs
iterate_until_stationarity
```
