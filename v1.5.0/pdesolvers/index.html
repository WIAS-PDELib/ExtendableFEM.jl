<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stationary Solvers · ExtendableFEM.jl</title><meta name="title" content="Stationary Solvers · ExtendableFEM.jl"/><meta property="og:title" content="Stationary Solvers · ExtendableFEM.jl"/><meta property="twitter:title" content="Stationary Solvers · ExtendableFEM.jl"/><meta name="description" content="Documentation for ExtendableFEM.jl."/><meta property="og:description" content="Documentation for ExtendableFEM.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../tensordescription/">Tensor Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li><a class="tocitem" href="../bilinearoperator/">BilinearOperator</a></li><li><a class="tocitem" href="../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../restrictions/">Restrictions</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li class="is-active"><a class="tocitem" href>Stationary Solvers</a><ul class="internal"><li><a class="tocitem" href="#Meshes-and-FESpaces"><span>Meshes and FESpaces</span></a></li><li><a class="tocitem" href="#Monolithic-Solve"><span>Monolithic Solve</span></a></li><li><a class="tocitem" href="#Block-Iterative-Solve-(Subproblem-Iteration)"><span>Block-Iterative Solve (Subproblem Iteration)</span></a></li></ul></li><li><a class="tocitem" href="../pdesolvers_dt/">Time-dependent Solvers</a></li><li><a class="tocitem" href="../parallel_assembly/">Parallel Assembly</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Postprocessing and Visualization</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../faceinterpolator/">Face Interpolator</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../module_examples/Example103_BurgersEquation/">Example103_BurgersEquation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoissonEquation/">Example105_NonlinearPoissonEquation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion/">Example106_NonlinearDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example108_RobinBoundaryCondition/">Example108_RobinBoundaryCondition</a></li><li><a class="tocitem" href="../module_examples/Example201_PoissonProblem/">Example201_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example202_MixedPoissonProblem/">Example202_MixedPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example203_PoissonProblemDG/">Example203_PoissonProblemDG</a></li><li><a class="tocitem" href="../module_examples/Example204_LaplaceEVProblem/">Example204_LaplaceEVProblem</a></li><li><a class="tocitem" href="../module_examples/Example205_HeatEquation/">Example205_HeatEquation</a></li><li><a class="tocitem" href="../module_examples/Example206_CoupledSubGridProblems/">Example206_CoupledSubGridProblems</a></li><li><a class="tocitem" href="../module_examples/Example207_AdvectionUpwindDG/">Example207_AdvectionUpwindDG</a></li><li><a class="tocitem" href="../module_examples/Example210_LshapeAdaptivePoissonProblem/">Example210_LshapeAdaptivePoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example211_LshapeAdaptiveEQPoissonProblem/">Example211_LshapeAdaptiveEQPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example212_PeriodicBoundary2D/">Example212_PeriodicBoundary2D</a></li><li><a class="tocitem" href="../module_examples/Example220_ReactionConvectionDiffusion/">Example220_ReactionConvectionDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example225_ObstacleProblem/">Example225_ObstacleProblem</a></li><li><a class="tocitem" href="../module_examples/Example226_Thermoforming/">Example226_Thermoforming</a></li><li><a class="tocitem" href="../module_examples/Example230_NonlinearElasticity/">Example230_NonlinearElasticity</a></li><li><a class="tocitem" href="../module_examples/Example235_StokesIteratedPenalty/">Example235_StokesIteratedPenalty</a></li><li><a class="tocitem" href="../module_examples/Example240_SVRTEnrichment/">Example240_SVRTEnrichment</a></li><li><a class="tocitem" href="../module_examples/Example245_NSEFlowAroundCylinder/">Example245_NSEFlowAroundCylinder</a></li><li><a class="tocitem" href="../module_examples/Example250_NSELidDrivenCavity/">Example250_NSELidDrivenCavity</a></li><li><a class="tocitem" href="../module_examples/Example252_NSEPlanarLatticeFlow/">Example252_NSEPlanarLatticeFlow</a></li><li><a class="tocitem" href="../module_examples/Example260_AxisymmetricNavierStokesProblem/">Example260_AxisymmetricNavierStokesProblem</a></li><li><a class="tocitem" href="../module_examples/Example264_StokesDarcy/">Example264_StokesDarcy</a></li><li><a class="tocitem" href="../module_examples/Example265_FlowTransport/">Example265_FlowTransport</a></li><li><a class="tocitem" href="../module_examples/Example270_NaturalConvectionProblem/">Example270_NaturalConvectionProblem</a></li><li><a class="tocitem" href="../module_examples/Example275_OptimalControlStokes/">Example275_OptimalControlStokes</a></li><li><a class="tocitem" href="../module_examples/Example280_CompressibleStokes/">Example280_CompressibleStokes</a></li><li><a class="tocitem" href="../module_examples/Example282_IncompressibleMHD/">Example282_IncompressibleMHD</a></li><li><a class="tocitem" href="../module_examples/Example284_LevelSetMethod/">Example284_LevelSetMethod</a></li><li><a class="tocitem" href="../module_examples/Example285_CahnHilliard/">Example285_CahnHilliard</a></li><li><a class="tocitem" href="../module_examples/Example290_PoroElasticity/">Example290_PoroElasticity</a></li><li><a class="tocitem" href="../module_examples/Example301_PoissonProblem/">Example301_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example310_DivFreeBasis/">Example310_DivFreeBasis</a></li><li><a class="tocitem" href="../module_examples/Example312_PeriodicBoundary3D/">Example312_PeriodicBoundary3D</a></li><li><a class="tocitem" href="../module_examples/Example330_HyperElasticity/">Example330_HyperElasticity</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solving</a></li><li class="is-active"><a href>Stationary Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stationary Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/master/docs/src/pdesolvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stationary-Solvers"><a class="docs-heading-anchor" href="#Stationary-Solvers">Stationary Solvers</a><a id="Stationary-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-Solvers" title="Permalink"></a></h1><p>This section describes how to solve stationary (time-independent) PDEs using the high-level API provided by this package. Both monolithic (single system) and block-iterative (subproblem) approaches are supported. For time-dependent problems, there is an extra section.</p><h2 id="Meshes-and-FESpaces"><a class="docs-heading-anchor" href="#Meshes-and-FESpaces">Meshes and FESpaces</a><a id="Meshes-and-FESpaces-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-and-FESpaces" title="Permalink"></a></h2><p>To solve a <code>ProblemDescription</code>, you must provide discretization information:</p><ul><li><p><strong>Mesh:</strong> The computational domain, represented as an <code>ExtendableGrid</code>. See <a href="https://github.com/WIAS-PDELib/ExtendableGrids.jl">ExtendableGrids.jl</a> for details and grid constructors. For simplex grids, see <a href="https://github.com/WIAS-PDELib/SimplexGridFactory.jl">SimplexGridFactory.jl</a>. Gmsh mesh import is also supported.</p></li><li><p><strong>Finite Element Spaces:</strong> For each unknown, specify a finite element space (FESpace) that defines the ansatz functions. Construct with:</p><p><code>julia   FESpace{FEType}(grid::ExtendableGrid)</code>   where <code>FEType</code> is the finite element type. See the <a href="https://wias-pdelib.github.io/ExtendableFEMBase.jl/stable/fems/">list of available FETypes</a> in the <a href="https://wias-pdelib.github.io/ExtendableFEMBase.jl/stable/">ExtendableFEMBase.jl documentation</a>.</p></li></ul><h2 id="Monolithic-Solve"><a class="docs-heading-anchor" href="#Monolithic-Solve">Monolithic Solve</a><a id="Monolithic-Solve-1"></a><a class="docs-heading-anchor-permalink" href="#Monolithic-Solve" title="Permalink"></a></h2><p>To solve a problem, call <code>solve</code> with a <code>ProblemDescription</code> and an array of FESpaces (one per unknown). The solver automatically detects whether the problem is linear or nonlinear and chooses the appropriate algorithm (direct solve or fixed-point iteration/Newton&#39;s method). The nonlinear residual is reduced to the prescribed tolerance.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(
    PD::ProblemDescription,
    FES::Dict{&lt;:Unknown};
    ...
) -&gt; Any
solve(
    PD::ProblemDescription,
    FES::Dict{&lt;:Unknown},
    SC;
    unknowns,
    kwargs...
) -&gt; Any
</code></pre><p>Solve a PDE problem described by a <code>ProblemDescription</code> using the provided finite element spaces and solver configuration.</p><p><strong>Arguments</strong></p><ul><li><code>PD::ProblemDescription</code>: The problem description, including operators, unknowns, and boundary conditions.</li><li><code>FES::Union{&lt;:FESpace, Vector{&lt;:FESpace}, Dict{&lt;:Unknown}}</code>: The finite element space(s) for discretizing the unknowns. Can be a single space, a vector of spaces (one per unknown), or a dictionary mapping unknowns to spaces.</li><li><code>SC</code>: (optional) Solver configuration. If not provided, a new configuration is created.</li><li><code>unknowns</code>: (optional) Vector of unknowns to solve for (default: <code>PD.unknowns</code>).</li><li><code>kwargs...</code>: Additional keyword arguments for solver configuration and algorithmic options (see below).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>abstol</code>: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>check_matrix</code>: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p><code>constant_matrix</code>: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li><li><p><code>constant_rhs</code>: right-hand side is constant (skips reassembly). Default: false</p></li><li><p><code>damping</code>: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p><code>inactive</code>: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p><code>init</code>: initial solution (also used to save the new solution). Default: nothing</p></li><li><p><code>initialized</code>: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p><code>is_linear</code>: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>maxiterations</code>: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p><code>method_linear</code>: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p><code>plot</code>: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p><code>precon_linear</code>: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing</p></li><li><p><code>reltol</code>: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>restrict_dofs</code>: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]</p></li><li><p><code>return_config</code>: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p><code>show_config</code>: show configuration at the beginning of solve. Default: false</p></li><li><p><code>show_matrix</code>: show system matrix after assembly. Default: false</p></li><li><p><code>spy</code>: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p><code>symmetrize</code>: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p><code>symmetrize_structure</code>: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false</p></li><li><p><code>target_residual</code>: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p><code>time</code>: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p><code>timeroutputs</code>: configures show of timeroutputs (choose between :hide, :full, :compact). Default: full</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul><p><strong>Returns</strong></p><ul><li>The solution as an <code>FEVector</code> (or a tuple <code>(sol, SC)</code> if <code>return_config=true</code>).</li></ul><p><strong>Notes</strong></p><ul><li>The function automatically detects and handles linear and nonlinear problems depending on the operator definitions and runs a fixed-point iteration if necessary.</li><li>See the <code>iterate_until_stationarity</code> function for non-monolithic problems.</li><li>This method extends the <code>CommonSolve.solve</code> interface, where <code>ProblemDescription</code> acts as the problem type and <code>FES</code> as the solver type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/7c2db7b7511860ef2fe9926c093ee42d871ee448/src/solvers.jl#L164-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.residual" href="#ExtendableFEM.residual"><code>ExtendableFEM.residual</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual(S::SolverConfiguration)</code></pre><p>returns the residual of the last solve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/7c2db7b7511860ef2fe9926c093ee42d871ee448/src/solver_config.jl#L35-L41">source</a></section></article><div class="admonition is-info" id="Note-7b034fdbe3500f77"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7b034fdbe3500f77" title="Permalink"></a></header><div class="admonition-body"><p>The type of fixed-point algorithm depends on how nonlinearities are assembled. If all are assembled as <code>NonlinearOperator</code>, a Newton scheme is used (customizable via keyword arguments like <code>damping</code>). If nonlinearities are linearized by <code>LinearOperator</code> and <code>BilinearOperator</code>, other fixed-point iterations are used.</p></div></div><h2 id="Block-Iterative-Solve-(Subproblem-Iteration)"><a class="docs-heading-anchor" href="#Block-Iterative-Solve-(Subproblem-Iteration)">Block-Iterative Solve (Subproblem Iteration)</a><a id="Block-Iterative-Solve-(Subproblem-Iteration)-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Iterative-Solve-(Subproblem-Iteration)" title="Permalink"></a></h2><p>For problems that can be solved by iterating over subproblems, configure each subproblem separately with a <code>ProblemDescription</code>/<code>SolverConfiguration</code>. This allows different tolerances and keyword arguments for each subproblem.</p><p>Construct a <code>SolverConfiguration</code> with:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.SolverConfiguration" href="#ExtendableFEM.SolverConfiguration"><code>ExtendableFEM.SolverConfiguration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SolverConfiguration(
    Problem::ProblemDescription;
    init,
    unknowns,
    kwargs...
)
</code></pre><p>Construct a <code>SolverConfiguration</code> for a given problem and set of finite element spaces.</p><p>A <code>SolverConfiguration</code> bundles all data and options needed to assemble and solve a finite element system for a given <code>ProblemDescription</code>. It stores the system matrix, right-hand side, solution vector, solver parameters, and bookkeeping for unknowns and degrees of freedom.</p><p><strong>Arguments</strong></p><ul><li><code>Problem::ProblemDescription</code>: The problem to be solved, including operators, unknowns, and boundary conditions.</li><li><code>FES::Union{&lt;:FESpace, Vector{&lt;:FESpace}}</code>: The finite element space(s) for the unknowns. Can be a single space or a vector of spaces (one per unknown).</li><li><code>unknowns::Vector{Unknown}</code>: (optional) The unknowns to be solved for (default: <code>Problem.unknowns</code>).</li><li><code>init</code>: (optional) Initial <code>FEVector</code> for the solution. If provided, the finite element spaces are inferred from it.</li><li><code>kwargs...</code>: Additional keyword arguments to set solver parameters (see below).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>abstol</code>: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>check_matrix</code>: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p><code>constant_matrix</code>: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li><li><p><code>constant_rhs</code>: right-hand side is constant (skips reassembly). Default: false</p></li><li><p><code>damping</code>: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p><code>inactive</code>: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p><code>init</code>: initial solution (also used to save the new solution). Default: nothing</p></li><li><p><code>initialized</code>: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p><code>is_linear</code>: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>maxiterations</code>: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p><code>method_linear</code>: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p><code>plot</code>: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p><code>precon_linear</code>: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing</p></li><li><p><code>reltol</code>: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>restrict_dofs</code>: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]</p></li><li><p><code>return_config</code>: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p><code>show_config</code>: show configuration at the beginning of solve. Default: false</p></li><li><p><code>show_matrix</code>: show system matrix after assembly. Default: false</p></li><li><p><code>spy</code>: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p><code>symmetrize</code>: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p><code>symmetrize_structure</code>: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false</p></li><li><p><code>target_residual</code>: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p><code>time</code>: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p><code>timeroutputs</code>: configures show of timeroutputs (choose between :hide, :full, :compact). Default: full</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul><p><strong>Returns</strong></p><ul><li>A <code>SolverConfiguration</code> instance, ready to be passed to the <code>solve</code> function.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>init</code> is provided, the finite element spaces are inferred from it and the solution vector is initialized accordingly.</li><li>The constructor checks that the number of unknowns matches the number of finite element spaces and that all unknowns are present in the problem description.</li><li>The configuration includes storage for the system matrix, right-hand side, solution, temporary solution, residual, and solver statistics.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/7c2db7b7511860ef2fe9926c093ee42d871ee448/src/solver_config.jl#L132-L183">source</a></section></article><p>Trigger the fixed-point iteration over subproblems with:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.iterate_until_stationarity" href="#ExtendableFEM.iterate_until_stationarity"><code>ExtendableFEM.iterate_until_stationarity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate_until_stationarity(
    SCs::Vector{&lt;:SolverConfiguration};
    ...
)
iterate_until_stationarity(
    SCs::Vector{&lt;:SolverConfiguration},
    FES;
    maxsteps,
    energy_integrator,
    init,
    unknowns,
    kwargs...
) -&gt; Tuple{FEVector{Float64, _A, _B, Vector{Float64}} where {_A, _B}, Int64}
</code></pre><p>Iteratively solve coupled problems (i.e. an array of SolverConfigurations/ProblemDescriptions with intersecting unknowns) by iterating between them. Iteration continues until the residuals of all subproblems fall below their specified tolerances, or until <code>maxsteps</code> is reached.</p><p><strong>Arguments</strong></p><ul><li><code>SCs::Vector{&lt;:SolverConfiguration}</code>: Array of solver configurations, one for each subproblem. Each must contain its own <code>ProblemDescription</code>.</li><li><code>FES</code>: (optional) Nested vector of finite element spaces for all subproblems and unknowns. If not provided, must be inferred from <code>init</code>.</li><li><code>maxsteps::Int</code>: Maximum number of outer iterations (default: 1000).</li><li><code>energy_integrator</code>: (optional) Function or object to evaluate an energy or error after each iteration (for diagnostics).</li><li><code>init</code>: (optional) Initial <code>FEVector</code> containing all unknowns for all subproblems. Required if <code>FES</code> is not provided.</li><li><code>unknowns</code>: (optional) List of unknowns for each subproblem (default: <code>[SC.PD.unknowns for SC in SCs]</code>).</li><li><code>kwargs...</code>: Additional keyword arguments passed to each subproblem&#39;s solver.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol</code>: The final solution vector containing all unknowns.</li><li><code>it</code>: The number of outer iterations performed.</li></ul><p><strong>Notes</strong></p><ul><li>Each subproblem is solved in sequence within each outer iteration, using its own configuration and options.´</li><li>If <code>energy_integrator</code> is provided, its value is printed after each iteration for monitoring convergence.</li><li>This function is intended for non-monolithic (partitioned) solution strategies; for monolithic problems with a single ProblemDescription, see <code>solve</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/7c2db7b7511860ef2fe9926c093ee42d871ee448/src/solvers.jl#L719">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../allindex/">« Index</a><a class="docs-footer-nextpage" href="../pdesolvers_dt/">Time-dependent Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 25 September 2025 10:35">Thursday 25 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
