var documenterSearchIndex = {"docs":
[{"location":"examples/Example250_NSELidDrivenCavity/#:-Navier–Stokes-Lid-driven-cavity","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"","category":"section"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"(source code)","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"beginaligned\n- mu Delta mathbfu + left(mathbfu cdot nablaright) mathbfu+ nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"in a lid driven cavity example over a cone and plots the solution and the formed eddies.","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"module Example250_NSELidDrivenCavity\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n\tu, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n\tμ = qpinfo.params[1]\n\tresult[1] = dot(u, view(∇u, 1:2))\n\tresult[2] = dot(u, view(∇u, 3:4))\n\tresult[3] = μ * ∇u[1] - p[1]\n\tresult[4] = μ * ∇u[2]\n\tresult[5] = μ * ∇u[3]\n\tresult[6] = μ * ∇u[4] - p[1]\n\tresult[7] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction boundarydata!(result, qpinfo)\n\tresult[1] = 1\n\tresult[2] = 0\nend\n\nfunction initialgrid_cone()\n\txgrid = ExtendableGrid{Float64, Int32}()\n\txgrid[Coordinates] = Array{Float64, 2}([-1 0; 0 -2; 1 0]')\n\txgrid[CellNodes] = Array{Int32, 2}([1 2 3]')\n\txgrid[CellGeometries] = VectorOfConstants{ElementGeometries, Int}(Triangle2D, 1)\n\txgrid[CellRegions] = ones(Int32, 1)\n\txgrid[BFaceRegions] = Array{Int32, 1}([1, 2, 3])\n\txgrid[BFaceNodes] = Array{Int32, 2}([1 2; 2 3; 3 1]')\n\txgrid[BFaceGeometries] = VectorOfConstants{ElementGeometries, Int}(Edge1D, 3)\n\txgrid[CoordinateSystem] = Cartesian2D\n\treturn xgrid\nend\n\nfunction main(; μ_final = 0.0005, order = 2, nrefs = 5, Plotter = nothing, kwargs...)\n\n\t# prepare parameter field\n\textra_params = Array{Float64, 1}([max(μ_final, 0.05)])\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id(u), grad(u), id(p)]; params = extra_params, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, boundarydata!; regions = 3))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 2]))\n\n\t# grid\n\txgrid = uniform_refine(initialgrid_cone(), nrefs)\n\n\t# prepare FESpace\n\tFES = [FESpace{H1Pk{2,2,order}}(xgrid), FESpace{H1Pk{1,2,order-1}}(xgrid)]\n\n\t# prepare plots\n\tp = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, size = (1600, 800))\n\n\t# solve by μ embedding\n\tstep = 0\n\tsol = nothing\n\tSC = nothing\n\tPE = PointEvaluator([id(1)])\n\twhile (true)\n\t\tstep += 1\n\t\t@info \"Step $step : solving for μ=$(extra_params[1])\"\n\t\tsol, SC = ExtendableFEM.solve(PD, FES, SC; return_config = true, target_residual = 1e-10, maxiterations = 20, kwargs...)\n\t\tif step == 1\n\t\t\tinitialize!(PE, sol)\n\t\tend\n\t\tscalarplot!(p[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n\t\tvectorplot!(p[1, 1], xgrid, eval_func(PE), spacing = 0.05, clear = false)\n\t\tstreamplot!(p[1, 2], xgrid, eval_func(PE), spacing = 0.01, density = 2, title = \"streamlines\")\n\n\t\tif extra_params[1] <= μ_final\n\t\t\tbreak\n\t\telse\n\t\t\textra_params[1] = max(μ_final, extra_params[1] / 2)\n\t\tend\n\tend\n\n\tscalarplot!(p[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n\tvectorplot!(p[1, 1], xgrid, eval_func(PE), spacing = 0.05, clear = false)\n\tstreamplot!(p[1, 2], xgrid, eval_func(PE), spacing = 0.01, density = 2, title = \"streamlines\")\nend\n\nend # module","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"Default output:","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"julia> Example250_NSELidDrivenCavity.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.24\n   1\t5.330e-01\t6.116e-14\t0.22\t0.04\t0.26\t\t5.24\t17.93\t23.17\n   2\t1.861e-02\t1.387e-15\t0.22\t0.03\t0.26\t\t3.84\t21.02\t24.86\n   3\t1.544e-04\t9.490e-16\t0.22\t0.02\t0.24\t\t0.17\t15.47\t15.64\n   4\t6.221e-09\t2.118e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n END\t2.137e-15\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.23\t\t\tSUM -->\t79.71\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t1.969e-01\t5.688e-16\t0.23\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   2\t1.332e-04\t1.025e-15\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   3\t3.664e-08\t7.697e-16\t0.22\t0.04\t0.26\t\t0.17\t15.47\t15.64\n END\t4.186e-15\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t0.97\t\t\tSUM -->\t47.09\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t9.864e-02\t2.901e-16\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   2\t3.434e-04\t3.362e-16\t0.23\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   3\t3.108e-06\t6.256e-16\t0.22\t0.04\t0.26\t\t0.17\t15.47\t15.64\n END\t4.525e-11\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t0.98\t\t\tSUM -->\t47.09\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t4.965e-02\t3.235e-16\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   2\t5.215e-04\t3.949e-16\t0.23\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   3\t2.521e-05\t3.194e-16\t0.22\t0.04\t0.26\t\t0.17\t15.47\t15.64\n   4\t3.378e-08\t1.265e-15\t0.22\t0.02\t0.24\t\t0.17\t15.47\t15.64\n END\t7.747e-15\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.22\t\t\tSUM -->\t62.72\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t2.535e-02\t4.834e-16\t0.23\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   2\t1.457e-03\t2.095e-16\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   3\t2.648e-04\t2.327e-14\t0.22\t0.02\t0.24\t\t0.17\t15.47\t15.64\n   4\t6.088e-06\t2.317e-16\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   5\t3.656e-10\t2.684e-15\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n END\t2.685e-15\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.47\t\t\tSUM -->\t78.36\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t1.341e-02\t1.196e-14\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   2\t2.367e-03\t1.753e-13\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n   3\t1.386e-03\t5.636e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   4\t2.007e-04\t4.846e-15\t0.22\t0.02\t0.25\t\t0.17\t15.47\t15.64\n   5\t9.275e-07\t2.515e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n END\t6.822e-11\t\t\t0.23\t\t0.23\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.47\t\t\tSUM -->\t78.36\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t7.510e-03\t2.511e-13\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   2\t3.059e-03\t7.564e-14\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   3\t3.784e-03\t5.288e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   4\t1.388e-03\t1.502e-15\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n   5\t7.445e-05\t2.411e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   6\t6.883e-07\t1.905e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   7\t6.169e-10\t1.597e-15\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n END\t1.603e-15\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.97\t\t\tSUM -->\t109.64\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t3.226e-03\t4.588e-15\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   2\t7.479e-04\t1.645e-13\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n   3\t4.136e-04\t2.518e-12\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   4\t3.384e-05\t4.530e-13\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   5\t3.172e-07\t9.791e-14\t0.22\t0.03\t0.25\t\t0.17\t15.47\t15.64\n   6\t3.361e-10\t8.702e-14\t0.23\t0.03\t0.26\t\t0.17\t15.47\t15.64\n END\t8.702e-14\t\t\t0.22\t\t0.22\t\t0.17\t\t0.17\n\tconverged\t\t\t\tSUM -->\t1.73\t\t\tSUM -->\t94.00\n","category":"page"},{"location":"examples/Example250_NSELidDrivenCavity/","page":"250 : Navier–Stokes Lid-driven cavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"(Image: )","category":"page"},{"location":"examples/Example225_ObstacleProblem/#:-Obstacle-Problem","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"","category":"section"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"(source code)","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"This example computes the solution u of the nonlinear obstacle problem that seeks the minimiser of the energy functional","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"beginaligned\n\tE(u) = frac12 int_Omega lvert nabla u rvert^2 dx - int_Omega f u dx\nendaligned","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"with some right-hand side f within the set of admissible functions that lie above an obstacle  chi","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"beginaligned\n\tmathcalK = lbrace u in H^1_0(Omega)  u geq chi rbrace\nendaligned","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"The obstacle constraint is realised via a penalty term","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"beginaligned\n\tfrac1epsilon  min(0 u - chi) ^2_L^2\nendaligned","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"that is added to the energy above and is automatically differentiated for a Newton scheme.","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"module Example225_ObstacleProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define obstacle and penalty kernel\nconst χ! = (result, x) -> (result[1] = (cos(4 * x[1] * π) * cos(4 * x[2] * π) - 1) / 20)\nfunction obstacle_penalty_kernel!(result, input, qpinfo)\n\tχ!(result, qpinfo.x) # eval obstacle\n\tresult[1] = min(0, input[1] - result[1])\n\treturn nothing\nend\n\nfunction main(; Plotter = nothing, ϵ = 1e-4, nrefs = 6, order = 1, kwargs...)\n\n\t# choose initial mesh\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(obstacle_penalty_kernel!, [id(u)]; factor = 1 / ϵ, kwargs...))\n\tassign_operator!(PD, BilinearOperator([grad(u)]; kwargs...))\n\tassign_operator!(PD, LinearOperator([id(u)]; factor = -1, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n\n\t# create finite element space\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplot([id(u), grad(u)], sol; Plotter = Plotter)\nend\nend","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"Default output:","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"julia> Example225_ObstacleProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.65\n   1\t1.096e-02\t1.989e-15\t0.05\t0.05\t0.09\t\t4.74\t11.64\t16.38\n   2\t1.741e+00\t2.657e-15\t0.04\t0.02\t0.06\t\t1.38\t12.56\t13.93\n   3\t6.074e-02\t1.933e-15\t0.04\t0.02\t0.06\t\t0.02\t8.84\t8.85\n   4\t4.051e-02\t1.370e-15\t0.04\t0.02\t0.06\t\t0.02\t8.81\t8.83\n   5\t2.865e-02\t1.024e-15\t0.04\t0.02\t0.06\t\t0.02\t8.81\t8.82\n   6\t1.848e-02\t8.882e-16\t0.04\t0.04\t0.07\t\t0.02\t8.80\t8.81\n   7\t9.456e-03\t8.562e-16\t0.04\t0.02\t0.06\t\t0.02\t8.79\t8.81\n   8\t2.891e-03\t8.141e-16\t0.04\t0.02\t0.06\t\t0.02\t8.78\t8.80\n   9\t3.888e-04\t8.144e-16\t0.04\t0.02\t0.06\t\t0.02\t8.78\t8.80\n END\t8.144e-16\t\t\t0.04\t\t0.04\t\t0.02\t\t0.02\n\tconverged\t\t\t\tSUM -->\t0.61\t\t\tSUM -->\t92.71\n","category":"page"},{"location":"examples/Example225_ObstacleProblem/","page":"225 : Obstacle Problem","title":"225 : Obstacle Problem","text":"(Image: )","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/#:-Poisson-L-shape-Local-Equilibrated-Fluxes","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"","category":"section"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"(source code)","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"This example computes a local equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"where sigma_h discretisates the exact sigma in the dual mixed problem","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"by some local equilibration strategy, see reference below for details.","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"This examples demonstrates the use of low-level structures to assemble individual problems and a strategy to solve several small problems in parallel by use of non-overlapping node patch groups.","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"reference: Reference\n''A posteriori error estimates for efficiency and error control in numerical simulations'' Lecture Notes by M. Vohralik >Link<","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"module Example211_LshapeAdaptiveEQPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tr2 = x[1]^2 + x[2]^2\n\tφ = atan(x[2], x[1])\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\tresult[1] = r2^(1 / 3) * sin(2 * φ / 3)\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tφ = atan(x[2], x[1])\n\tr2 = x[1]^2 + x[2]^2\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\t∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n\t∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n\tresult[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n\tresult[2] = sin(φ) * ∂r + cos(φ) * ∂φ\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# kernel for equilibration error estimator\nfunction eqestimator_kernel!(result, input, qpinfo)\n\tσ_h, divσ_h, ∇u_h = view(input, 1:2), input[3], view(input, 4:5)\n\tresult[1] = norm(σ_h .- ∇u_h)^2 + divσ_h^2\n\treturn nothing\nend\n\n# unknowns for primal and dual problem\nu = Unknown(\"u\"; name = \"u\")\nσ = Unknown(\"σ\"; name = \"equilibrated fluxes / dual stress\")\n\n# everything is wrapped in a main function\nfunction main(; maxdofs = 4000, μ = 1, order = 2, nlevels = 16, θ = 0.5, Plotter = nothing, kwargs...)\n\n\t# initial grid\n\txgrid = grid_lshape(Triangle2D)\n\n\t# choose some finite elements for primal and dual problem (= for equilibrated fluxes)\n\t# (local equilibration for Pk needs at least BDMk)\n\tif order == 1\n\t\tFEType, FETypeDual = H1P1{1}, HDIVBDM1{2}\n\telseif order == 2\n\t\tFEType, FETypeDual = H1P2{1, 2}, HDIVBDM2{2}\n\telse\n\t\t@error \"order must be 1 or 2\"\n\tend\n\n\t# setup Poisson problem\n\tPD = ProblemDescription(\"Poisson problem\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n\t# define error estimator : || σ_h - ∇u_h ||^2 + || div σ_h ||^2\n\tEQIntegrator = ItemIntegrator(eqestimator_kernel!, [id(σ), div(σ), grad(u)]; resultdim = 1, quadorder = 2 * order)\n\n\t# setup exact error evaluations\n\tErrorIntegrator = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * order, kwargs...)\n\n\t# refinement loop (only uniform for now)\n\tNDofs = zeros(Int, 0)\n\tNDofsDual = zeros(Int, 0)\n\tResultsL2 = zeros(Float64, 0)\n\tResultsH1 = zeros(Float64, 0)\n\tResultsη = zeros(Float64, 0)\n\tsol = nothing\n\tlevel = 0\n\twhile (true)\n\t\tlevel += 1\n\n\t\t# create a solution vector and solve the problem\n\t\tFES = FESpace{FEType}(xgrid)\n\t\tsol = solve(PD, FES)\n\t\tpush!(NDofs, length(view(sol[u])))\n\t\tprintln(\"\\n  SOLVE LEVEL $level\")\n\t\tprintln(\"    ndofs = $(NDofs[end])\")\n\n\t\t# evaluate eqilibration error estimator and append it to sol vector (for plotting etc.)\n\t\tlocal_equilibration_estimator!(sol, FETypeDual)\n\t\tη4cell = evaluate(EQIntegrator, sol)\n\t\tpush!(Resultsη, sqrt(sum(view(η4cell, 1, :))))\n\n\t\t# calculate L2 error, H1 error, estimator, dual L2 error and write to results\n\t\tpush!(NDofsDual, length(view(sol[σ])))\n\t\terror = evaluate(ErrorIntegrator, sol)\n\t\tpush!(ResultsL2, sqrt(sum(view(error, 1, :))))\n\t\tpush!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n\t\tprintln(\"  ESTIMATE\")\n\t\tprintln(\"    ndofsDual = $(NDofsDual[end])\")\n\t\tprintln(\"    estim H1 error = $(Resultsη[end])\")\n\t\tprintln(\"    exact H1 error = $(ResultsH1[end])\")\n\t\tprintln(\"    exact L2 error = $(ResultsL2[end])\")\n\n\t\tif NDofs[end] >= maxdofs\n\t\t\tbreak\n\t\tend\n\n\t\t# mesh refinement\n\t\tif θ >= 1 ## uniform mesh refinement\n\t\t\txgrid = uniform_refine(xgrid)\n\t\telse ## adaptive mesh refinement\n\t\t\tfacemarker = bulk_mark(xgrid, view(η4cell, :), θ; indicator_AT = ON_CELLS)\n\t\t\txgrid = RGB_refine(xgrid, facemarker)\n\t\tend\n\tend\n\n\t# plot\n\tp = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, resolution = (1000, 1000))\n\tscalarplot!(p[1, 1], id(u), sol; levels = 11, title = \"u_h\")\n\tplot_convergencehistory!(p[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\tgridplot!(p[2, 1], xgrid; linewidth = 1)\n\tgridplot!(p[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n\t# print/plot convergence history\n\tprint_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\nend\n\n\n# this function computes the local equilibrated fluxes\n# by solving local problems on (disjunct groups of) node patches\nfunction local_equilibration_estimator!(sol, FETypeDual)\n\t# needed grid stuff\n\txgrid = sol[u].FES.xgrid\n\txCellNodes::Array{Int32, 2} = xgrid[CellNodes]\n\txCellVolumes::Array{Float64, 1} = xgrid[CellVolumes]\n\txNodeCells::Adjacency{Int32} = atranspose(xCellNodes)\n\tnnodes::Int = num_sources(xNodeCells)\n\n\t# get node patch groups that can be solved in parallel\n\tgroup4node = xgrid[NodePatchGroups]\n\n\t# init equilibration space (and Lagrange multiplier space)\n\tFESDual = FESpace{FETypeDual}(xgrid)\n\txItemDofs::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = FESDual[CellDofs]\n\txItemDofs_uh::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = sol[u].FES[CellDofs]\n\n\t# append block in solution vector for equilibrated fluxes\n\tappend!(sol, FESDual; tag = σ)\n\n\t# partition of unity and their gradients = P1 basis functions\n\tPOUFES = FESpace{H1P1{1}}(xgrid)\n\tPOUqf = QuadratureRule{Float64, Triangle2D}(0)\n\n\t# quadrature formulas\n\tqf = QuadratureRule{Float64, Triangle2D}(2 * get_polynomialorder(FETypeDual, Triangle2D))\n\tweights::Array{Float64, 1} = qf.w\n\n\t# some constants\n\tdiv_penalty::Float64 = 1e5      # divergence constraint is realized by penalisation\n\tbnd_penalty::Float64 = 1e60     # penalty for non-involved dofs of a group\n\tmaxdofs::Int = max_num_targets_per_source(xItemDofs)\n\tmaxdofs_uh::Int = max_num_targets_per_source(xItemDofs_uh)\n\n\t# redistribute groups for more equilibrated thread load (first groups are larger)\n\tmaxgroups = maximum(group4node)\n\tgroups = Array{Int, 1}(1:maxgroups)\n\tfor j::Int ∈ 1:floor(maxgroups / 2)\n\t\ta = groups[j]\n\t\tgroups[j] = groups[2*j]\n\t\tgroups[2*j] = a\n\tend\n\tX = Array{Array{Float64, 1}, 1}(undef, maxgroups)\n\n\tThreads.@threads for group in groups\n\t\tgrouptime = @elapsed begin\n\t\t\t@info \"  Starting equilibrating patch group $group on thread $(Threads.threadid())... \"\n\t\t\t# temporary variables\n\t\t\tgraduh = zeros(Float64, 2)\n\t\t\tgradphi = zeros(Float64, 2)\n\t\t\tcoeffs_uh = zeros(Float64, maxdofs_uh)\n\t\t\teval_i = zeros(Float64, 2)\n\t\t\teval_j = zeros(Float64, 2)\n\t\t\teval_phi = zeros(Float64, 1)\n\t\t\tAlocal = zeros(Float64, maxdofs, maxdofs)\n\t\t\tblocal = zeros(Float64, maxdofs)\n\n\t\t\t# init FEBasiEvaluators\n\t\t\tFEE_∇φ = FEEvaluator(POUFES, Gradient, POUqf)\n\t\t\tFEE_xref = FEEvaluator(POUFES, Identity, qf)\n\t\t\tFEE_∇u = FEEvaluator(sol[u].FES, Gradient, qf)\n\t\t\tFEE_div = FEEvaluator(FESDual, Divergence, qf)\n\t\t\tFEE_id = FEEvaluator(FESDual, Identity, qf)\n\n\t\t\t# init system\n\t\t\tA = ExtendableSparseMatrix{Float64, Int64}(FESDual.ndofs, FESDual.ndofs)\n\t\t\tb = zeros(Float64, FESDual.ndofs)\n\n\t\t\t# find dofs at boundary of current node patches\n\t\t\t# and in interior of cells outside of current node patch group\n\t\t\tis_noninvolveddof = zeros(Bool, FESDual.ndofs)\n\t\t\toutside_cell::Bool = false\n\t\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\t\toutside_cell = true\n\t\t\t\tfor k ∈ 1:3\n\t\t\t\t\tif group4node[xCellNodes[k, cell]] == group\n\t\t\t\t\t\toutside_cell = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif (outside_cell) # mark interior dofs of outside cell\n\t\t\t\t\tfor j ∈ 1:maxdofs\n\t\t\t\t\t\tis_noninvolveddof[xItemDofs[j, cell]] = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tfor node ∈ 1:nnodes\n\t\t\t\tif group4node[node] == group\n\t\t\t\t\tfor c ∈ 1:num_targets(xNodeCells, node)\n\t\t\t\t\t\tcell = xNodeCells[c, node]\n\n\t\t\t\t\t\t# find local node number of global node z\n\t\t\t\t\t\t# and evaluate (constant) gradient of nodal basis function phi_z\n\t\t\t\t\t\tlocalnode = 1\n\t\t\t\t\t\twhile xCellNodes[localnode, cell] != node\n\t\t\t\t\t\t\tlocalnode += 1\n\t\t\t\t\t\tend\n\t\t\t\t\t\tFEE_∇φ.citem[] = cell\n\t\t\t\t\t\tupdate_basis!(FEE_∇φ)\n\t\t\t\t\t\teval_febe!(gradphi, FEE_∇φ, localnode, 1)\n\n\t\t\t\t\t\t# read coefficients for discrete flux\n\t\t\t\t\t\tfor j ∈ 1:maxdofs_uh\n\t\t\t\t\t\t\tcoeffs_uh[j] = sol[u][xItemDofs_uh[j, cell]]\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\t# update other FE evaluators\n\t\t\t\t\t\tFEE_∇u.citem[] = cell\n\t\t\t\t\t\tFEE_div.citem[] = cell\n\t\t\t\t\t\tFEE_id.citem[] = cell\n\t\t\t\t\t\tupdate_basis!(FEE_∇u)\n\t\t\t\t\t\tupdate_basis!(FEE_div)\n\t\t\t\t\t\tupdate_basis!(FEE_id)\n\n\t\t\t\t\t\t# assembly on this cell\n\t\t\t\t\t\tfor i in eachindex(weights)\n\t\t\t\t\t\t\tweight = weights[i] * xCellVolumes[cell]\n\n\t\t\t\t\t\t\t# evaluate grad(u_h) and nodal basis function at quadrature point\n\t\t\t\t\t\t\tfill!(graduh, 0)\n\t\t\t\t\t\t\teval_febe!(graduh, FEE_∇u, coeffs_uh, i)\n\t\t\t\t\t\t\teval_febe!(eval_phi, FEE_xref, localnode, i)\n\n\t\t\t\t\t\t\t# compute residual -f*phi_z + grad(u_h) * grad(phi_z) at quadrature point i ( f = 0 in this example !!! )\n\t\t\t\t\t\t\ttemp2 = div_penalty * sqrt(xCellVolumes[cell]) * weight\n\t\t\t\t\t\t\ttemp = temp2 * (graduh[1] * gradphi[1] + graduh[2] * gradphi[2])\n\t\t\t\t\t\t\tfor dof_i ∈ 1:maxdofs\n\t\t\t\t\t\t\t\teval_febe!(eval_i, FEE_id, dof_i, i)\n\t\t\t\t\t\t\t\teval_i .*= weight\n\t\t\t\t\t\t\t\t# right-hand side for best-approximation (grad(u_h)*phi)\n\t\t\t\t\t\t\t\tblocal[dof_i] += (graduh[1] * eval_i[1] + graduh[2] * eval_i[2]) * eval_phi[1]\n\t\t\t\t\t\t\t\t# mass matrix Hdiv\n\t\t\t\t\t\t\t\tfor dof_j ∈ dof_i:maxdofs\n\t\t\t\t\t\t\t\t\teval_febe!(eval_j, FEE_id, dof_j, i)\n\t\t\t\t\t\t\t\t\tAlocal[dof_i, dof_j] += (eval_i[1] * eval_j[1] + eval_i[2] * eval_j[2])\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t# div-div matrix Hdiv * penalty (quick and dirty to avoid Lagrange multiplier)\n\t\t\t\t\t\t\t\teval_febe!(eval_i, FEE_div, dof_i, i)\n\t\t\t\t\t\t\t\tblocal[dof_i] += temp * eval_i[1]\n\t\t\t\t\t\t\t\ttemp3 = temp2 * eval_i[1]\n\t\t\t\t\t\t\t\tfor dof_j ∈ dof_i:maxdofs\n\t\t\t\t\t\t\t\t\teval_febe!(eval_j, FEE_div, dof_j, i)\n\t\t\t\t\t\t\t\t\tAlocal[dof_i, dof_j] += temp3 * eval_j[1]\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\t# write into global A and b\n\t\t\t\t\t\tfor dof_i ∈ 1:maxdofs\n\t\t\t\t\t\t\tdofi = xItemDofs[dof_i, cell]\n\t\t\t\t\t\t\tb[dofi] += blocal[dof_i]\n\t\t\t\t\t\t\tfor dof_j ∈ 1:maxdofs\n\t\t\t\t\t\t\t\tdofj = xItemDofs[dof_j, cell]\n\t\t\t\t\t\t\t\tif dof_j < dof_i # use that Alocal is symmetric\n\t\t\t\t\t\t\t\t\t_addnz(A, dofi, dofj, Alocal[dof_j, dof_i], 1)\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t_addnz(A, dofi, dofj, Alocal[dof_i, dof_j], 1)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\n\t\t\t\t\t\t# reset local A and b\n\t\t\t\t\t\tfill!(Alocal, 0)\n\t\t\t\t\t\tfill!(blocal, 0)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t# penalize dofs that are not involved\n\t\t\tfor j ∈ 1:FESDual.ndofs\n\t\t\t\tif is_noninvolveddof[j]\n\t\t\t\t\tA[j, j] = bnd_penalty\n\t\t\t\t\tb[j] = 0\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t# solve local problem\n\t\t\tX[group] = A \\ b\n\t\tend\n\n\t\t@info \"Finished equilibration patch group $group on thread $(Threads.threadid()) in $(grouptime)s \"\n\tend\n\n\t# write local solutions to global vector\n\tfor group ∈ 1:maxgroups\n\t\tview(sol[σ]) .+= X[group]\n\tend\nend\nend","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"Default output:","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"julia> Example211_LshapeAdaptiveEQPoissonProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t3.140e-16\t0.00\t0.00\t0.00\t\t0.07\t0.05\t0.11\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.13\n\n\n  SOLVE LEVEL 1\n    ndofs = 21\n  ESTIMATE\n    ndofsDual = 57\n    estim H1 error = 0.2528183786149358\n    exact H1 error = 0.19140445035125792\n    exact L2 error = 0.0234220656741654\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t1.223e-15\t0.00\t0.00\t0.00\t\t0.08\t0.11\t0.19\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.21\n\n\n  SOLVE LEVEL 2\n    ndofs = 43\n  ESTIMATE\n    ndofsDual = 135\n    estim H1 error = 0.18200016603404268\n    exact H1 error = 0.13681495929512505\n    exact L2 error = 0.016865181340871987\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t2.456e-15\t0.00\t0.00\t0.00\t\t0.10\t0.11\t0.21\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.23\n\n\n  SOLVE LEVEL 3\n    ndofs = 66\n  ESTIMATE\n    ndofsDual = 219\n    estim H1 error = 0.11766692828553585\n    exact H1 error = 0.08725419470614605\n    exact L2 error = 0.006011386581472842\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t2.376e-15\t0.00\t0.00\t0.00\t\t0.10\t0.15\t0.26\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.28\n\n\n  SOLVE LEVEL 4\n    ndofs = 92\n  ESTIMATE\n    ndofsDual = 312\n    estim H1 error = 0.07655257050518746\n    exact H1 error = 0.058027681015557935\n    exact L2 error = 0.0026001182395898018\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t2.417e-15\t0.00\t0.00\t0.00\t\t0.11\t0.19\t0.30\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.32\n\n\n  SOLVE LEVEL 5\n    ndofs = 118\n  ESTIMATE\n    ndofsDual = 405\n    estim H1 error = 0.05171604216767797\n    exact H1 error = 0.041104122665456884\n    exact L2 error = 0.0016985012363043407\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t3.676e-15\t0.00\t0.00\t0.00\t\t0.15\t0.25\t0.39\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.42\n\n\n  SOLVE LEVEL 6\n    ndofs = 144\n  ESTIMATE\n    ndofsDual = 498\n    estim H1 error = 0.03771183327008747\n    exact H1 error = 0.032018751151057\n    exact L2 error = 0.0015191068660504422\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.685e-15\t0.00\t0.00\t0.00\t\t0.16\t0.37\t0.53\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.56\n\n\n  SOLVE LEVEL 7\n    ndofs = 209\n  ESTIMATE\n    ndofsDual = 735\n    estim H1 error = 0.02874492191872704\n    exact H1 error = 0.025758113969179774\n    exact L2 error = 0.001268063724654\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.04\n END\t---------\t2.624e-15\t0.00\t0.00\t0.00\t\t0.29\t0.52\t0.81\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.85\n\n\n  SOLVE LEVEL 8\n    ndofs = 307\n  ESTIMATE\n    ndofsDual = 1089\n    estim H1 error = 0.021507828339689106\n    exact H1 error = 0.019815349055081526\n    exact L2 error = 0.000774216125263324\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.04\n END\t---------\t4.530e-15\t0.00\t0.00\t0.00\t\t0.36\t0.62\t0.98\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t1.02\n\n\n  SOLVE LEVEL 9\n    ndofs = 379\n  ESTIMATE\n    ndofsDual = 1350\n    estim H1 error = 0.014867738044438302\n    exact H1 error = 0.01373292419142422\n    exact L2 error = 0.0003691243673771289\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.05\n END\t---------\t4.244e-15\t0.00\t0.00\t0.00\t\t0.45\t0.79\t1.24\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t1.29\n\n\n  SOLVE LEVEL 10\n    ndofs = 495\n  ESTIMATE\n    ndofsDual = 1776\n    estim H1 error = 0.01090121012739892\n    exact H1 error = 0.010265785425198652\n    exact L2 error = 0.0003000647680662301\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.06\n END\t---------\t5.013e-15\t0.00\t0.00\t0.01\t\t0.57\t1.15\t1.72\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t1.78\n\n\n  SOLVE LEVEL 11\n    ndofs = 706\n  ESTIMATE\n    ndofsDual = 2547\n    estim H1 error = 0.0077728677457493895\n    exact H1 error = 0.0074056288436767734\n    exact L2 error = 0.00018093425334914803\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.08\n END\t---------\t7.724e-15\t0.00\t0.00\t0.01\t\t0.85\t1.50\t2.35\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t2.43\n\n\n  SOLVE LEVEL 12\n    ndofs = 984\n  ESTIMATE\n    ndofsDual = 3567\n    estim H1 error = 0.0052850819270909115\n    exact H1 error = 0.005059529165319206\n    exact L2 error = 8.388587702363404e-5\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.11\n END\t---------\t9.475e-15\t0.00\t0.00\t0.01\t\t1.25\t2.03\t3.28\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t3.39\n\n\n  SOLVE LEVEL 13\n    ndofs = 1420\n  ESTIMATE\n    ndofsDual = 5184\n    estim H1 error = 0.003560170587726078\n    exact H1 error = 0.0034168917227275965\n    exact L2 error = 4.480682965094028e-5\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.15\n END\t---------\t1.069e-14\t0.01\t0.01\t0.01\t\t1.64\t3.04\t4.69\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t4.84\n\n\n  SOLVE LEVEL 14\n    ndofs = 2028\n  ESTIMATE\n    ndofsDual = 7437\n    estim H1 error = 0.002385771120878144\n    exact H1 error = 0.0023022451635062945\n    exact L2 error = 2.710181572969755e-5\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.21\n END\t---------\t1.420e-14\t0.01\t0.01\t0.02\t\t1.86\t4.59\t6.46\n\tfinished\t\t\t\tSUM -->\t0.02\t\t\tSUM -->\t6.67\n\n\n  SOLVE LEVEL 15\n    ndofs = 3030\n  ESTIMATE\n    ndofsDual = 11154\n    estim H1 error = 0.001571275954275814\n    exact H1 error = 0.001519399670443651\n    exact L2 error = 1.3670573319285668e-5\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.31\n END\t---------\t1.723e-14\t0.01\t0.02\t0.03\t\t2.57\t6.40\t8.97\n\tfinished\t\t\t\tSUM -->\t0.03\t\t\tSUM -->\t9.28\n\n\n  SOLVE LEVEL 16\n    ndofs = 4583\n  ESTIMATE\n    ndofsDual = 16917\n    estim H1 error = 0.0010426891691066044\n    exact H1 error = 0.0010103037444213867\n    exact L2 error = 6.947072990565313e-6\n\n    ndofs   |   || u - u_h ||    order | || ∇(u - u_h) ||   order |         η          order |\n============|==========================|==========================|==========================|\n        21  |     2.342e-02      0.00  |     1.914e-01      0.00  |     2.528e-01      0.00  |\n        43  |     1.687e-02      0.92  |     1.368e-01      0.94  |     1.820e-01      0.92  |\n        66  |     6.011e-03      4.82  |     8.725e-02      2.10  |     1.177e-01      2.04  |\n        92  |     2.600e-03      5.05  |     5.803e-02      2.46  |     7.655e-02      2.59  |\n       118  |     1.699e-03      3.42  |     4.110e-02      2.77  |     5.172e-02      3.15  |\n       144  |     1.519e-03      1.12  |     3.202e-02      2.51  |     3.771e-02      3.17  |\n       209  |     1.268e-03      0.97  |     2.576e-02      1.17  |     2.874e-02      1.46  |\n       307  |     7.742e-04      2.57  |     1.982e-02      1.36  |     2.151e-02      1.51  |\n       379  |     3.691e-04      7.03  |     1.373e-02      3.48  |     1.487e-02      3.50  |\n       495  |     3.001e-04      1.55  |     1.027e-02      2.18  |     1.090e-02      2.32  |\n       706  |     1.809e-04      2.85  |     7.406e-03      1.84  |     7.773e-03      1.91  |\n       984  |     8.389e-05      4.63  |     5.060e-03      2.29  |     5.285e-03      2.32  |\n      1420  |     4.481e-05      3.42  |     3.417e-03      2.14  |     3.560e-03      2.15  |\n      2028  |     2.710e-05      2.82  |     2.302e-03      2.22  |     2.386e-03      2.25  |\n      3030  |     1.367e-05      3.41  |     1.519e-03      2.07  |     1.571e-03      2.08  |\n      4583  |     6.947e-06      3.27  |     1.010e-03      1.97  |     1.043e-03      1.98  |","category":"page"},{"location":"examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"211 : Poisson L-shape Local Equilibrated Fluxes","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"(Image: )","category":"page"},{"location":"linearoperator/#LinearOperator","page":"LinearOperator","title":"LinearOperator","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"A linear operator allows to add vectors to the right-hand side of the system that usually refer to right-hand side data or linearisations of PDE operators (see remark in NonlinearOperator example).","category":"page"},{"location":"linearoperator/#Constructors","page":"LinearOperator","title":"Constructors","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Any, Any}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tA,\n\tu_test,\n\tu_args;\n\tkwargs...)\n\nGenerates a linear form from a user-provided matrix A, which can be an AbstractMatrix or a FEMatrix with multiple blocks. The arguments uargs specify which coefficients of the current solution should be multiplied with the matrix and utest specifies where to put the (blocks of the) resulting vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Any}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tb,\n\tu_test;\n\tkwargs...)\n\nGenerates a linear form from a user-provided vector b, which can be an AbstractVector or a FEVector with multiple blocks. The argument u_test specifies where to put the (blocks of the) vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tkernel!::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: LinearOperator(kernel!, [id(1)]; kwargs...) generates the right-hand side for a Poisson problem, where kernel! evaluates the right-hand side.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#Example-right-hand-side","page":"LinearOperator","title":"Example - right-hand side","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"For a right-hand side operator of a Poisson problem with some given function f(x) a kernel could look like","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"function kernel!(result, qpinfo)\n    result[1] = f(qpinfo.x)\nend","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"and the coressponding LinearOperator constructor call reads","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"u = Unknown(\"u\")\nNonlinearOperator(kernel!, [id(u)])","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"The second argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the test function.","category":"page"},{"location":"examples/Example201_PoissonProblem/#:-Poisson-Problem","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"","category":"section"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"(source code)","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"module Example201_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2]\nend\n\nfunction main(; μ = 1.0, nrefs = 4, order = 2, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplot([id(u), grad(u)], sol; Plotter = Plotter)\nend\n\nend # module","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"Default output:","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"julia> Example201_PoissonProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.15\n END\t---------\t3.809e-16\t0.01\t0.01\t0.01\t\t1.15\t3.23\t4.38\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t4.53\n","category":"page"},{"location":"examples/Example201_PoissonProblem/","page":"201 : Poisson-Problem","title":"201 : Poisson-Problem","text":"(Image: )","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/#:-Stokes-iterated-penalty-method","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"","category":"section"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"(source code)","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbf0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"with some μ parameter mu.","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain with the iterated penalty method suggested in the reference below adapted to the Bernardi–Raugel finite element method. Given intermediate solutions  mathbfu_h and  p_h the next approximations are computed by the two equations","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"beginaligned\n(nabla mathbfu_h^next nabla mathbfv_h) + lambda (mathrmdiv_h(mathbfu_h) mathrmdiv_h(mathbfv_h))  = (mathbffmathbfv_h) + (p_hmathrmdiv(mathbfv_h))\n textfor all  mathbfv_h in mathbfV_h\n(p^next_hq_h)  = (p_hq_h) - lambda (mathrmdiv(mathbfu_h^next)q_h)  textfor all  q_h in Q_h\nendaligned","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"This is done consecutively until the residual of both equations is small enough. The discrete divergence is computed via a RT0 reconstruction operator that preserves the disrete divergence. (another way would be to compute Binv(M)B' where M is the mass matrix of the pressure and B is the matrix for the div-pressure block).","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"reference: Reference\n\"An iterative penalty method for the finite element solution of the stationary Navier-Stokes equations\",\nR. Codina,\nComputer Methods in Applied Mechanics and Engineering Volume 110, Issues 3–4 (1993),\n>Journal-Link<","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"module Example235_StokesIteratedPenalty\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# data for Hagen-Poiseuille flow\nfunction p!(result, qpinfo)\n\tx = qpinfo.x\n\tμ = qpinfo.params[1]\n\tresult[1] = μ * (-2 * x[1] + 1.0)\nend\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[2] * (1.0 - x[2])\n\tresult[2] = 0.0\nend\n# kernel for div projection\nfunction div_projection!(result, input, qpinfo)\n\tresult[1] = input[1] - qpinfo.params[1] * input[2]\nend\n# kernel for exact error calculator\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\tp!(view(result, 3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, λ = 1e4, μ = 1.0, nrefs = 5, kwargs...)\n\n\t# initial grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# Bernardi--Raugel element with reconstruction operator\n\tFETypes = (H1BR{2}, L2P0{1})\n\tPenaltyDivergence = Reconstruct{HDIVRT0{2}, Divergence}\n\n\t# generate two problems\n\t# one for velocity, one for pressure\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tPDu = ProblemDescription(\"Stokes IPM - velocity update\")\n\tassign_unknown!(PDu, u)\n\tassign_operator!(PDu, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n\tassign_operator!(PDu, BilinearOperator([apply(u, PenaltyDivergence)]; store = true, factor = λ, kwargs...))\n\tassign_operator!(PDu, LinearOperator([div(u)], [id(p)]; factor = 1, kwargs...))\n\tassign_operator!(PDu, InterpolateBoundaryData(u, u!; regions = 1:4, params = [μ], bonus_quadorder = 4, kwargs...))\n\n\tPDp = ProblemDescription(\"Stokes IPM - pressure update\")\n\tassign_unknown!(PDp, p)\n\tassign_operator!(PDp, BilinearOperator([id(p)]; store = true, kwargs...))\n\tassign_operator!(PDp, LinearOperator(div_projection!, [id(p)], [id(p), div(u)]; params = [λ], factor = 1, kwargs...))\n\n\t# show and solve problem\n\tFES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n\tsol = FEVector([FES[1], FES[2]]; tags = [u, p])\n\tSC1 = SolverConfiguration(PDu; init = sol, maxiterations = 1, target_residual = 1e-8, constant_matrix = true, kwargs...)\n\tSC2 = SolverConfiguration(PDp; init = sol, maxiterations = 1, target_residual = 1e-8, constant_matrix = true, kwargs...)\n\tsol, nits = iterate_until_stationarity([SC1, SC2]; init = sol, kwargs...)\n\t@info \"converged after $nits iterations\"\n\n\t# error calculation\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), id(p)]; quadorder = 4, params = [μ], kwargs...)\n\terror = evaluate(ErrorIntegratorExact, sol)\n\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\tL2errorP = sqrt(sum(view(error, 3, :)))\n\t@info \"L2error(u) = $L2errorU\"\n\t@info \"L2error(p) = $L2errorP\"\n\n\t# plot\n\tplot([id(u), id(p)], sol; Plotter = Plotter)\nend\nend","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"Default output:","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"julia> Example235_StokesIteratedPenalty.main()\n    1\t\tres[1] = 4.13e+04 (5.637e-11)\tres[2] = 9.01e-03 (0.000e+00)\n    2\t\tres[1] = 5.80e-02 (5.705e-11)\tres[2] = 2.75e-06 (0.000e+00)\n    3\t\tres[1] = 2.74e-05 (5.530e-11)\tres[2] = 1.05e-09 (0.000e+00)\n    4\t\tres[1] = 1.70e-08 (5.488e-11)\tres[2] = 5.50e-13 (0.000e+00)\n    5\t\tres[1] = 9.12e-11 (5.583e-11)\tres[2] = 2.85e-13 (0.000e+00)","category":"page"},{"location":"examples/Example235_StokesIteratedPenalty/","page":"235 : Stokes iterated penalty method","title":"235 : Stokes iterated penalty method","text":"(Image: )","category":"page"},{"location":"examples/Example265_FlowTransport/#:-Flow-Transport","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"","category":"section"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"(source code)","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"This example solve the Stokes problem in an Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a stationary species concentration mathbfc such that","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nmathbfc_t - kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"with some viscosity parameter and diffusion parameter kappa.","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation three possibilities can be chosen:","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"Classical Bernardi–Raugel stationary finite element discretisations mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = false]\nAs in 1. but with divergence-free reconstruction operator in convection term Pi_textreconst mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = true]\nTime-dependent upwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces [set FVtransport = true]","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"Observe that the divergence-free postprocessing helps a lot for mass conservation, but is still not perfect. The finite volume upwind discretisation ensures mass conservation.","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"module Example265_FlowTransport\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n# boundary data\nfunction u_inlet!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 4*x[2]*(1-x[2])\n    result[2] = 0\nend\nfunction c_inlet!(result, qpinfo)\n    result[1] = (1-qpinfo.x[2])*qpinfo.x[2]\nend\n\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops,1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\nend\n\nfunction kernel_convection!(result, ∇T, u, qpinfo)\n    result[1] = ∇T[1]*u[1] + ∇T[2]*u[2]\nend\n\nfunction kernel_inlet!(result, input, qpinfo)\n    c_inlet!(result, qpinfo)\n    result[1] *= -input[1]\nend\n\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, FVtransport = true, μ = 1, kwargs...)\n\n    # load mesh and refine\n    xgrid = uniform_refine(simplexgrid(Triangulate;\n    points = [0 0; 3 0; 3 -3; 7 -3; 7 0; 10 0; 10 1; 6 1; 6 -2; 4 -2; 4 1; 0 1]',\n    bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 12; 12 1]',\n    bfaceregions = [1; 1; 1; 1; 1; 2; 3; 3; 3; 3; 3; 4],\n    regionpoints = [0.5 0.5;]',\n    regionnumbers = [1],\n    regionvolumes = [1.0]), nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    T = Unknown(\"T\"; name = \"temperature\", dim = 1)\n\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u_inlet!; regions = 4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1,3], kwargs...))\n\n    # add transport equation of species\n    PDT = ProblemDescription(\"transport problem\")\n    assign_unknown!(PDT, T)\n    if FVtransport ## FVM discretisation of transport equation (pure upwind convection)\n        τ = 1e3\n        assign_operator!(PDT, CallbackOperator(assemble_fv_operator!(), [u]; kwargs...))\n        assign_operator!(PDT, BilinearOperator([id(T)]; store = true, factor = 1/τ, kwargs...))\n        assign_operator!(PDT, LinearOperator([id(T)], [id(T)]; factor = 1/τ, kwargs...))\n    else ## FEM discretisation of transport equation (with small diffusion term)\n        assign_operator!(PDT, BilinearOperator([grad(T)]; factor = 1e-6, kwargs...))\n        assign_operator!(PDT, BilinearOperator(kernel_convection!, [id(T)], [grad(T)], [id_u]; kwargs...))\n        assign_operator!(PDT, InterpolateBoundaryData(T, c_inlet!; regions = [4], kwargs...))\n    end\n\n    # generate FESpaces and a solution vector for all 3 unknowns\n    FETypes = [H1BR{2}, L2P0{1}, FVtransport ? L2P0{1} : H1P1{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 3]\n    sol = FEVector(FES; tags = [u,p,T])\n\n    # solve the two problems separately\n    sol = solve(PD; init = sol, kwargs...)\n    sol = solve(PDT; init = sol, maxiterations = 20, target_residual = 1e-12, constant_matrix = true, kwargs...)\n\n    # print minimal and maximal concentration to check max principle (shoule be in [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(view(sol[T]))),$(maximum(view(sol[T])))]\")\n\n    # plot\n    plot([id(u), id(T)], sol; Plotter = Plotter, ncols = 1, spacing = 0.25)\nend\n\n# pure convection finite volume operator for transport\nfunction assemble_fv_operator!()\n\n    BndFluxIntegrator = ItemIntegrator(kernel_inflow!, [normalflux(1)]; entities = ON_BFACES)\n    FluxIntegrator = ItemIntegrator([normalflux(1)]; entities = ON_FACES)\n    fluxes::Matrix{Float64} = zeros(Float64,1,0)\n\n    function closure(A, b, args; assemble_matrix = true, assemble_rhs = true, kwargs...)\n\n    # prepare grid and stash\n    xgrid = args[1].FES.xgrid\n    nfaces = size(xgrid[FaceCells],2)\n    if size(fluxes,2) < nfaces\n        fluxes = zeros(Float64, 1, nfaces)\n    end\n\n    # right-hand side = boundary inflow fluxes if velocity points inward\n    if assemble_rhs\n        fill!(fluxes, 0)\n        evaluate!(fluxes, BndFluxIntegrator, [args[1]])\n        facecells = xgrid[FaceCells]\n        bface2face = xgrid[BFaceFaces]\n        for bface in 1 : lastindex(bface2face)\n            b[facecells[1, bface2face[bface]]] -= fluxes[bface]\n        end\n    end\n\n    # assemble upwind finite volume fluxes over cell faces into matrix\n    if assemble_matrix\n        # integrate normalfux of velocity\n        fill!(fluxes, 0)\n        evaluate!(fluxes, FluxIntegrator, [args[1]])\n\n        cellfaces = xgrid[CellFaces]\n        cellfacesigns = xgrid[CellFaceSigns]\n        for cell = 1 : num_cells(xgrid)\n            nfaces4cell = num_targets(cellfaces, cell)\n            for cf = 1 : nfaces4cell\n                face = cellfaces[cf,cell]\n                other_cell = facecells[1,face]\n                if other_cell == cell\n                    other_cell = facecells[2,face]\n                end\n                flux = fluxes[face] * cellfacesigns[cf,cell]\n                if (other_cell > 0)\n                    flux *= 1 // 2 # because it will be accumulated on two cells\n                end\n                if flux > 0 # flow from cell to other_cell or out of domain\n                    _addnz(A,cell,cell,flux,1)\n                    if other_cell > 0\n                        _addnz(A,other_cell,cell,-flux,1)\n                        # otherwise flow goes out of domain\n                    end\n                else # flow from other_cell into cell or into domain\n                    _addnz(A,cell,cell,1e-16,1) # add zero to keep pattern for LU\n                    if other_cell > 0 # flow comes from neighbour cell\n                        _addnz(A,other_cell,other_cell,-flux,1)\n                        _addnz(A,cell,other_cell,flux,1)\n                    end\n                    # otherwise flow comes from outside into domain, handled in rhs side loop above\n                end\n            end\n        end\n    end\n    return nothing\n    end\nend\n\n\nfunction kernel_inflow!(result, input, qpinfo)\n    if input[1] < 0 # if velocity points into domain\n        c_inlet!(result, qpinfo)\n        result[1] *= input[1]\n    else\n        result[1] = 0\n    end\nend\n\n\n\nend","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"Default output:","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"julia> Example265_FlowTransport.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.76\n END\t---------\t1.034e-11\t0.10\t0.16\t0.26\t\t13.93\t51.23\t65.16\n\tfinished\t\t\t\tSUM -->\t0.26\t\t\tSUM -->\t65.93\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.73\n   1\t3.976e-02\t8.049e-17\t0.01\t0.00\t0.01\t\t1.51\t3.35\t4.86\n   2\t4.264e-05\t8.455e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   3\t7.825e-07\t8.441e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   4\t5.955e-08\t8.496e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   5\t1.002e-08\t8.501e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   6\t1.709e-09\t8.459e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   7\t2.860e-10\t8.361e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   8\t4.728e-11\t8.466e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n   9\t7.766e-12\t8.670e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n  10\t1.271e-12\t8.637e-17\t0.00\t0.00\t0.00\t\t0.00\t0.00\t0.01\n END\t2.077e-13\t\t\t0.00\t\t0.00\t\t0.00\t\t0.00\n\tconverged\t\t\t\tSUM -->\t0.02\t\t\tSUM -->\t5.63\n\n\n[min(c),max(c)] = [0.03950832201086902,0.24870388160205545]","category":"page"},{"location":"examples/Example265_FlowTransport/","page":"265 : Flow + Transport","title":"265 : Flow + Transport","text":"(Image: )","category":"page"},{"location":"pdesolvers_dt/#Time-dependent-Solvers","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"For time-dependent (non-stationary) problems the user currently has these options:","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"fully manual option: add custom time derivatives to the problem (i.e. a mass matrix as a BilinearOperator and necessary LinearOperators for evaluating the previous time step(s), if more than one previous time step needs to be remembered, their memorization must be handled manually, e.g. by registering further unknowns)\nfully automatic option: reframe the ProblemDescription as an ODE problem and evolve it via DifferentialEquations with ExtendableFEMDiffEQExt.jl extension (see below)","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Several time-dependent examples are available where both options are implemented, see e.g. Examples103 (Burger's equation) and Example205 (Heat equation).","category":"page"},{"location":"pdesolvers_dt/#Extension-ExtendableFEMDiffEQExt.jl","page":"Time-dependent Solvers","title":"Extension ExtendableFEMDiffEQExt.jl","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"This extension is automatically loaded when also DifferentialEquations.jl is used. It allows to easily reframe the ProblemDescription for the spacial differential operator of the PDE as the right-hand side of an ODE. Here, the ProblemDescription contains the right-hand side description of the ODE","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"beginaligned\nM u_t(t)  = b(u(t)) - A(u(t)) u(t)\nendaligned","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"where A and b correspond to the assembled (linearized) spacial operator and the right-hand side operators in the ProblemDescription. Note, that A comes with a minus sign. The matrix M is the mass matrix and can be customized somewhat (as long as it stays constant). The operators in the ProblemDescription might depend on time (if their kernels use qpinfo.time) and will be reassembled in each time step. To avoid this single operator reassemblies can be switched off by using the store = true argument. The full matrix reassembly can be skipped if constant_matrix = true is used in the SolverConfiguration.","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Modules = [ExtendableFEM]\nPages = [\"solvers_diffeq.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tPD::ProblemDescription,\n\tFES,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into an ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nAdditional keyword arguments:\n\nverbosity: verbosity level. Default: 0\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"note: Note\nThe solvers of DifferentialEquations should be run with the autodiff=false option as it is currently not possible to differentiate the right-hand side of the generated ODEProblem with respect to time.","category":"page"},{"location":"pdesolvers_dt/#Example-:-2D-Heat-equation","page":"Time-dependent Solvers","title":"Example : 2D Heat equation","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"The following ProblemDescription yields the space discretisation of the heat equation (including homogeneous boundary conditions and equivalent to the Poisson equation).","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"PD = ProblemDescription(\"Heat Equation\")\nu = Unknown(\"u\"; name = \"temperature\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\nassign_operator!(PD, HomogeneousBoundaryData(u))","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Given a finite element space FES and an initial FEVector sol for the unknown, the ODEProblem for some time interval (0,T) can be generated and solved via","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"prob = generate_ODEProblem(PD, FES, (0, T); init = sol)\nDifferentialEquations.solve(prob, Rosenbrock23(autodiff = false), dt = 1e-3, dtmin = 1e-6, adaptive = true)","category":"page"},{"location":"postprocessing/#Other-packages","page":"Other packages","title":"Other packages","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"A lot of functionality is already provided by the bases packages, e.g.:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"ExtendableGrids.jl offers an interface to WriteVTK.jl which can be used, e.g. in combination with nodevalues interpolations or (piecewise constant) item integrator results. There is also the CellFinder that can be used to find the right cell for a certain point of the domain.\nExtendableFEMBase.jl offers a PointEvaluator and a SegmentIntegrator to evaluate solutions at arbitrary points of the domain or integrating along 1D line intersections with the cells of the triangulation. It also provides some basic unicode plots.\nGridVisualize.jl provides grid and scalar piecewise linear function plotting for various plotting backends on simplicial grids in one, two or three space dimensions. The main supported backends are PyPlot, GLMakie and PlutoVista.","category":"page"},{"location":"examples/Example205_HeatEquation/#:-Heat-equation","page":"205 : Heat equation","title":"205 : Heat equation","text":"","category":"section"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"(source code)","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"This example computes the solution u of the two-dimensional heat equation","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"beginaligned\nu_t - Delta u  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"for homogeneous Dirichlet boundary conditions and some given initial state on the unit square domain Omega on a given grid.","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"module Example205_HeatEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\n\n# initial state u at time t0\nfunction initial_data!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = exp(-5 * x[1]^2 - 5 * x[2]^2)\nend\n\nfunction main(; nrefs = 4, T = 2.0, τ = 1e-3, order = 2, use_diffeq = true,\n\tsolver = Rosenbrock23(autodiff = false), Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Heat Equation\")\n\tu = Unknown(\"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n\t# prepare solution vector and initial data u0\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], initial_data!; bonus_quadorder = 5)\n\n\t# init plotter and plot u0\n\tp = plot([id(u)], sol; add = 1, Plotter = Plotter, title_add = \" (t = 0)\")\n\n\tif (use_diffeq)\n\t\t# generate DifferentialEquations.ODEProblem\n\t\tprob = generate_ODEProblem(PD, FES, (0.0, T); init = sol, constant_matrix = true)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-6, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tM = FEMatrix(FES)\n\t\tassemble!(M, BilinearOperator([id(1)]))\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, constant_matrix = true, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor(T / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state\n\tplot!(p, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\nend\n\nend # module","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"Default output:","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"julia> Example205_HeatEquation.main()","category":"page"},{"location":"examples/Example205_HeatEquation/","page":"205 : Heat equation","title":"205 : Heat equation","text":"(Image: )","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/#:-Navier–Stokes-Planar-Lattice-Flow","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"","category":"section"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"(source code)","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"This example computes an approximation to the planar lattice flow test problem of the Stokes equations","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"beginaligned\n- nu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"with an exterior force mathbff and some viscosity parameter nu and Dirichlet boundary data for mathbfu.","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"Here the exact data for the planar lattice flow","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"beginaligned\nmathbfu(xyt)  = exp(-8 pi^2 nu t) beginpmatrix sin(2 pi x) sin(2 pi y)  cos(2 pi x) cos(2 pi y) endpmatrix\np(xyt)  = exp(-8 pi^2 nu t) ( cos(4 pi x) - cos(4 pi y))  4\nendaligned","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"is prescribed at fixed time t = 0 with mathbff = - nu Delta mathbfu.","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"In this example the Navier-Stokes equations are solved with a pressure-robust variant of the Bernardi–Raugel finite element method and the nonlinear convection term (that involves reconstruction operators) is automatically differentiated for a Newton iteration.","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"module Example252_NSEPlanarLatticeFlow\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact velocity (and Dirichlet data)\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n\tresult[2] = cos(2 * pi * x[1]) * cos(2 * pi * x[2])\nend\n\n# right-hand side f := -μ Δu + (u⋅∇)u + ∇p\nfunction f!(μ)\n\tα = [0, 0]\n\tfunction closure(result, qpinfo)\n\t\tx = qpinfo.x\n\t\tresult[1] = (μ * 8 * pi^2 + α[1]) * sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n\t\tresult[2] = (μ * 8 * pi^2 + α[2]) * cos(2 * pi * x[1]) * cos(2 * pi * x[2])\n\tend\nend\n\n# exact pressure\nfunction p!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = (cos(4 * pi * x[1]) - cos(4 * pi * x[2])) / 4\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n\tu, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n\tμ = qpinfo.params[1]\n\tresult[1] = dot(u, view(∇u, 1:2))\n\tresult[2] = dot(u, view(∇u, 3:4))\n\tresult[3] = μ * ∇u[1] - p[1]\n\tresult[4] = μ * ∇u[2]\n\tresult[5] = μ * ∇u[3]\n\tresult[6] = μ * ∇u[4] - p[1]\n\tresult[7] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\tp!(view(result, 3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\nfunction main(; μ = 0.001, nrefs = 5, reconstruct = true, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tid_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!(μ), [id_u]; kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# prepare FESpace\n\tFES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# move integral mean of pressure\n\tpintegrate = ItemIntegrator([id(p)])\n\tpmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n\tview(sol[p]) .-= pmean\n\n\t# error calculation\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), id(p)]; quadorder = 4, params = [μ], kwargs...)\n\terror = evaluate(ErrorIntegratorExact, sol)\n\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\tL2errorP = sqrt(sum(view(error, 3, :)))\n\t@info \"L2error(u) = $L2errorU\"\n\t@info \"L2error(p) = $L2errorP\"\n\n\t# plot\n\tplot([id(u), id(p)], sol; Plotter = Plotter)\nend\n\nend # module","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"Default output:","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"julia> Example252_NSEPlanarLatticeFlow.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.75\n   1\t1.251e-01\t8.924e-14\t0.55\t0.17\t0.72\t\t11.78\t63.74\t75.52\n   2\t9.161e-02\t1.363e-13\t0.56\t0.15\t0.71\t\t6.53\t65.77\t72.30\n   3\t4.279e-07\t9.485e-13\t0.56\t0.12\t0.68\t\t0.96\t54.04\t55.00\n END\t3.381e-11\t\t\t0.55\t\t0.56\t\t0.96\t\t0.96\n\tconverged\t\t\t\tSUM -->\t2.66\t\t\tSUM -->\t204.54\n","category":"page"},{"location":"examples/Example252_NSEPlanarLatticeFlow/","page":"252 : Navier–Stokes Planar Lattice Flow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"(Image: )","category":"page"},{"location":"interpolateboundarydata/#InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"","category":"section"},{"location":"interpolateboundarydata/","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/interpolateboundarydata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"interpolateboundarydata/#ExtendableFEM.InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"ExtendableFEM.InterpolateBoundaryData","text":"function InterpolateBoundaryData(u, data!::Function; kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to match the standard interpolation of the provided data! function. The header of this function needs to be conform to the interface\n\ndata!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x provides the global coordinates of the quadrature/evaluation point.\n\nKeyword arguments:\n\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nregions: subset of regions where operator should be assembly only. Default: Any[]\nname: name for operator used in printouts. Default: ''BoundaryData''\nbonus_quadorder: additional quadrature order added to the quadorder chosen by the interpolator. Default: 0\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"examples/Example106_NonlinearDiffusion/#:-Nonlinear-Diffusion","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"","category":"section"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"(source code)","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"This example solves the nonlinear diffusion equation","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"beginaligned\nu_t - Delta u^m  = 0\nendaligned","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"in Omega = (-11) with homogeneous Neumann boundary conditions.","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"module Example106_NonlinearDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\nusing GridVisualize\n\n# Barenblatt solution\n# (see Barenblatt, G. I. \"On nonsteady motions of gas and fluid in porous medium.\" Appl. Math. and Mech.(PMM) 16.1 (1952): 67-78.)\nfunction u_exact!(result, qpinfo)\n\tt = qpinfo.time\n\tx = qpinfo.x[1]\n\tm = qpinfo.params[1]\n\ttx = t^(-1.0 / (m + 1.0))\n\txx = x * tx\n\txx = xx * xx\n\txx = 1 - xx * (m - 1) / (2.0 * m * (m + 1))\n\tif xx < 0.0\n\t\txx = 0.0\n\tend\n\tresult[1] = tx * xx^(1.0 / (m - 1.0))\nend\n\nfunction kernel_nonlinear!(result, input, qpinfo)\n\tu, ∇u = view(input, 1), view(input, 2)\n\tm = qpinfo.params[1]\n\tresult[1] = m * u[1]^(m - 1) * ∇u[1]\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\tm = 2,\n\th = 0.05,\n\tt0 = 0.001,\n\tT = 0.01,\n\torder = 1,\n\tτ = 0.0001,\n\tPlotter = nothing,\n\tuse_diffeq = true,\n\tuse_masslumping = true,\n\tsolver = ImplicitEuler(autodiff = false),\n\tkwargs...)\n\n\t# load mesh and exact solution\n\txgrid = simplexgrid(-1:h:1)\n\n\t# set finite element types [surface height, velocity]\n\tFEType = H1Pk{1, 1, order}\n\n\t# generate empty PDEDescription for three unknowns (h, u)\n\tPD = ProblemDescription(\"Nonlinear Diffusion Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [grad(u)], [id(u), grad(u)]; params = [m], bonus_quadorder = 2))\n\n\t# prepare solution vector and initial data\n\tFES = FESpace{FEType}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], u_exact!; time = t0, params = [m])\n\n\t# init plotter and plot u0\n\tp = GridVisualizer(; Plotter = Plotter, layout = (1, 2), size = (800,400))\n\tscalarplot!(p[1, 1], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1, title = \"t = $t0\")\n\n\t# generate mass matrix (with mass lumping)\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(1)]; lump = 2 * use_masslumping))\n\n\tif (use_diffeq)\n\t\t# generate ODE problem\n\t\tprob = ExtendableFEM.generate_ODEProblem(PD, FES, (t0, T); init = sol, mass_matrix = M.entries.cscmatrix)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-8, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor((T - t0) / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state and exact solution for comparison\n\tscalarplot!(p[1, 2], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1, title = \"t = $T\")\n\tinterpolate!(sol[1], u_exact!; time = T, params = [m])\n\tscalarplot!(p[1, 2], id(u), sol; clear = false, color = :green, label = \"u\", legend = :best)\nend\nend","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"Default output:","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"julia> Example106_NonlinearDiffusion.main()","category":"page"},{"location":"examples/Example106_NonlinearDiffusion/","page":"106 : Nonlinear Diffusion","title":"106 : Nonlinear Diffusion","text":"(Image: )","category":"page"},{"location":"examples/Example240_SVRTEnrichment/#:-Stokes-RT-enrichment","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"","category":"section"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"(source code)","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"with exterior force mathbff and some parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"The problem will be solved by a (P_k oplus RTenrichment) times P_k-1 scheme, which can be seen as an inf-sup stabilized Scott-Vogelius variant that works with general meshes, see references below. Therein, the velocity space employs continuous P_k functions plus certain (only H(div)-conforming) Raviart-Thomas functions and a discontinuous P_k-1 pressure space leading to an exactly divergence-free discrete velocity. In a reduction step (that can be triggered with the reduce switch) all higher order pressure dofs and the enrichment dofs can be eliminated from the system.","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"reference: Reference\n\"A low-order divergence-free H(div)-conforming finite element method for Stokes flows\",\nX. Li, H. Rui,\nIMA Journal of Numerical Analysis (2021),\n>Journal-Link< >Preprint-Link<\"Inf-sup stabilized Scott–Vogelius pairs on general simplicial grids by Raviart–Thomas enrichment\",\nV. John, X. Li, C. Merdon, H. Rui,\n>Preprint-Link<","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"module Example240_SVRTEnrichment\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing Triangulate\nusing SimplexGridFactory\nusing Symbolics\n\n# exact data for problem by Symbolics\nfunction prepare_data(; μ = 1)\n\n\t@variables x y\n\n\t# stream function ξ\n\tξ = -sin(2 * pi * x) * cos(2 * pi * y) / (2 * pi)\n\n\t# velocity u = curl ξ\n\t∇ξ = Symbolics.gradient(ξ, [x, y])\n\tu = [-∇ξ[2], ∇ξ[1]]\n\n\t# pressure\n\tp = (cos(4 * pi * x) - cos(4 * pi * y)) / 4\n\n\t# gradient of velocity\n\t∇u = Symbolics.jacobian(u, [x, y])\n\t∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1, 1], [x])+Symbolics.gradient(∇u[1, 2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2, 1], [x])+Symbolics.gradient(∇u[2, 2], [y]))[1],\n\t]\n\n\t# right-hand side\n\tf = -μ * Δu + Symbolics.gradient(p, [x, y])\n\n\t# build functions\n\tp_eval = build_function(p, x, y, expression = Val{false})\n\tu_eval = build_function(u, x, y, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n\tf_eval = build_function(f, x, y, expression = Val{false})\n\n\treturn f_eval[2], u_eval[2], ∇u_eval[2], p_eval\nend\n\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n\t∇u, p = view(u_ops, 1:4), view(u_ops, 5)\n\tμ = qpinfo.params[1]\n\tresult[1] = μ * ∇u[1] - p[1]\n\tresult[2] = μ * ∇u[2]\n\tresult[3] = μ * ∇u[3]\n\tresult[4] = μ * ∇u[4] - p[1]\n\tresult[5] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction get_grid2D(nref; uniform = false, barycentric = false)\n\tif uniform || barycentric\n\t\tgen_ref = 0\n\telse\n\t\tgen_ref = nref\n\tend\n\tgrid = simplexgrid(Triangulate;\n\t\tpoints = [0 0; 0 1; 1 1; 1 0]',\n\t\tbfaces = [1 2; 2 3; 3 4; 4 1]',\n\t\tbfaceregions = [1, 2, 3, 4],\n\t\tregionpoints = [0.5 0.5;]',\n\t\tregionnumbers = [1],\n\t\tregionvolumes = [4.0^(-gen_ref - 1)])\n\tif uniform\n\t\tgrid = uniform_refine(grid, nref)\n\tend\n\tif barycentric\n\t\tgrid = barycentric_refine(grid)\n\tend\n\treturn grid\nend\n\nfunction main(; nrefs = 5, μ = 1, order = 2, Plotter = nothing, enrich = true, reduce = true, time = 0.5, bonus_quadorder = 5, kwargs...)\n\n\t# prepare problem data\n\tf_eval, u_eval, ∇u_eval, p_eval = prepare_data(; μ = μ)\n\trhs!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\texact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2]))\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\texact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\n\t# prepare unknowns\n\tu = Unknown(\"u\"; name = \"velocity\", dim = 2)\n\tpfull = Unknown(\"p\"; name = \"pressure (full)\", dim = 1)\n\tpE = Unknown(\"p⟂\"; name = \"pressure (enriched)\", dim = 1)\n\tp0 = Unknown(\"p0\"; name = \"pressure (reduced)\", dim = 1) # only used if enrich && reduced\n\tuR = Unknown(\"uR\"; name = \"velocity enrichment\", dim = 2) # only used if enrich == true\n\n\t# prepare plots\n\tpl = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\n\t# prepare error calculations\n\tfunction exact_error!(result, u, qpinfo)\n\t\texact_u!(view(result, 1:2), qpinfo)\n\t\texact_∇u!(view(result, 3:6), qpinfo)\n\t\tresult .-= u\n\t\tresult .= result .^ 2\n\tend\n\tfunction exact_error_p!(result, p, qpinfo)\n\t\texact_p!(view(result, 1), qpinfo)\n\t\tresult .-= p\n\t\tresult .= result .^ 2\n\tend\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * (order + 1), kwargs...)\n\tErrorIntegratorPressure = ItemIntegrator(exact_error_p!, [id(pfull)]; quadorder = 2 * (order + 1), kwargs...)\n\tL2NormIntegratorE = L2NormIntegrator([id(uR)]; quadorder = 2 * order)\n\tfunction kernel_div!(result, u, qpinfo)\n\t\tresult .= sum(u) .^ 2\n\tend\n\tDivNormIntegrator = ItemIntegrator(kernel_div!, enrich ? [div(u), div(uR)] : [div(u)]; quadorder = 2 * order)\n\tNDofs = zeros(Int, nrefs)\n\tResults = zeros(Float64, nrefs, 5)\n\n\tfor lvl ∈ 1:nrefs\n\n\t\t# grid\n\t\txgrid = get_grid2D(lvl)\n\n\t\t# define and assign unknowns\n\t\tPD = ProblemDescription(\"Stokes problem\")\n\t\tassign_unknown!(PD, u)\n\t\tp = reduce * enrich ? p0 : pfull\n\t\tassign_unknown!(PD, p)\n\n\t\t################\n\t\t### FESPACES ###\n\t\t################\n\t\tif order == 1\n\t\t\tFES_enrich = FESpace{HDIVRT0{2}}(xgrid)\n\t\telse\n\t\t\tFES_enrich = FESpace{HDIVRTkENRICH{2, order - 1, reduce}}(xgrid)\n\t\tend\n\t\tFES = Dict(u => FESpace{H1Pk{2, 2, order}}(xgrid),\n\t\t\tpfull => FESpace{order == 1 ? L2P0{1} : H1Pk{1, 2, order - 1}}(xgrid; broken = true),\n\t\t\tp0 => FESpace{L2P0{1}}(xgrid; broken = true),\n\t\t\tuR => enrich ? FES_enrich : nothing)\n\n\t\t######################\n\t\t### STANDARD TERMS ###\n\t\t######################\n\t\tassign_operator!(PD, LinearOperator(rhs!, [id(u)]; bonus_quadorder = bonus_quadorder, kwargs...))\n\t\tassign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n\t\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4, bonus_quadorder = bonus_quadorder))\n\t\tassign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n\n\t\t##################\n\t\t### ENRICHMENT ###\n\t\t##################\n\t\tif enrich\n\t\t\tif reduce\n\t\t\t\tif order == 1\n\t\t\t\t\t@info \"... preparing condensation of RT0 dofs\"\n\t\t\t\t\tAR = FEMatrix(FES_enrich)\n\t\t\t\t\tBR = FEMatrix(FES[p], FES_enrich)\n\t\t\t\t\tbR = FEVector(FES_enrich)\n\t\t\t\t\tassemble!(AR, BilinearOperator([div(1)]; lump = true, factor = μ, kwargs...))\n\t\t\t\t\tfor bface in xgrid[BFaceFaces]\n\t\t\t\t\t\tAR.entries[bface, bface] = 1e60\n\t\t\t\t\tend\n\t\t\t\t\tassemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n\t\t\t\t\tassemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n\t\t\t\t\t# invert AR (diagonal matrix)\n\t\t\t\t\tAR.entries.cscmatrix.nzval .= 1 ./ AR.entries.cscmatrix.nzval\n\t\t\t\t\tC = -BR.entries.cscmatrix * AR.entries.cscmatrix * BR.entries.cscmatrix'\n\t\t\t\t\tc = -BR.entries.cscmatrix * AR.entries.cscmatrix * bR.entries\n\t\t\t\t\tassign_operator!(PD, BilinearOperator(C, [p], [p]; kwargs...))\n\t\t\t\t\tassign_operator!(PD, LinearOperator(c, [p]; kwargs...))\n\t\t\t\telse\n\t\t\t\t\t@info \"... preparing removal of enrichment dofs\"\n\t\t\t\t\tBR = FEMatrix(FES[p], FES_enrich)\n\t\t\t\t\tA1R = FEMatrix(FES_enrich, FES[u])\n\t\t\t\t\tbR = FEVector(FES_enrich)\n\t\t\t\t\tassemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n\t\t\t\t\tassemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n\t\t\t\t\tassemble!(A1R, BilinearOperator([id(1)], [Δ(1)]; factor = -μ, kwargs...))\n\t\t\t\t\tF, DD_RR = div_projector(FES[u], FES_enrich)\n\t\t\t\t\tC = F.entries.cscmatrix * A1R.entries.cscmatrix\n\t\t\t\t\tassign_operator!(PD, BilinearOperator(C, [u], [u]; factor = 1, transposed_copy = -1, kwargs...))\n\t\t\t\t\tassign_operator!(PD, LinearOperator(F.entries.cscmatrix * bR.entries, [u]; kwargs...))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tassign_unknown!(PD, uR)\n\t\t\t\tassign_operator!(PD, LinearOperator(rhs!, [id(uR)]; bonus_quadorder = 5, kwargs...))\n\t\t\t\tassign_operator!(PD, BilinearOperator([id(p)], [div(uR)]; transposed_copy = 1, factor = -1, kwargs...))\n\t\t\t\tif order == 1\n\t\t\t\t\tassign_operator!(PD, BilinearOperator([div(uR)]; lump = true, factor = μ, kwargs...))\n\t\t\t\t\tassign_operator!(PD, HomogeneousBoundaryData(uR; regions = 1:4))\n\t\t\t\telse\n\t\t\t\t\tassign_operator!(PD, BilinearOperator([Δ(u)], [id(uR)]; factor = μ, transposed_copy = -1, kwargs...))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t#############\n\t\t### SOLVE ###\n\t\t#############\n\t\tsol = solve(PD, FES; time = time, kwargs...)\n\t\tNDofs[lvl] = length(sol.entries)\n\n\t\t# move integral mean of pressure\n\t\tpintegrate = ItemIntegrator([id(p)])\n\t\tpmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n\t\tview(sol[p]) .-= pmean\n\n\t\t######################\n\t\t### POSTPROCESSING ###\n\t\t######################\n\t\tif enrich && reduce\n\t\t\tappend!(sol, FES_enrich; tag = uR)\n\t\t\tif order == 1\n\t\t\t\t# compute enrichment part of velocity\n\t\t\t\tview(sol[uR]) .= AR.entries.cscmatrix * (bR.entries - BR.entries.cscmatrix' * view(sol[p]))\n\t\t\telse\n\t\t\t\t# compute enrichment part of velocity\n\t\t\t\tview(sol[uR]) .= F.entries.cscmatrix' * view(sol[u])\n\t\t\tend\n\n\t\t\t# compute higher order pressure dofs\n\t\t\tif reduce && order > 1\n\t\t\t\t# add blocks for higher order pressures to sol vector\n\t\t\t\tVR = FES_enrich\n\t\t\t\tappend!(sol, VR; tag = pE)\n\t\t\t\tappend!(sol, FES[pfull]; tag = pfull)\n\t\t\t\tsol_pE = view(sol[pE])\n\t\t\t\tsol_pfull = view(sol[pfull])\n\t\t\t\tsol_p0 = view(sol[p0])\n\n\t\t\t\tres = FEVector(VR)\n\t\t\t\taddblock_matmul!(res[1], A1R[1, 1], sol[u])\n\t\t\t\tcelldofs_VR::VariableTargetAdjacency{Int32} = VR[CellDofs]\n\t\t\t\tndofs_VR = max_num_targets_per_source(celldofs_VR)\n\t\t\t\tAp = zeros(Float64, ndofs_VR, ndofs_VR)\n\t\t\t\tbp = zeros(Float64, ndofs_VR)\n\t\t\t\txp = zeros(Float64, ndofs_VR)\n\t\t\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\t\t\t# solve local pressure reconstruction\n\t\t\t\t\t# (p_h, div VR) = - (f,VR) + a_h(u_h,VR)\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\tbp[dof_j] = -bR.entries[dof] + res.entries[dof]\n\t\t\t\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\t\t\t\tAp[dof_j, dof_k] = DD_RR.entries[dof, dof2]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# solve for coefficients of div(RT1bubbles)\n\t\t\t\t\txp = Ap \\ bp\n\n\t\t\t\t\t# save in block id_pk\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\tsol_pE[dof] = xp[dof_j]\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t# interpolate into Pk basis (= same pressure basis as in full scheme)\n\t\t\t\tPF = FES[pfull]\n\t\t\t\tappend!(sol, PF; tag = pfull)\n\t\t\t\tcelldofs_PF::SerialVariableTargetAdjacency{Int32} = PF[CellDofs]\n\t\t\t\tndofs_PF::Int = max_num_targets_per_source(celldofs_PF)\n\n\t\t\t\t# compute local mass matrix of full pressure space\n\t\t\t\tMAMA = FEMatrix(PF)\n\t\t\t\tassemble!(MAMA, BilinearOperator([id(1)]))\n\t\t\t\tMAMAE::ExtendableSparseMatrix{Float64, Int64} = MAMA.entries\n\n\t\t\t\t# full div-pressure matrix\n\t\t\t\tPFxVR = FEMatrix(PF, VR)\n\t\t\t\tassemble!(PFxVR, BilinearOperator([id(1)], [div(1)]))\n\t\t\t\tPFxVRE::ExtendableSparseMatrix{Float64, Int64} = PFxVR.entries\n\t\t\t\tbp = zeros(Float64, ndofs_PF)\n\t\t\t\txp = zeros(Float64, ndofs_PF)\n\t\t\t\tlocMAMA = zeros(Float64, ndofs_PF, ndofs_PF)\n\t\t\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\t\t\t# solve local pressure reconstruction\n\t\t\t\t\tfill!(bp, 0)\n\t\t\t\t\tfor dof_k ∈ 1:ndofs_PF\n\t\t\t\t\t\tdof2 = celldofs_PF[dof_k, cell]\n\t\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\t\tbp[dof_k] += PFxVRE[dof2, dof] * sol_pE[dof]\n\t\t\t\t\t\tend\n\t\t\t\t\t\tfor dof_j ∈ 1:ndofs_PF\n\t\t\t\t\t\t\tdof = celldofs_PF[dof_j, cell]\n\t\t\t\t\t\t\tlocMAMA[dof_k, dof_j] = MAMAE[dof2, dof]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# solve for coefficients of div(RT1bubbles)\n\t\t\t\t\txp = locMAMA \\ bp\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_PF\n\t\t\t\t\t\tdof = celldofs_PF[dof_j, cell]\n\t\t\t\t\t\tsol_pfull[dof] = sol_p0[cell] + xp[dof_j]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telseif reduce && order == 1\n\t\t\t\tpfull = p0\n\t\t\tend\n\t\tend\n\n\t\t########################\n\t\t### ERROR EVALUATION ###\n\t\t########################\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\tH1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n\t\t@info \"L2error(u) = $L2errorU\"\n\t\t@info \"L2error(∇u) = $H1errorU\"\n\t\tevaluate!(error, ErrorIntegratorPressure, sol)\n\t\tL2errorP = sqrt(sum(view(error, 1, :)))\n\t\t@info \"L2error(p) = $L2errorP\"\n\t\tResults[lvl, 4] = L2errorP\n\t\tif enrich\n\t\t\tfill!(error, 0)\n\t\t\tevaluate!(error, L2NormIntegratorE, sol)\n\t\t\tL2normUR = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\t\t@info \"L2norm(uR) = $L2normUR\"\n\t\tend\n\t\tfill!(error, 0)\n\t\tevaluate!(error, DivNormIntegrator, sol)\n\t\tL2normDiv = sqrt(sum(view(error, 1, :)))\n\t\t@info \"L2norm(div(u+uR)) = $L2normDiv\"\n\n\t\tResults[lvl, 1] = L2errorU\n\t\tResults[lvl, 2] = H1errorU\n\t\tResults[lvl, 3] = L2normUR\n\t\tResults[lvl, 5] = L2normDiv\n\n\t\t#############\n\t\t### PLOTS ###\n\t\t#############\n\t\tscalarplot!(pl[1, 1], id(u), sol; abs = true)\n\t\tscalarplot!(pl[1, 2], id(pfull), sol)\n\t\tif order == 1 && enrich\n\t\t\tscalarplot!(pl[2, 2], id(uR), sol)\n\t\tend\n\tend\n\tplot_convergencehistory!(\n\t\tpl[2, 1],\n\t\tNDofs,\n\t\tResults[:,1:4];\n\t\tadd_h_powers = [order, order + 1],\n\t\tX_to_h = X -> 8 * X .^ (-1 / 2),\n\t\tlegend = :best,\n\t\tylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"],\n\t)\n\n\tprint_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"], xlabel = \"ndof\")\nend\n\nfunction div_projector(V1, VR)\n\n\t# setup interpolation matrix\n\tcelldofs_V1 = V1[CellDofs]\n\tcelldofs_VR = VR[CellDofs]\n\tndofs_V1 = max_num_targets_per_source(celldofs_V1)\n\tndofs_VR = max_num_targets_per_source(celldofs_VR)\n\n\tDD_RR = FEMatrix(VR)\n\tassemble!(DD_RR, BilinearOperator([div(1)]))\n\tDD_RRE = DD_RR.entries\n\tDD_1R = FEMatrix(V1, VR)\n\tassemble!(DD_1R, BilinearOperator([div(1)]))\n\tDD_1RE = DD_1R.entries\n\tAp = zeros(Float64, ndofs_VR, ndofs_VR)\n\tbp = zeros(Float64, ndofs_VR)\n\txp = zeros(Float64, ndofs_VR)\n\tncells = num_sources(celldofs_V1)\n\tF = FEMatrix(V1, VR)\n\tFE = F.entries\n\tfor cell ∈ 1:ncells\n\n\t\t# solve local pressure reconstruction for RTk part\n\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tAp[dof_j, dof_k] = DD_RRE[dof, dof2]\n\t\t\tend\n\t\tend\n\n\t\tfor dof_j ∈ 1:ndofs_V1\n\t\t\tdof = celldofs_V1[dof_j, cell]\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tbp[dof_k] = -DD_1RE[dof, dof2]\n\t\t\tend\n\n\t\t\txp = Ap \\ bp\n\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tFE[dof, dof2] = xp[dof_k]\n\t\t\tend\n\t\tend\n\tend\n\tflush!(FE)\n\treturn F, DD_RR\nend\n\nend # module","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"Default output:","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"julia> Example240_SVRTEnrichment.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t1.068e-14\t0.00\t0.00\t0.00\t\t0.30\t0.33\t0.64\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.66\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.05\n END\t---------\t5.918e-13\t0.01\t0.00\t0.01\t\t1.22\t1.51\t2.74\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t2.79\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.14\n END\t---------\t4.032e-13\t0.02\t0.03\t0.04\t\t3.86\t7.18\t11.04\n\tfinished\t\t\t\tSUM -->\t0.04\t\t\tSUM -->\t11.18\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.49\n END\t---------\t1.234e-10\t0.08\t0.07\t0.15\t\t15.07\t37.59\t52.67\n\tfinished\t\t\t\tSUM -->\t0.15\t\t\tSUM -->\t53.16\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t1.87\n END\t---------\t5.840e-10\t0.28\t0.36\t0.65\t\t60.69\t184.80\t245.49\n\tfinished\t\t\t\tSUM -->\t0.64\t\t\tSUM -->\t247.36\n\n\n    ndof    |   || u - u_h ||    order | || ∇(u - u_h) ||   order |     || uR ||       order |   || p - p_h ||    order | || div(u + uR) ||  order |\n============|==========================|==========================|==========================|==========================|==========================|\n        98  |     2.282e-01      0.00  |     2.796e+00      0.00  |     1.256e-01      0.00  |     3.138e+00      0.00  |     9.093e-16      0.00  |\n       493  |     1.528e-02      3.35  |     5.163e-01      2.09  |     1.190e-02      2.92  |     5.248e-01      2.21  |     1.201e-10      -14.60  |\n      2062  |     1.503e-03      3.24  |     1.199e-01      2.04  |     1.334e-03      3.06  |     1.287e-01      1.96  |     1.091e-13      9.79  |\n      8283  |     1.717e-04      3.12  |     2.849e-02      2.07  |     1.466e-04      3.18  |     2.947e-02      2.12  |     1.161e-11      -6.71  |\n     32329  |     2.196e-05      3.02  |     7.243e-03      2.01  |     1.806e-05      3.08  |     7.578e-03      1.99  |     2.429e-11      -1.08  |","category":"page"},{"location":"examples/Example240_SVRTEnrichment/","page":"240 : Stokes RT enrichment","title":"240 : Stokes RT enrichment","text":"(Image: )","category":"page"},{"location":"examples/Example310_DivFreeBasis/#:-Div-free-RT0-basis","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"","category":"section"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"(source code)","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"This example computes the best-approximation mathbfpsi_h of a divergence-free velocity mathbfu = mathrmcurl mathbfpsi by solving for a curl-potential mathbfphi_h in N_0 with","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"beginaligned\n(mathrmcurl mathbfphi_h mathrmcurl mathbftheta_h)  = (mathbfu mathrmcurl mathbftheta_h) quad textfor all  mathbftheta in N_0\nendaligned","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"Here, N_0 denotes the lowest-order Nedelec space which renders the problem ill-posed unless one selects a linear independent basis. This is done with the algorithm suggested in the reference below.","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"reference: Reference\n\"Decoupling three-dimensional mixed problems using divergence-free finite elements\",\nR. Scheichl,\nSIAM J. Sci. Comput. 23(5) (2002),\n>Journal-Link<","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"module Example310_DivFreeBasis\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing Symbolics\n\n# exact data for problem by symbolics\nfunction prepare_data()\n\n\t@variables x y z\n\n\t# stream function ξ\n\tξ = [x*y*z,x*y*z,x*y*z]\n\n\t# velocity u = curl ξ\n\t∇ξ = Symbolics.jacobian(ξ, [x, y, z])\n\tu = [∇ξ[3,2] - ∇ξ[2,3], ∇ξ[1,3] - ∇ξ[3,1], ∇ξ[2,1] - ∇ξ[1,2]]\n\n\t# build function\n\tu_eval = build_function(u, x, y, z, expression = Val{false})\n\n\treturn u_eval[2]\nend\n\nfunction main(;\n\tnrefs = 4,                      ## number of refinement levels\n\tbonus_quadorder = 2,            ## additional quadrature order for data evaluations\n\tdivfree_basis = true,\t\t\t## if true uses curl(N0), if false uses mixed FEM RT0xP0\n\tPlotter = nothing,              ## Plotter (e.g. PyPlot)\n\tkwargs...)\n\n\t# prepare problem data\n\tu_eval = prepare_data()\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.x[3]))\n\n\t# prepare plots\n\tpl = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\n\t# prepare error calculation\n\tfunction exact_error!(result, u, qpinfo)\n\t\texact_u!(view(result, 1:3), qpinfo)\n\t\tresult .-= u\n\t\tresult .= result .^ 2\n\tend\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [divfree_basis ? curl3(1) : id(1)]; bonus_quadorder = 2 + bonus_quadorder, kwargs...)\n\tNDofs = zeros(Int, nrefs)\n\tL2error = zeros(Float64, nrefs)\n\n\tfor lvl ∈ 1:nrefs\n\t\t# grid\n\t\txgrid = uniform_refine(grid_unitcube(Tetrahedron3D), lvl)\n\n\t\tif divfree_basis\n\t\t\t@time begin\n\t\t\t\t# get subset of edges, spanning the node graph\n\t\t\t\tspanning_tree = get_spanning_edge_subset(xgrid)\n\n\t\t\t\t# get all other edges = linear independent degrees of freedom\n\t\t\t\tsubset = setdiff(1:num_edges(xgrid), spanning_tree)\n\t\t\tend\n\n\t\t\t# generate lowest order Nedelec FESpace\n\t\t\tFES = FESpace{HCURLN0{3}}(xgrid)\n\t\t\tNDofs[lvl] = length(subset)\n\n\t\t\t# assemble full Nedelec curl-curl matrix\n\t\t\t@time begin\n\t\t\t\tA = FEMatrix(FES)\n\t\t\t\tb = FEVector(FES)\n\t\t\t\tassemble!(A, BilinearOperator([curl3(1)]))\n\t\t\t\tassemble!(b, LinearOperator(exact_u!, [curl3(1)]; bonus_quadorder = bonus_quadorder))\n\n\t\t\t\t# restrict to linear independent basis\n\t\t\t\tZ = ExtendableSparseMatrix{Float64, Int64}(length(subset), FES.ndofs)\n\t\t\t\tfor j = 1 : length(subset)\n\t\t\t\t\tZ[j,subset[j]] = 1\n\t\t\t\tend\n\t\t\t\tAred = Z * (A.entries * Z')\n\t\t\t\tbred = Z * b.entries\n\t\t\tend\n\n\t\t\t# solve\n\t\t\tsol = FEVector(FES)\n\t\t\t@time sol.entries[subset] .= Ared\\bred\n\t\telse\n\t\t\t# use RT0 functions + side constraint for divergence\n\t\t\tFES = [FESpace{HDIVRT0{3}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n\t\t\tNDofs[lvl] = FES[1].ndofs + FES[2].ndofs\n\n\t\t\t# assemble full RT0 mass matrix and div-pressure constraint\n\t\t\t@time begin\n\t\t\t\tA = FEMatrix(FES)\n\t\t\t\tb = FEVector(FES)\n\t\t\t\tassemble!(A, BilinearOperator([id(1)]))\n\t\t\t\tassemble!(A, BilinearOperator([div(1)], [id(2)]; transposed_copy = 1))\n\t\t\t\tassemble!(b, LinearOperator(exact_u!, [id(1)]; bonus_quadorder = bonus_quadorder))\n\t\t\tend\n\n\t\t\t# solve\n\t\t\tsol = FEVector(FES)\n\t\t\t@time sol.entries .= A.entries\\b.entries\n\t\tend\n\n\n\t\t# check residual\n\t\t@info \"residual = $(norm(A.entries * sol.entries - b.entries))\"\n\n\t\t# evalute error\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tL2error[lvl] = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\tif divfree_basis\n\t\t\t@info \"|| u - curl(ϕ_h) || = $(L2error[lvl])\"\n\t\t\tscalarplot!(pl[1, 1], curl3(1), sol; abs = true)\n\t\telse\n\t\t\t@info \"|| u - u_h || = $(L2error[lvl])\"\n\t\t\tscalarplot!(pl[1, 1], id(1), sol; abs = true)\n\t\tend\n\tend\n\n\t# print convergence history as table\n\tprint_convergencehistory(NDofs, L2error; X_to_h = X -> X .^ (-1 / 3), ylabels = [\"|| u - u_h ||\"], xlabel = \"ndof\")\nend\n\n\n# finds a minimal subset (of dimension #nodes - 1) of edges, such that all nodes are connected\nfunction get_spanning_edge_subset(xgrid)\n\tnnodes = num_nodes(xgrid)\n\tedgenodes = xgrid[EdgeNodes]\n\tbedgenodes = xgrid[BEdgeNodes]\n\tbedgeedges = xgrid[BEdgeEdges]\n\n\t# boolean arrays to memorize which nodes are visited\n\t# and which edges belong to the spanning tree\n\tvisited = zeros(Bool, nnodes)\n\tmarkededges = zeros(Bool, num_edges(xgrid))\n\n\tfunction find_spanning_tree(edgenodes, remap)\n\t\tnodeedges = atranspose(edgenodes)\n\t\tfunction recursive(node)\n\t\t\tvisited[node] = true\n\t\t\tnneighbors = num_targets(nodeedges, node)\n\t\t\tfor e = 1 : nneighbors\n\t\t\t\tedge = nodeedges[e, node]\n\t\t\t\tfor k = 1 : 2\n\t\t\t\t\tnode2 = edgenodes[k, edge]\n\t\t\t\t\tif !visited[node2]\n\t\t\t\t\t\t# mark edge\n\t\t\t\t\t\tmarkededges[remap[edge]] = true\n\t\t\t\t\t\trecursive(node2)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn nothing\n\t\tend\n\t\trecursive(edgenodes[1])\n\tend\n\n\t# find spanning tree for Neumann boundary\n\t# local bedges >> global edge numbers\n\tfind_spanning_tree(bedgenodes, bedgeedges)\n\n\t# find spanning tree for remaining part\n\tother_nodes = setdiff(1:nnodes, unique(view(bedgenodes,:)))\n\tif length(other_nodes) > 0\n\t\tfind_spanning_tree(edgenodes, 1 : num_edges(xgrid))\n\tend\n\n\t# return all marked edges\n\treturn findall(==(true), markededges)\nend\n\n\nend # module","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"Default output:","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"julia> Example310_DivFreeBasis.main()\n  0.000234 seconds (158 allocations: 46.203 KiB)\n  0.001072 seconds (700 allocations: 215.523 KiB)\n  0.000204 seconds (59 allocations: 59.406 KiB)\n  0.001460 seconds (2.69 k allocations: 283.625 KiB)\n  0.002935 seconds (706 allocations: 786.008 KiB)\n  0.001177 seconds (59 allocations: 546.953 KiB)\n  0.011798 seconds (54.01 k allocations: 2.257 MiB)\n  0.019691 seconds (730 allocations: 4.428 MiB)\n  0.011402 seconds (70 allocations: 6.419 MiB)\n  0.115217 seconds (457.84 k allocations: 18.814 MiB, 8.33% gc time)\n  0.159836 seconds (738 allocations: 35.552 MiB)\n  0.303761 seconds (70 allocations: 96.092 MiB, 5.85% gc time)\n\n    ndof    |   || u - u_h ||    order |\n============|==========================|\n        72  |     1.257e-01      0.00  |\n       480  |     6.821e-02      0.97  |\n      3456  |     3.510e-02      1.01  |\n     26112  |     1.772e-02      1.01  |","category":"page"},{"location":"examples/Example310_DivFreeBasis/","page":"310 : Div-free RT0 basis","title":"310 : Div-free RT0 basis","text":"(Image: )","category":"page"},{"location":"callbackoperator/#CallbackOperator","page":"CallbackOperator","title":"CallbackOperator","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"A callback operator passes the matrix and rhs to a user-defined function where they can be modified as desired. An example where this is used is Example265.","category":"page"},{"location":"callbackoperator/#Constructors","page":"CallbackOperator","title":"Constructors","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/callback_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"callbackoperator/#ExtendableFEM.CallbackOperator","page":"CallbackOperator","title":"ExtendableFEM.CallbackOperator","text":"function CallbackOperator(\n\tcallback!::Function,\n\tu_args = [];\n\tkwargs...)\n\nGenerates an operator that simply passes the matrix and rhs to a user-specified call back function. The callback function needs to be conform to the interface\n\ncallback!(A, b, args; assemble_matrix = true, assemble_rhs = true, time = 0, kwargs...)\n\nThe u_args argument can be used to specify the arguments of the solution that should be passed as args (a vector of FEVectorBlocks) to the callback.\n\nKeyword arguments:\n\nmodifies_matrix: callback function modifies the matrix?. Default: true\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''CallbackOperator''\nmodifies_rhs: callback function modifies the rhs?. Default: true\nverbosity: verbosity level. Default: 0\nstore: store matrix and rhs separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"fixdofs/#FixDofs","page":"FixDofs","title":"FixDofs","text":"","category":"section"},{"location":"fixdofs/","page":"FixDofs","title":"FixDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/fixdofs_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fixdofs/#ExtendableFEM.FixDofs-Tuple{Any}","page":"FixDofs","title":"ExtendableFEM.FixDofs","text":"function FixDofs(u; vals = [], dofs = [], kwargs...)\n\nWhen assembled, all specified dofs of the unknown u will be penalized to the specified values.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''FixDofs''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\n\n\n\n\n\n","category":"method"},{"location":"nonlinearoperator/#NonlinearOperator","page":"NonlinearOperator","title":"NonlinearOperator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"A nonlinear operator automatically assembles all necessary terms for the Newton method. Other linearisations of a nonlinear operator can be constructed with special constructors for BilinearOperator or LinearOperator.","category":"page"},{"location":"nonlinearoperator/#Constructor","page":"NonlinearOperator","title":"Constructor","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/nonlinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"nonlinearoperator/#ExtendableFEM.NonlinearOperator","page":"NonlinearOperator","title":"ExtendableFEM.NonlinearOperator","text":"function NonlinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tjacobian = nothing,\n\tkwargs...)\n\nGenerates a nonlinear form for the specified kernel function, test function operators, and argument operators evaluations. Operator evaluations are tuples that pair an unknown identifier or integer with a FunctionOperator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, input, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nDuring assembly the Newton update is computed via local jacobians of the kernel which are calculated by automatic differentiation or by the user-provided jacobian function with interface\n\njacobian!(jac, input_args, params)\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nsparse_jacobians: use sparse jacobians. Default: true\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''NonlinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\n\n\n\n\n\n","category":"type"},{"location":"nonlinearoperator/#Example-NSE-convection-operator","page":"NonlinearOperator","title":"Example - NSE convection operator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"For the 2D Navier–Stokes equations, a kernel function for the convection operator could look like","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input,3:6)\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4))\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"and the coressponding NonlinearOperator constructor call reads","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\nNonlinearOperator(kernel!, [id(u)], [id(u),grad(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The second argument triggers that the evaluation of the Identity and Gradient operator of the current velocity iterate at each quadrature point go (in that order) into the input vector (of length 6) of the kernel, while the third argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the velocity test function.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"remark: Remark\nAlso note, that the same kernel could be used for a fully explicit linearisation of the convection term as a LinearOperator viau = Unknown(\"u\"; name = \"velocity\")\nLinearOperator(kernel!, [id(u)], [id(u),grad(u)])For a Picard iteration of the convection term, a BilinearOperator can be used with a slightly modified kernel that separates the operator evaluations of the ansatz function and the current solution, i.e.,function kernel_picard!(result, input_ansatz, input_args, qpinfo)\n    a, ∇u = view(input_args, 1:2), view(input_ansatz,1:4)\n    result[1] = dot(a, view(∇u,1:2))\n    result[2] = dot(a, view(∇u,3:4))\nend\nu = Unknown(\"u\"; name = \"velocity\")\nBilinearOperator(kernel_picard!, [id(u)], [grad(u)], [id(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Note\nKernels are allowed to depend on region numbers, space and time coordinates via the qpinfo argument.","category":"page"},{"location":"nonlinearoperator/#Newton-by-local-jacobians-of-kernel","page":"NonlinearOperator","title":"Newton by local jacobians of kernel","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To demonstrate the general approach consider a model problem with a nonlinear operator that has the weak formulation that seeks some function u(x) in X in some finite-dimensional space X with N = mathrmdim X, i.e., some coefficient vector x in mathbbR^N, such that","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) = int_Omega A(L_1u(x)(y)) cdot L_2v(y) textitdy  = 0 quad textfor all  v in X\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"for some given nonlinear kernel function A  mathbbR^m rightarrow mathbbR^n where m is the dimension of the input L_1 u(x)(y) in mathbbR^m and n is the dimension of the result L_2 v(y) in mathbbR^n. Here, L_1 and L_2 are linear operators, e.g. primitive differential operator evaluations of u or v.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Let us consider the Newton scheme to find a root of the residual function F  mathbbR^N rightarrow mathbbR^N, which iterates","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nx_n+1 = x_n - D_xF(x_n)^-1 F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"or, equivalently, solves","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x_n) left(x_n+1 - x_nright) = -F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To compute the jacobian of F, observe that its discretisation on a mesh mathcalT and some quadrature rule (x_qp w_qp) leads to","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp A(L_1u_h(x)(x_qp)) cdot L_2v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Now, by linearity of everything involved other than A, we can evaluate the jacobian by","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp DA(L_1 u_h(x)(x_qp)) cdot L_2 v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Hence, assembly only requires to evaluate the low-dimensional jacobians DA in mathbbR^m times n of A at L_1 u_h(x)(x_qp). These jacobians are computed by automatic differentiation via ForwardDiff.jl (or via the user-given jacobian function). If m and n are a little larger, e.g. when more operator evaluations L_1 and L_2 or more unknowns are involved, there is the option to use sparse_jacobians (using the sparsity detection of Symbolics.jl).","category":"page"},{"location":"examples/Example275_OptimalControlStokes/#:-Optimal-Control-Stokes","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"","category":"section"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"(source code)","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"This example studies the optimal control problem for the Stokes operator with divergence-free velocity space mathbfV_0 subset mathbfH^1_0, i.e., for given data mathbfu^d minimize the functional","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"beginaligned\nmin_(mathbfumathbfq) in mathbfV_0 times mathbfL^2  mathbfu - mathbfu^d ^2 + fracalpha2  mathbfq ^2\nquad textst  (mu nabla mathbfu nabla mathbfv) = (mathbfq mathbfv) quad textfor all  mathbfv in mathbfV_0\nendaligned","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"This results in the set of variational equations that seeks (mathbfu mathbfz p  lambda) such that","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"beginaligned\n(mu nabla mathbfu nabla mathbfv) + (p mathrmdiv mathbfv)  = - alpha^-12 (mathbfz mathbfv)\n                                             (q mathrmdiv mathbfu)  = 0\n(mu nabla mathbfz nabla mathbfw) + (λ mathrmdiv mathbfw)  = alpha^-12 (mathbfu - mathbfu^d mathbfw)\n                                             (φ mathrmdiv mathbfz)  = 0\nendaligned","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"for all test functions (mathbfv mathbfw q  varphi).","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"Here, we study pressure-robustness with the given data","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"mathbfu^d = mathrmcurl left(x^4y^4(x-1)^4(y-1)^4right) + epsilon nabla(cos(x)sin(y))","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"with a gradient field distortion that can be steered by ϵ geq 0 which was an example in the reference below.","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"reference: Reference\n\"Pressure-robustness in the context of optimal control\",\nC. Merdon and W. Wollner,\nSIAM Journal on Control and Optimization 61:1, 342-360 (2023),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"module Example275_OptimalControlStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Symbolics\n\nfunction prepare_data!(; ϵ = 0)\n\t@variables x y\n\n\t# stream function ξ\n\tξ = x^4*y^4*(x-1)^4*(y-1)^4\n\t∇ξ = Symbolics.gradient(ξ, [x,y])\n\n    # irrotational perturbation (to study pressure-robustness)\n    ϕ = cos(x)*sin(y)\n\t∇ϕ = Symbolics.gradient(ϕ, [x,y])\n\n    # final data = curl ξ + ϵ ∇ϕ\n\td = [-∇ξ[2], ∇ξ[1]] + ϵ * ∇ϕ\n\td_eval = build_function(d, x, y, expression = Val{false})\n\n    return d_eval[2]\nend\n\n# standard Stokes kernel\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops,1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ*∇u[1] + p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] + p[1]\n    result[5] = (∇u[1] + ∇u[4])\nend\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, μ = 1, α = 1e-6, ϵ = 0, kwargs...)\n\n    # prepare target data\n    d_eval = prepare_data!(; ϵ = ϵ)\n    data!(result, qpinfo) = (d_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n\n    # load mesh and refine\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    z = Unknown(\"z\"; name = \"control\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    λ = Unknown(\"λ\"; name = \"control pressure\", dim = 1)\n\n    # prepare reconstruction operator (if reconstruct = true)\n    idR(u) = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define optimal control problem\n    PD = ProblemDescription(\"Stokes optimal control problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, z)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, λ)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(z), id(λ)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator([idR(z)], [idR(u)]; factor = -1/sqrt(α), transposed_copy = -1, kwargs...))\n    assign_operator!(PD, LinearOperator(data!, [idR(z)]; factor = -1/sqrt(α), bonus_quadorder = 5, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(z; regions = 1:4, kwargs...))\n\n    # solve with Bernardi--Raugel method\n    FETypes = [H1BR{2}, L2P0{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 2]\n    sol = solve(PD, [FES[1],FES[1],FES[2],FES[2]]; kwargs...)\n\n    # plot solution\n    plt = plot([id(u), id(p), id(z), id(λ)], sol; add = 1, Plotter = Plotter)\n\n    # plot target data\n    I = FEVector(FES[1]; name = \"u^d\")\n    interpolate!(I[1], data!)\n    plot!(plt, [id(1)], I; keep = 1:4)\nend\n\nend","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"Default output:","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"julia> Example275_OptimalControlStokes.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.33\n END\t---------\t7.792e-16\t0.08\t0.13\t0.21\t\t14.17\t44.27\t58.44\n\tfinished\t\t\t\tSUM -->\t0.21\t\t\tSUM -->\t58.77\n","category":"page"},{"location":"examples/Example275_OptimalControlStokes/","page":"275 : Optimal Control Stokes","title":"275 : Optimal Control Stokes","text":"(Image: )","category":"page"},{"location":"examples/Example230_NonlinearElasticity/#:-Nonlinear-Elasticity","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"","category":"section"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"(source code)","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"This example computes the displacement field u of the nonlinear elasticity problem","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"beginaligned\n-mathrmdiv(mathbbC (epsilon(u)-epsilon_T))  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"where an isotropic stress tensor mathbbC is applied to the nonlinear strain epsilon(u) = frac12(nabla u + (nabla u)^T + (nabla u)^T nabla u) and a misfit strain  epsilon_T = Delta T alpha due to thermal load caused by temperature(s) Delta T and thermal expansion coefficients alpha (that may be different) in the two regions of the bimetal.","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"This example demonstrates how to setup a (parameter- and region-dependent) nonlinear expression and how to assign it to the problem description.","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"module Example230_NonlinearElasticity\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\n\n# parameter-dependent nonlinear operator uses a callable struct to reduce allocations\nmutable struct nonlinear_operator{T}\n\tλ::Vector{T}\n\tμ::Vector{T}\n\tϵT::Vector{T}\nend\n\nfunction strain!(result, input)\n\tresult[1] = input[1]\n\tresult[2] = input[4]\n\tresult[3] = input[2] + input[3]\n\n\t# add nonlinear part of the strain 1/2 * (grad(u)'*grad(u))\n\tresult[1] += 1 // 2 * (input[1]^2 + input[3]^2)\n\tresult[2] += 1 // 2 * (input[2]^2 + input[4]^2)\n\tresult[3] += input[1] * input[2] + input[3] * input[4]\n\treturn nothing\nend\n\n# kernel for nonlinear operator\n(op::nonlinear_operator)(result, input, qpinfo) = (\n\t# input = grad(u) written as a vector\n\t# compute strain and subtract thermal strain (all in Voigt notation)\n\tregion = qpinfo.region;\n\tstrain!(result, input);\n\tresult[1] -= op.ϵT[region];\n\tresult[2] -= op.ϵT[region];\n\n\t# multiply with isotropic stress tensor\n\t# (stored in input[5:7] using Voigt notation)\n\ta = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[1];\n\tb = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[2];\n\tc = 2 * op.μ[region] * result[3];\n\n\t# write strain into result\n\tresult[1] = a;\n\tresult[2] = c;\n\tresult[3] = c;\n\tresult[4] = b;\n\treturn nothing\n)\n\nconst op = nonlinear_operator([0.0, 0.0], [0.0, 0.0], [0.0, 0.0])\n\n# everything is wrapped in a main function\nfunction main(;\n\tν = [0.3, 0.3],          # Poisson number for each region/material\n\tE = [2.1, 1.1],          # Elasticity modulus for each region/material\n\tΔT = [580, 580],         # temperature for each region/material\n\tα = [1.3e-5, 2.4e-4],    # thermal expansion coefficients\n\tscale = [20, 500],       # scale of the bimetal, i.e. [thickness, width]\n\tnrefs = 0,              # refinement levels\n\torder = 2,              # finite element order\n\tperiodic = false,       # use periodic boundary conditions?\n\tPlotter = nothing,\n\tkwargs...)\n\n\t# compute Lame' coefficients μ and λ from ν and E\n\t# and thermal misfit strain and assign to operator operator\n\top.μ .= E ./ (2 .* (1 .+ ν .^ (-1)))\n\top.λ .= E .* ν ./ ((1 .- 2 * ν) .* (1 .+ ν))\n\top.ϵT .= ΔT .* α\n\n\t# generate bimetal mesh\n\txgrid = bimetal_strip2D(; scale = scale, n = 2 * (nrefs + 1))\n\tprintln(stdout, unicode_gridplot(xgrid))\n\n\t# create finite element space and solution vector\n\tFES = FESpace{H1Pk{2, 2, order}}(xgrid)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"displacement\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, ExtendableFEM.NonlinearOperator(op, [grad(u)]; kwargs...))\n\tif periodic\n\t\t# periodic boundary conditions\n\t\t# 1) couple dofs left (bregion 1) and right (bregion 3) in y-direction\n\t\tdofsX, dofsY, factors = get_periodic_coupling_info(FES, xgrid, 1, 3, (f1, f2) -> abs(f1[2] - f2[2]) < 1e-14; factor_components = [0, 1])\n\t\tassign_operator!(PD, CombineDofs(u, u, dofsX, dofsY, factors; kwargs...))\n\t\t# 2) find and fix point at [0, scale[1]]\n\t\txCoordinates = xgrid[Coordinates]\n\t\tclosest::Int = 0\n\t\tmindist::Float64 = 1e30\n\t\tfor j ∈ 1:num_nodes(xgrid)\n\t\t\tdist = xCoordinates[1, j]^2 + (xCoordinates[2, j] - scale[1])^2\n\t\t\tif dist < mindist\n\t\t\t\tmindist = dist\n\t\t\t\tclosest = j\n\t\t\tend\n\t\tend\n\t\tassign_operator!(PD, FixDofs(u; dofs = [closest], vals = [0]))\n\telse\n\t\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = [1, 0], kwargs...))\n\tend\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# displace mesh and plot\n\tp = GridVisualizer(; Plotter = Plotter, layout = (3, 1), clear = true, size = (1000, 1500))\n\tgrad_nodevals = nodevalues(grad(u), sol)\n\tstrain_nodevals = zeros(Float64, 3, num_nodes(xgrid))\n\tfor j in 1:num_nodes(xgrid)\n\t\tstrain!(view(strain_nodevals, :, j), view(grad_nodevals, :, j))\n\tend\n\tscalarplot!(p[1, 1], xgrid, view(strain_nodevals, 1, :), levels = 3, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_xx + displacement\")\n\tscalarplot!(p[2, 1], xgrid, view(strain_nodevals, 2, :), levels = 1, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_yy + displacement\")\n\tvectorplot!(p[1, 1], xgrid, eval_func(PointEvaluator([id(u)], sol)), spacing = [50, 25], clear = false)\n\tvectorplot!(p[2, 1], xgrid, eval_func(PointEvaluator([id(u)], sol)), spacing = [50, 25], clear = false)\n\tdisplace_mesh!(xgrid, sol[u])\n\tgridplot!(p[3, 1], xgrid, linewidth = 1, title = \"displaced mesh\")\n\tprintln(stdout, unicode_gridplot(xgrid))\nend\n\n# grid\nfunction bimetal_strip2D(; scale = [1, 1], n = 2, anisotropy_factor::Int = Int(ceil(scale[2] / (2 * scale[1]))))\n\tX = linspace(-scale[2] / 2, 0, (n + 1) * anisotropy_factor)\n\tX2 = linspace(0, scale[2] / 2, (n + 1) * anisotropy_factor)\n\tappend!(X, X2[2:end])\n\tY = linspace(0, scale[1], 2 * n + 1)\n\txgrid = simplexgrid(X, Y)\n\tcellmask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, scale[1] / 2], 1)\n\tcellmask!(xgrid, [-scale[2] / 2, scale[1] / 2], [scale[2] / 2, scale[1]], 2)\n\tbfacemask!(xgrid, [-scale[2] / 2, 0.0], [-scale[2] / 2, scale[1] / 2], 1)\n\tbfacemask!(xgrid, [-scale[2] / 2, scale[1] / 2], [-scale[2] / 2, scale[1]], 1)\n\tbfacemask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, 0.0], 2)\n\tbfacemask!(xgrid, [-scale[2] / 2, scale[1]], [scale[2] / 2, scale[1]], 2)\n\tbfacemask!(xgrid, [scale[2] / 2, 0.0], [scale[2] / 2, scale[1]], 3)\n\treturn xgrid\nend\n\nend","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"Default output:","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"julia> Example230_NonlinearElasticity.main()\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿│ \n    │⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.15\n   1\t1.225e+01\t1.101e-11\t0.06\t0.01\t0.06\t\t3.29\t5.92\t9.21\n   2\t8.096e+02\t1.531e-09\t0.02\t0.01\t0.03\t\t1.71\t7.23\t8.94\n   3\t3.652e+02\t7.749e-11\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n   4\t1.886e+02\t4.695e-10\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n   5\t7.393e+01\t6.922e-11\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n   6\t1.996e+01\t2.373e-11\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n   7\t2.545e+00\t9.693e-11\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n   8\t6.653e-02\t5.943e-11\t0.02\t0.03\t0.05\t\t0.00\t4.65\t4.65\n   9\t6.471e-05\t1.007e-10\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n  10\t1.334e-10\t2.795e-10\t0.02\t0.01\t0.02\t\t0.00\t4.65\t4.65\n END\t\t\t2.795e-10\t\t\t0.02\t\t0.02\t\t0.00\t\t0.00\n\tmaxiterations reached\t\t\tSUM -->\t0.32\t\t\tSUM -->\t55.51\n\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌───────────────────────────────────────────┐ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣷⣶⣦⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠿⣿⣿⣿⣿⣷⣤⡀⠀⠀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⢿⣿⣿⣯⣆⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣿⣿⣿⣧⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣧⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣾⡇│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⢿│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⢿⣿⠇│ \n    │⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡿⠀│ \n    │⣶⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⡿⠁⠀│ \n    │⠈⢻⡿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⣿⣿⣿⣿⠋⠀⠀⠀│ \n    │⠀⠀⠙⢿⣽⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⢿⡿⣿⣿⡟⠁⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠙⠽⣿⣿⣿⣯⣷⣦⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⣤⣖⣯⣿⣿⣿⣿⠟⠉⠀⠀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠈⠙⠽⢿⣻⣿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣶⣶⣶⣿⣿⣿⣿⣿⢿⣿⠿⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⠛⠻⠿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠟⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └───────────────────────────────────────────┘ ","category":"page"},{"location":"examples/Example230_NonlinearElasticity/","page":"230 : Nonlinear Elasticity","title":"230 : Nonlinear Elasticity","text":"(Image: )","category":"page"},{"location":"#ExtendableFEM.jl","page":"Home","title":"ExtendableFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers a toolkit to easily setup (mostly low-order, standard and non-standard) finite element methods for multiphysics problems in Julia and to run fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl (for meshing and administration) and ExtendableFEMBase.jl (for quadrature and FEM basis functions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that this package is part of the meta-package PDELIB.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nExtendableFEMBase.jl\nGridVisualize.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\n","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"#.-Geometry-description-/-meshing","page":"Home","title":"1. Geometry description / meshing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The geometry description and meshing is not really separated. For meshes of rectangular domains, there are simple constructors available in ExtendableGrids.jl, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExtendableGrids\n## unit square criss-cross into Triangles\nxgrid1 = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n## uniform rectangular grid\nxgrid2 = simplexgrid(0:0.1:1, 0:0.2:2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that these grids generate boundary regions from 1 to 4 (bottom, left, top, right) that can be used to assign boundary conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More complex grids can be created via the mesh generators in SimplexGridFactory.jl, see e.g. Examples 245 or 265, or by loading a Gmsh grid file via the corresponding ExtendableGrids.jl extension.","category":"page"},{"location":"#.-Problem-description","page":"Home","title":"2. Problem description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Before discretizing the user has the option to pose his problems in form of a Problem Description. Note, that usually no grid has to be defined at this point, but region numbers correspond to regions defined in the grid. Here is a short example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# a simple Poisson problem with right-hand side f(x,y) = x*y and u = 0 along boundary\nPD = ProblemDescription()\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\nf! = (result, qpinfo) -> (result[1] = qpinfo.x[1] * qpinfo.x[2])\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))","category":"page"},{"location":"#.-Discretization","page":"Home","title":"3. Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this step, the user chooses suitable finite element types for the unknowns of the problem, and generates finite element spaces on the grid (and probably already a solution vector to preoccupy it with an initial solution).","category":"page"},{"location":"","page":"Home","title":"Home","text":"# cubic H1 element in 2D with one component\nFES = FESpace{H1Pk{1,2,3}}(xgrid) \n# alternatively: create solution vector and tag blocks with problem unknowns\nsol = FEVector(FES; tags = PD.unknowns) \n# fill block corresponding to unknown u with initial values\nfill(sol[u], 1)\n# interpolate some given function u!(result, qpinfo)\ninterpolate!(sol[u], u!)","category":"page"},{"location":"#.-Solve","page":"Home","title":"4. Solve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here, we solve the problem. If the problem is nonlinear, several additional arguments allow to steer the fixed-point iteration, see Stationary Solvers. In the simplest case, the user only needs to call:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# solve problem with finite element space(s)\n# (in case of more than one unknown, provide a vector of FESpaces)\nsol = solve(PD, FES; init = sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For time-dependent problem, the user can add the necessary operators for the time derivative manually. Alternatively, the problem description in space can be turned into an ODE and solve via DifferentialEquations.jl, see Time-dependent Solvers for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that the use can bypass the problem description and control the algebraic level manually via assembling the operators directly into an FEMatrix, see e.g. Example310. It is also possible to take control over the low-level assembly of the operators, see ExtendableFEMBase.jl for details.","category":"page"},{"location":"#.-Plot-and-postprocess","page":"Home","title":"5. Plot and postprocess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After solving, the user can postprocess the solution, calculate quantities of interest or plot components.","category":"page"},{"location":"#Gradient-robustness","page":"Home","title":"Gradient-robustness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers some ingredients to build gradient-robust schemes via reconstruction operators or divergence-free elements. Gradient-robustness is a feature of discretisations that exactly balance gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to contruct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfunctions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"homogeneousdata/#HomogeneousData","page":"HomogeneousData","title":"HomogeneousData","text":"","category":"section"},{"location":"homogeneousdata/","page":"HomogeneousData","title":"HomogeneousData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/homogeneousdata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousData","text":"function HomogeneousData(u; entities = ON_CELLS, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the specifies entities and entity regions (via kwargs).\n\nKeyword arguments:\n\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousBoundaryData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousBoundaryData","text":"function HomogeneousBoundaryData(u; entities = ON_BFACES, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the boundary faces and boundary regions (via kwargs).\n\nKeyword arguments:\n\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder   = [:function, :type]","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/#:-Flow-around-a-cylinder","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"","category":"section"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"(source code)","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"This example solves the DFG Navier-Stokes benchmark problem","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"on a rectangular 2D domain with a circular obstacle, see here for details.","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"This script demonstrates the employment of external grid generators and the computation of drag and lift coefficients.","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"Note: This example needs the additional packages Triangulate and SimplexGridFactory to generate the mesh.","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"module Example245_NSEFlowAroundCylinder\n\nusing ExtendableFEM\nusing Triangulate\nusing SimplexGridFactory\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\n# inlet data for Karman vortex street example\n# as in DFG benchmark 2D-1 (Re = 20, laminar)\nconst umax = 0.3\nconst umean = 2 // 3 * umax\nconst L, W, H = 0.1, 2.2, 0.41\nfunction inflow!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = 4 * umax * x[2] * (H - x[2]) / (H * H)\n\tresult[2] = 0.0\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n\tu, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n\tμ = qpinfo.params[1]\n\tresult[1] = dot(u, view(∇u, 1:2))\n\tresult[2] = dot(u, view(∇u, 3:4))\n\tresult[3] = μ * ∇u[1] - p[1]\n\tresult[4] = μ * ∇u[2]\n\tresult[5] = μ * ∇u[3]\n\tresult[6] = μ * ∇u[4] - p[1]\n\tresult[7] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1e-3, maxvol = 1e-3, reconstruct = true, kwargs...)\n\n\t# load grid (see function below)\n\txgrid = make_grid(W, H; n = Int(ceil(sqrt(1 / maxvol))), maxvol = maxvol)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tid_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, inflow!; regions = 4))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 3, 5]))\n\n\t# P2-bubble + reconstruction operator\n\tFETypes = [H1P2B{2, 2}, H1P1{1}]\n\n\t# generate FESpaces and Solution vector\n\tFES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n\n\t# solve\n\tsol = solve(PD, FES; maxiterations = 50, target_residual = 1e-10)\n\n\t# postprocess : compute drag/lift (see function below)\n\tdraglift = get_draglift(sol, μ)\n\tpdiff = get_pressure_difference(sol)\n\tprintln(\"[drag, lift] = $draglift\")\n\tprintln(\"p difference = $pdiff\")\n\n\t# plots via GridVisualize\n\tpl = GridVisualizer(; Plotter = Plotter, layout = (4, 1), clear = true, size = (800, 1200))\n\tgridplot!(pl[1, 1], xgrid, linewidth = 1)\n\tgridplot!(pl[2, 1], xgrid, linewidth = 1, xlimits = [0, 0.3], ylimits = [0.1, 0.3])\n\tscalarplot!(pl[3, 1], xgrid, nodevalues(sol[u]; abs = true)[1, :])\n\tvectorplot!(pl[3, 1], xgrid, eval_func(PointEvaluator([id(u)], sol)), spacing = (0.2, 0.05), vscale = 0.5, clear = false)\n\tscalarplot!(pl[4, 1], xgrid, view(nodevalues(sol[p]), 1, :), levels = 11, title = \"p_h\")\nend\n\nfunction get_pressure_difference(sol::FEVector)\n\txgrid = sol[2].FES.xgrid\n\tPE = PointEvaluator([id(2)], sol)\n\tCF = CellFinder(xgrid)\n\txref = zeros(Float64, 2)\n\tp_left = zeros(Float64, 1)\n\tx1 = [0.1, 0.2]\n\tp_right = zeros(Float64, 1)\n\tx2 = [0.25, 0.2]\n\tcell::Int = gFindLocal!(xref, CF, x1; icellstart = 1)\n\tevaluate!(p_left, PE, xref, cell)\n\tcell = gFindLocal!(xref, CF, x2; icellstart = 1)\n\tevaluate!(p_right, PE, xref, cell)\n\t@show p_left, p_right\n\treturn p_left - p_right\nend\n\nfunction get_draglift(sol::FEVector, μ)\n\n\t# this function is interpolated for drag/lift test function creation\n\tfunction DL_testfunction(component)\n\t\tfunction closure(result, qpinfo)\n\t\t\tx = qpinfo.x\n\t\t\tfill!(result, 0)\n\t\t\tif sqrt((x[1] - 0.2)^2 + (x[2] - 0.2)^2) <= 0.06\n\t\t\t\tresult[component] = 1\n\t\t\tend\n\t\tend\n\tend\n\n\t# drag lift calcuation by testfunctions\n\tfunction draglift_kernel(result, input, qpinfo)\n\t\t# input = [ u, grad(u), p , v , grad(v)]\n\t\t#         [1:2,  3:6,   7 ,8:9,  10:13 ]\n\t\tresult[1] = μ * (input[3] * input[10] + input[4] * input[11] + input[5] * input[12] + input[6] * input[13])\n\t\tresult[1] += (input[1] * input[3] + input[2] * input[4]) * input[8]\n\t\tresult[1] += (input[1] * input[5] + input[2] * input[6]) * input[9]\n\t\tresult[1] -= input[7] * (input[10] + input[13])\n\t\tresult[1] *= -(2 / (umean^2 * L))\n\t\treturn nothing\n\tend\n\tDLIntegrator = ItemIntegrator(draglift_kernel, [id(1), grad(1), id(2), id(3), grad(3)]; quadorder = 4)\n\n\t# test for drag\n\tTestFunction = FEVector(sol[1].FES; name = \"drag/lift testfunction\")\n\tinterpolate!(TestFunction[1], ON_BFACES, DL_testfunction(1))\n\tdrag = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n\t# test for lift\n\tinterpolate!(TestFunction[1], ON_BFACES, DL_testfunction(2))\n\tlift = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n\treturn [drag, lift]\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(W, H; n = 20, maxvol = 0.1)\n\tbuilder = SimplexGridBuilder(Generator = Triangulate)\n\tfunction circlehole!(builder, center, radius; n = 20)\n\t\tpoints = [point!(builder, center[1] + radius * sin(t), center[2] + radius * cos(t)) for t in range(0, 2π, length = n)]\n\t\tfor i ∈ 1:n-1\n\t\t\tfacet!(builder, points[i], points[i+1])\n\t\tend\n\t\tfacet!(builder, points[end], points[1])\n\t\tholepoint!(builder, center)\n\tend\n\tp1 = point!(builder, 0, 0)\n\tp2 = point!(builder, W, 0)\n\tp3 = point!(builder, W, H)\n\tp4 = point!(builder, 0, H)\n\n\t# heuristic refinement around cylinder\n\trefine_radius = 0.25\n\tmaxrefinefactor = 1 // 20\n\tfunction unsuitable(x1, y1, x2, y2, x3, y3, area)\n\t\tif area > maxvol * min(max(4 * maxrefinefactor, abs((x1 + x2 + x3) / 3 - 0.2)), 1 / maxrefinefactor)\n\t\t\treturn true\n\t\tend\n\t\tdist = sqrt(((x1 + x2 + x3) / 3 - 0.2)^2 + ((y1 + y2 + y3) / 3 - 0.2)^2) - 0.05\n\t\tmyarea = dist < refine_radius ? maxvol * max(maxrefinefactor, 1 - (refine_radius - dist) / refine_radius) : maxvol\n\t\tif area > myarea\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\n\tfacetregion!(builder, 1)\n\tfacet!(builder, p1, p2)\n\tfacetregion!(builder, 2)\n\tfacet!(builder, p2, p3)\n\tfacetregion!(builder, 3)\n\tfacet!(builder, p3, p4)\n\tfacetregion!(builder, 4)\n\tfacet!(builder, p4, p1)\n\tfacetregion!(builder, 5)\n\tcirclehole!(builder, (0.2, 0.2), 0.05, n = n)\n\n\tsimplexgrid(builder, maxvolume = 16 * maxvol, unsuitable = unsuitable)\nend\n\nend","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"Default output:","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"julia> Example245_NSEFlowAroundCylinder.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t1.10\n   1\t1.044e-02\t1.277e-14\t1.58\t0.25\t1.84\t\t23.63\t141.17\t164.80\n   2\t1.899e-03\t2.485e-13\t1.57\t0.23\t1.80\t\t18.22\t161.65\t179.87\n   3\t5.382e-04\t1.216e-14\t1.54\t0.17\t1.71\t\t0.72\t132.18\t132.90\n   4\t2.908e-05\t1.438e-14\t1.53\t0.17\t1.71\t\t0.72\t132.18\t132.90\n   5\t1.055e-07\t1.523e-14\t1.53\t0.17\t1.71\t\t0.72\t132.18\t132.90\n END\t1.112e-12\t\t\t1.53\t\t1.54\t\t0.72\t\t0.72\n\tconverged\t\t\t\tSUM -->\t10.29\t\t\tSUM -->\t745.17\n\n(p_left, p_right) = ([0.097880239794547], [0.015171398944499872])\n[drag, lift] = [5.557181737901021, 0.010948148640391703]\np difference = [0.08270884085004714]","category":"page"},{"location":"examples/Example245_NSEFlowAroundCylinder/","page":"245 : Flow around a cylinder","title":"245 : Flow around a cylinder","text":"(Image: )","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/#:-Natural-convection","page":"270 : Natural convection","title":"270 : Natural convection","text":"","category":"section"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"(source code)","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"Seek velocity mathbfu, pressure p and temperature theta such that","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"beginaligned\n\t- mu Delta u + (mathbfu cdot nabla) mathbfu + nabla p  = Ra  theta  g \n       - Delta theta + mathbfu cdot nabla theta  = 0\nendaligned","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"on a given domain Omega (here a triangle) and boundary conditions","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"beginaligned\n\tmathbfu  = 0  quad textalong  partial Omega\n \tT  = T_textbottom quad textalong  y = 0\n\tT  = 0 quad textalong  x = 0\nendaligned","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"The weak formulation seeks (mathbfuptheta) in V times Q times X subseteq H^1_0(Omega)^2 times L^2_0(Omega) times H^1_D(Omega) such that","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"beginaligned\n\t(mu nabla mathbfu nabla mathbfv) + ((mathbfu cdot nabla) mathbfu mathbfv) - (mathrmdiv mathbfv p)  = (mathbfv Ra g  theta)  quad textfor all  mathbfv in V\n(mathrmdiv mathbfu q)  = 0  quad textfor all  q in Q\n       (nabla theta nabla varphi) + (u cdot nabla theta varphi)  = 0\n  quad textfor all  varphi in X\nendaligned","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"To render the discrete method pressure-robust, a reconstruction operator is applied to all identity evaluations of mathbfu and mathbfv (when the switch reconstruct is set to true). Further explanations and discussion on this example can be found in the reference below.","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"reference: Reference\n\"On the divergence constraint in mixed finite element methods for incompressible flows\",\nV. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\nSIAM Review 59(3) (2017),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"module Example270_NaturalConvectionProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, ∇u, p, ∇T, T = view(u_ops, 1:2), view(u_ops,3:6), view(u_ops, 7), view(u_ops, 8:9), view(u_ops, 10)\n    Ra, μ, ϵ = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3]\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4)) - Ra*T[1]\n    result[3] = μ*∇u[1] - p[1]\n    result[4] = μ*∇u[2]\n    result[5] = μ*∇u[3]\n    result[6] = μ*∇u[4] - p[1]\n    result[7] = -(∇u[1] + ∇u[4])\n    result[8] = ϵ*∇T[1]\n    result[9] = ϵ*∇T[2]\n    result[10] = dot(u, ∇T)\n    return nothing\nend\n\nfunction T_bottom!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 2*(1-cos(2*π*x[1]))\nend\n\nfunction main(;\n    nrefs = 5,\n    μ = 1.0,\n    ϵ = 1.0,\n    Ra_final = 1.0e6,\n    reconstruct = true,\n    Plotter = nothing,\n    kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    T = Unknown(\"T\"; name = \"temperature\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, T)\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u,grad(u),id(p),grad(T),id(T)]; kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:3))\n    assign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n    assign_operator!(PD, HomogeneousBoundaryData(T; regions = 3))\n    assign_operator!(PD, InterpolateBoundaryData(T, T_bottom!; regions = 1))\n\n    # grid\n    xgrid = uniform_refine(reference_domain(Triangle2D), nrefs)\n\n    # FESpaces\n    FES = Dict(u => FESpace{H1BR{2}}(xgrid),\n               p => FESpace{L2P0{1}}(xgrid),\n               T => FESpace{H1P1{1}}(xgrid))\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1,3), clear = true, size = (1200,400))\n\n    # solve by Ra embedding\n\tparams = Array{Float64,1}([min(Ra_final, 4000), μ, ϵ])\n    sol = nothing\n    SC = nothing\n\tstep = 0\n\twhile (true)\n        # solve (params are given to all operators)\n        sol, SC = ExtendableFEM.solve(PD, FES, SC; init = sol, return_config = true, target_residual = 1e-6, params = params, kwargs...)\n\n        # plot\n        scalarplot!(plt[1,1], id(u), sol; levels = 0, colorbarticks = 7, abs = true)\n        vectorplot!(plt[1,1], id(u), sol; clear = false, title = \"|u| + quiver (Ra = $(params[1]))\")\n        scalarplot!(plt[1,2], id(T), sol; title = \"T (Ra = $(params[1]))\")\n        scalarplot!(plt[1,3], id(p), sol; title = \"p (Ra = $(params[1]))\")\n\n        # stop if Ra_final is reached\n\t\tif params[1] >= Ra_final\n\t\t\tbreak\n\t\tend\n\n        # increase Ra\n\t\tparams[1] = min(Ra_final, params[1]*3)\n\t\tstep += 1\n\t\t@info \"Step $step : solving for Ra=$(params[1])\"\n\tend\n\n    # compute Nusselt number along bottom (= boundary region 1)\n    ∇T_faces = FaceInterpolator([jump(grad(T))]; order = 0, kwargs...)\n\tNuIntegrator = ItemIntegrator((result, input, qpinfo) -> (result[1] = -input[2]), [id(1)]; entities = ON_FACES, regions = [1])\n\t@info \"Nu = $(sum(evaluate(NuIntegrator, evaluate!(∇T_faces, sol))))\"\n\n    return sol\nend\n\nend # module","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"Default output:","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"julia> Example270_NaturalConvectionProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.23\n   1\t2.317e+01\t3.077e-11\t0.23\t0.04\t0.27\t\t4.10\t15.67\t19.77\n   2\t1.507e+01\t8.579e-11\t0.20\t0.04\t0.24\t\t3.16\t17.20\t20.36\n   3\t1.814e+00\t3.405e-11\t0.20\t0.05\t0.25\t\t0.15\t13.14\t13.30\n   4\t1.312e-01\t2.541e-11\t0.20\t0.03\t0.22\t\t0.15\t13.14\t13.30\n   5\t4.601e-04\t2.326e-11\t0.20\t0.03\t0.23\t\t0.15\t13.14\t13.30\n END\t2.207e-09\t\t\t0.20\t\t0.20\t\t0.15\t\t0.15\n\tconverged\t\t\t\tSUM -->\t1.40\t\t\tSUM -->\t80.41\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t3.965e+02\t8.919e-10\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   2\t4.226e+01\t1.698e-10\t0.20\t0.05\t0.25\t\t0.16\t13.14\t13.30\n   3\t4.205e+00\t3.669e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   4\t6.763e-02\t6.935e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   5\t2.126e-05\t8.792e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n END\t8.792e-09\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t1.36\t\t\tSUM -->\t66.65\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t1.182e+03\t2.625e-10\t0.20\t0.04\t0.23\t\t0.16\t13.14\t13.30\n   2\t1.188e+02\t7.779e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   3\t2.150e+01\t1.135e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   4\t1.019e+00\t1.697e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   5\t2.696e-03\t2.896e-09\t0.20\t0.04\t0.24\t\t0.16\t13.14\t13.30\n END\t1.149e-08\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t1.35\t\t\tSUM -->\t66.65\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t3.431e+03\t9.538e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   2\t4.403e+02\t1.529e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   3\t1.091e+02\t3.165e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   4\t1.104e+01\t1.531e-08\t0.20\t0.04\t0.23\t\t0.16\t13.14\t13.30\n   5\t1.319e-01\t2.166e-08\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   6\t1.327e-05\t5.323e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n END\t5.323e-09\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t1.57\t\t\tSUM -->\t79.95\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t9.821e+03\t8.066e-10\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   2\t2.159e+03\t1.763e-09\t0.20\t0.04\t0.23\t\t0.16\t13.14\t13.30\n   3\t5.758e+02\t5.365e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   4\t1.364e+02\t5.969e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   5\t1.020e+01\t1.694e-09\t0.20\t0.03\t0.23\t\t0.16\t13.14\t13.30\n   6\t1.191e-02\t2.227e-09\t0.20\t0.04\t0.24\t\t0.16\t13.14\t13.30\n END\t2.944e-07\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t1.59\t\t\tSUM -->\t79.95\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t2.761e+04\t2.237e-09\t0.20\t0.03\t0.23\t\t0.16\t15.49\t15.65\n   2\t1.388e+04\t2.887e-09\t0.20\t0.03\t0.23\t\t0.16\t15.58\t15.73\n   3\t4.992e+03\t2.568e-09\t0.20\t0.04\t0.24\t\t0.16\t15.54\t15.69\n   4\t2.276e+03\t1.722e-08\t0.20\t0.03\t0.23\t\t0.16\t15.60\t15.75\n   5\t8.979e+02\t2.989e-09\t0.20\t0.03\t0.23\t\t0.16\t15.49\t15.64\n   6\t1.208e+02\t2.505e-09\t0.20\t0.04\t0.24\t\t0.16\t15.59\t15.74\n   7\t1.574e+01\t5.427e-09\t0.20\t0.03\t0.23\t\t0.16\t15.61\t15.77\n   8\t6.250e-02\t3.891e-09\t0.20\t0.03\t0.23\t\t0.16\t15.61\t15.77\n   9\t7.218e-06\t5.026e-09\t0.20\t0.04\t0.24\t\t0.16\t15.61\t15.77\n END\t5.071e-09\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t2.29\t\t\tSUM -->\t141.68\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.00\n   1\t1.101e+03\t3.819e-09\t0.20\t0.03\t0.23\t\t0.16\t15.58\t15.73\n   2\t2.032e+00\t3.302e-09\t0.20\t0.03\t0.23\t\t0.16\t15.62\t15.77\n   3\t1.311e-03\t5.047e-09\t0.20\t0.04\t0.24\t\t0.16\t15.62\t15.77\n END\t5.059e-09\t\t\t0.20\t\t0.20\t\t0.16\t\t0.16\n\tconverged\t\t\t\tSUM -->\t0.90\t\t\tSUM -->\t47.44\n","category":"page"},{"location":"examples/Example270_NaturalConvectionProblem/","page":"270 : Natural convection","title":"270 : Natural convection","text":"(Image: )","category":"page"},{"location":"examples/Example301_PoissonProblem/#:-Poisson-Problem","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"","category":"section"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"(source code)","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit cube domain Omega on a given grid.","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"module Example301_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2] * qpinfo.x[3]\nend\n\nfunction main(; μ = 1.0, nrefs = 3, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitcube(Tetrahedron3D), nrefs)\n\tFES = FESpace{H1P2{1, 3}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplot([id(u)], sol; Plotter = Plotter)\nend\n\nend # module","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"Default output:","category":"page"},{"location":"examples/Example301_PoissonProblem/","page":"301 : Poisson-Problem","title":"301 : Poisson-Problem","text":"julia> Example301_PoissonProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.51\n END\t---------\t8.593e-17\t0.08\t0.11\t0.20\t\t7.30\t45.23\t52.53\n\tfinished\t\t\t\tSUM -->\t0.20\t\t\tSUM -->\t53.04\n","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/#:-Robin-Boundary-Condition","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"","category":"section"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"(source code)","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"This demonstrates the assignment of a mixed Robin boundary condition for a nonlinear 1D convection-diffusion-reaction PDE on the unit interval, i.e.","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"beginaligned\n-partial^2 u  partial x^2 + u partial u  partial x + u  = f  textin  Omega\nu + partial u  partial_x  = g  textat  Gamma_1 =  0 \nu  = u_D  textat  Gamma_2 =  1 \nendaligned","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"tested with data f(x) = e^2x, g = 2 and u_D = e such that u(x) = e^x is the exact solution.","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"module Example108_RobinBoundaryCondition\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\n\n# data and exact solution\nfunction f!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = exp(2 * x[1])\nend\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = exp(x[1])\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion oeprator\nfunction nonlinear_kernel!(result, input, qpinfo)\n\t# input = [u,∇u] as a vector of length 2\n\tresult[1] = input[1] * input[2] + input[1] # convection + reaction (will be multiplied with v)\n\tresult[2] = input[2]                       # diffusion (will be multiplied with ∇v)\n\treturn nothing\nend\n\n# kernel for Robin boundary condition\nfunction robin_kernel!(result, input, qpinfo)\n\t# input = [u]\n\tresult[1] = 2 - input[1] # = g - u (will be multiplied with v)\n\treturn nothing\nend\n\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 1e-1, h_fine = 1e-3, order = 2, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; kwargs...))\n\tassign_operator!(PD, BilinearOperator(robin_kernel!, [id(u)]; entities = ON_BFACES, regions = [1], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = [2], kwargs...))\n\n\t# generate coarse and fine mesh\n\txgrid = simplexgrid(0:h:1)\n\n\t# choose some finite element type and generate a FESpace for the grid\n\t# (here it is a one-dimensional H1-conforming P2 element H1P2{1,1})\n\tFEType = H1Pk{1, 1, order}\n\tFES = FESpace{FEType}(xgrid)\n\n\t# generate a solution vector and solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# compute L2 error\n\tL2error = ItemIntegrator(exact_error!, [id(u)]; quadorder = 2 * order, kwargs...)\n\tprintln(\"L2error = $(sqrt(sum(evaluate(L2error, sol))))\")\n\n\t# plot discrete and exact solution (on finer grid)\n\tp = GridVisualizer(Plotter = Plotter, layout = (1, 1))\n\tscalarplot!(p[1, 1], id(u), sol; color = :black, label = \"u_h\", markershape = :circle, markersize = 10, markevery = 1)\n\txgrid_fine = simplexgrid(0:h_fine:1)\n\tscalarplot!(p[1, 1], xgrid_fine, view(nodevalues(xgrid_fine, u!), 1, :), clear = false, color = (1, 0, 0), label = \"u\", legend = :rb, markershape = :none)\nend\n\nend","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"Default output:","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"julia> Example108_RobinBoundaryCondition.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n   1\t7.345e+01\t5.791e-14\t0.00\t0.00\t0.00\t\t0.10\t0.04\t0.14\n   2\t6.400e-01\t5.230e-14\t0.00\t0.00\t0.00\t\t0.01\t0.03\t0.04\n   3\t5.344e-02\t5.993e-14\t0.00\t0.00\t0.00\t\t0.01\t0.03\t0.04\n   4\t4.413e-05\t5.241e-14\t0.00\t0.00\t0.00\t\t0.01\t0.03\t0.04\n END\t4.730e-11\t\t\t0.00\t\t0.00\t\t0.01\t\t0.01\n\tconverged\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.27\n\nL2error = 9.062544216508815e-6","category":"page"},{"location":"examples/Example108_RobinBoundaryCondition/","page":"108 : Robin Boundary Condition","title":"108 : Robin Boundary Condition","text":"(Image: )","category":"page"},{"location":"examples/Example280_CompressibleStokes/#:-Compressible-Stokes","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"","category":"section"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"(source code)","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"This example solves the two-dimensional compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"Here eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"There are two testcases. The first testcase solves an analytical toy problem with the prescribed solution","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = exp(-yc) \np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. The second testcase tests an analytical nonzero velocity benchmark problem with the same density.","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"This example is designed to study the well-balanced property of a discretisation. The gradient-robust discretisation approximates the well-balanced state much better, i.e. has a much smaller L2 velocity error. For larger c (= smaller Mach number) the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. See reference below for more details.","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"module Example280_CompressibleStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Triangulate\nusing SimplexGridFactory\nusing GridVisualize\nusing Symbolics\nusing LinearAlgebra\n\n# everything is wrapped in a main function\n# testcase = 1 : well-balanced test (stratified no-flow over mountain)\n# testcase = 2 : vortex example (ϱu is div-free p7 vortex)\nfunction main(;\n    testcase = 1,\n    nrefs = 4,\n    M = 1,\n    c = 1,\n    ufac = 100,\n    pressure_stab = 0,\n    laplacian_in_rhs = false, # for data in example 2\n    maxsteps = 5000,\n    target_residual = 1e-11,\n    Plotter = nothing,\n    reconstruct = true,\n    μ = 1,\n    order = 1,\n    kwargs...)\n\n\t# load data for testcase\n    grid_builder, kernel_gravity!, kernel_rhs!, u!, ∇u!, ϱ!, τfac = load_testcase_data(testcase; laplacian_in_rhs = laplacian_in_rhs, M = M, c = c, μ = μ, ufac = ufac)\n    xgrid = grid_builder(nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    ϱ = Unknown(\"ϱ\"; name = \"density\", dim = 1)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n\n    # define reconstruction operator\n    if order == 1\n        FETypes = [H1BR{2}, L2P0{1}, L2P0{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT0{2}, Identity}) : id(u)\n    elseif order == 2\n        FETypes = [H1P2B{2,2}, L2P1{1}, L2P1{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n    end\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n    assign_operator!(PD, LinearOperator([div(u)], [id(ϱ)]; factor = c, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    if kernel_rhs! !== nothing\n        assign_operator!(PD, LinearOperator(kernel_rhs!, [id_u]; factor = 1, store = true, bonus_quadorder = 3*order, kwargs...))\n    end\n    assign_operator!(PD, LinearOperator(kernel_gravity!, [id_u], [id(ϱ)]; factor = 1, bonus_quadorder = 3*order, kwargs...))\n\n    # FVM for continuity equation\n\tτ = μ / (order^2*M*sqrt(τfac)) # time step for pseudo timestepping\n    @info \"timestep = $τ\"\n    PDT = ProblemDescription(\"continuity equation\")\n    assign_unknown!(PDT, ϱ)\n    if order > 1\n       assign_operator!(PDT, BilinearOperator(kernel_continuity!,[grad(ϱ)],[id(ϱ)],[id(u)]; quadorder = 2*order, factor = -1, kwargs...))\n    end\n    if pressure_stab > 0\n        psf = pressure_stab #* xgrid[CellVolumes][1]\n        assign_operator!(PDT, BilinearOperator(stab_kernel!, [jump(id(ϱ))], [jump(id(ϱ))], [id(u)]; entities = ON_IFACES, factor = psf, kwargs...))\n    end\n    assign_operator!(PDT, BilinearOperator([id(ϱ)]; quadorder = 2*(order-1), factor = 1/τ, store = true, kwargs...))\n    assign_operator!(PDT, LinearOperator([id(ϱ)], [id(ϱ)]; quadorder = 2*(order-1), factor = 1/τ, kwargs...))\n\n    # prepare error calculation\n    ErrorIntegratorExact = ItemIntegrator(exact_error!(u!, ∇u!, ϱ!), [id(u), grad(u), id(ϱ)]; resultdim = 9, quadorder = 2*(order+1), kwargs...)\n    NDofs = zeros(Int, nrefs)\n    Results = zeros(Float64, nrefs, 5)\n\n    sol = nothing\n    xgrid = nothing\n    op_upwind = 0\n    for lvl = 1 : nrefs\n        xgrid = grid_builder(lvl)\n        @show xgrid\n        FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 3]\n        sol = FEVector(FES; tags = [u,ϱ,p])\n\n        if lvl == 1\n            op_upwind = assign_operator!(PDT, BilinearOperatorDG(kernel_upwind!(xgrid), [jump(id(ϱ))], [this(id(ϱ)), other(id(ϱ))], [id(u)]; quadorder = order+1, entities = ON_IFACES, kwargs...))\n        else\n            replace_operator!(PDT, op_upwind, BilinearOperatorDG(kernel_upwind!(xgrid), [jump(id(ϱ))], [this(id(ϱ)), other(id(ϱ))], [id(u)]; quadorder = order+1, entities = ON_IFACES, kwargs...))\n        end\n\n        # initial guess\n        fill!(sol[ϱ],M)\n        interpolate!(sol[u], u!)\n        interpolate!(sol[ϱ], ϱ!)\n        NDofs[lvl] = length(sol.entries)\n\n        # solve the two problems iteratively [1] >> [2] >> [1] >> [2] ...\n        SC1 = SolverConfiguration(PD; init = sol, maxiterations = 1, target_residual = target_residual, constant_matrix = true, kwargs...)\n        SC2 = SolverConfiguration(PDT; init = sol, maxiterations = 1, target_residual = target_residual, kwargs...)\n        sol, nits = iterate_until_stationarity([SC1, SC2]; maxsteps = maxsteps, init = sol, kwargs...)\n\n        # caculate error\n        error = evaluate(ErrorIntegratorExact, sol)\n        Results[lvl,1] = sqrt(sum(view(error,1,:)) + sum(view(error,2,:)))\n        Results[lvl,2] = sqrt(sum(view(error,3,:)) + sum(view(error,4,:)) + sum(view(error,5,:)) + sum(view(error,6,:)))\n        Results[lvl,3] = sqrt(sum(view(error,7,:)))\n        Results[lvl,4] = sqrt(sum(view(error,8,:)) + sum(view(error,9,:)))\n        Results[lvl,5] = nits\n\n        # print results\n        print_convergencehistory(NDofs[1:lvl], Results[1:lvl,:]; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\",\"#its\"], xlabel = \"ndof\")\n    end\n\n\n    # plot\n    pl = GridVisualizer(; Plotter = Plotter, layout = (2,2), clear = true, size = (1000,1000))\n    scalarplot!(pl[1,1],xgrid, view(nodevalues(sol[u]; abs = true),1,:), levels = 0, colorbarticks = 7)\n    vectorplot!(pl[1,1],xgrid, eval_func(PointEvaluator([id(u)], sol)), spacing = 0.1, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(pl[2,1],xgrid, view(nodevalues(sol[ϱ]),1,:), levels = 11, title = \"ϱ_h\")\n    plot_convergencehistory!(pl[1,2], NDofs, Results[:,1:4]; add_h_powers = [order,order+1], X_to_h = X -> 0.2*X.^(-1/2), legend = :best, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\",\"#its\"])\n    gridplot!(pl[2,2],xgrid)\nend\n\nfunction stab_kernel!(result, p, u, qpinfo)\n    result[1] = p[1] #*abs(u[1] + u[2])\nend\n\n# kernel for (uϱ, ∇λ) ON_CELLS in continuity equation\nfunction kernel_continuity!(result, ϱ, u, qpinfo)\n    result[1]  = ϱ[1] * u[1]\n    result[2]  = ϱ[1] * u[2]\nend\n\n# kernel for (u⋅n ϱ^upw, λ) ON_IFACES in continuity equation\nfunction kernel_upwind!(xgrid)\n    facenormals = xgrid[FaceNormals]\n    flux::Float64 = 0\n    function closure(result, input, u, qpinfo)\n        flux = dot(u, view(facenormals,:,qpinfo.item))\n        if flux > 0\n            result[1] = input[1] * flux\n        else\n            result[1] = input[2] * flux\n        end\n    end\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!,∇u!,ϱ!)\n    function closure(result, u, qpinfo)\n        u!(view(result,1:2), qpinfo)\n        ∇u!(view(result,3:6), qpinfo)\n        ϱ!(view(result,7), qpinfo)\n        result[8] = result[1] * result[7]\n        result[9] = result[2] * result[7]\n        view(result,1:7) .-= u\n        result[8] -= u[1] * u[7]\n        result[9] -= u[2] * u[7]\n        result .= result.^2\n    end\nend\n\n# kernel for gravity term in testcase 1\nfunction standard_gravity!(result, ϱ, qpinfo)\n    result[1] = 0\n    result[2] = -ϱ[1]\nend\n\nfunction load_testcase_data(testcase::Int = 1; laplacian_in_rhs = true, M = 1, c = 1, μ = 1, ufac = 100)\n    if testcase == 1\n        grid_builder = (nref) -> simplexgrid(Triangulate;\n                    points = [0 0; 0.2 0; 0.3 0.2; 0.45 0.05; 0.55 0.35; 0.65 0.2; 0.7 0.3; 0.8 0; 1 0; 1 1 ; 0 1]',\n                    bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 1]',\n                    bfaceregions = ones(Int,11),\n                    regionpoints = [0.5 0.5;]',\n                    regionnumbers = [1],\n                    regionvolumes = [4.0^-(nref)/2])\n        xgrid = grid_builder(3)\n        u1!(result, qpinfo) = (fill!(result, 0);)\n        ∇u1!(result, qpinfo) = (fill!(result, 0);)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[2]/c)/M;), 1; quadorder = 20)\n        area = sum(xgrid[CellVolumes])\n        ϱ1!(result, qpinfo) = (result[1] = exp(-qpinfo.x[2]/c)/(M_exact/area);)\n        return grid_builder, standard_gravity!, nothing, u1!, ∇u1!, ϱ1!, 1\n    elseif testcase == 2\n        grid_builder = (nref) -> simplexgrid(Triangulate;\n                    points = [0 0; 1 0; 1 1 ; 0 1]',\n                    bfaces = [1 2; 2 3; 3 4; 4 1]',\n                    bfaceregions = ones(Int,4),\n                    regionpoints = [0.5 0.5;]',\n                    regionnumbers = [1],\n                    regionvolumes = [4.0^-(nref)])\n\n        xgrid = grid_builder(3)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[1]^3/(3*c));), 1; quadorder = 20)\n        ϱ_eval, g_eval, f_eval, u_eval, ∇u_eval = prepare_data!(; laplacian_in_rhs = laplacian_in_rhs, M = M_exact, c = c, μ = μ, ufac = ufac)\n        ϱ2!(result, qpinfo) = (result[1] = ϱ_eval(qpinfo.x[1], qpinfo.x[2]);)\n\n        M_exact = integrate(xgrid, ON_CELLS, ϱ2!, 1)\n        area = sum(xgrid[CellVolumes])\n\n        function kernel_gravity!(result, input, qpinfo)\n            g_eval(result, qpinfo.x[1], qpinfo.x[2])\n            result .*= input[1]\n        end\n\n        function kernel_rhs!(result, qpinfo)\n            f_eval(result, qpinfo.x[1], qpinfo.x[2])\n        end\n\n        u2!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        ∇u2!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        return grid_builder, kernel_gravity!, f_eval === nothing ? nothing : kernel_rhs!, u2!, ∇u2!, ϱ2!, ufac\n    end\nend\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; M = 1, c = 1, μ = 1, ufac = 100, laplacian_in_rhs = true)\n\n\t@variables x y\n\n\t# density\n\tϱ = exp(-x^3/(3*c))/M\n\n\t# stream function ξ\n\t# sucht that ϱu = curl ξ\n\tξ = x^2*y^2*(x-1)^2*(y-1)^2 * ufac\n\n\t∇ξ = Symbolics.gradient(ξ, [x,y])\n\n\t# velocity u = curl ξ / ϱ\n\tu = [-∇ξ[2], ∇ξ[1]] ./ ϱ\n\n\t# gradient of velocity\n\t∇u = Symbolics.jacobian(u, [x,y])\n\t∇u_reshaped = [∇u[1,1], ∇u[1,2], ∇u[2,1], ∇u[2,2]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1,1], [x]) + Symbolics.gradient(∇u[1,2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2,1], [x]) + Symbolics.gradient(∇u[2,2], [y]))[1]\n\t]\n\n\t# gravity ϱg = - Δu + ϱ∇log(ϱ)\n\n    if laplacian_in_rhs\n        f = - μ*Δu\n        g = c * Symbolics.gradient(log(ϱ), [x,y])\n\telse\n        g = - μ*Δu/ϱ + c * Symbolics.gradient(log(ϱ), [x,y])\n        f = 0\n    end\n\n\t#Δu = Symbolics.derivative(∇u[1,1], [x]) + Symbolics.derivative(∇u[2,2], [y])\n\n\tϱ_eval = build_function(ϱ, x, y, expression = Val{false})\n\tu_eval = build_function(u, x, y, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n\tg_eval = build_function(g, x, y, expression = Val{false})\n\tf_eval = build_function(f, x, y, expression = Val{false})\n\n    return ϱ_eval, g_eval[2], f == 0 ? nothing : f_eval[2], u_eval[2], ∇u_eval[2]\nend\nend","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"Default output:","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"julia> Example280_CompressibleStokes.main()\nxgrid = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 16 cells: 16 bfaces: 14\n\n\n    1\t\tres[1] = 7.51e-03 (1.278e-18)\tres[2] = 4.78e-04 (2.882e-17)\n    2\t\tres[1] = 6.58e-03 (4.544e-19)\tres[2] = 1.04e-04 (9.813e-18)\n    3\t\tres[1] = 1.02e-03 (3.278e-19)\tres[2] = 5.21e-05 (2.508e-17)\n    4\t\tres[1] = 4.77e-04 (2.034e-19)\tres[2] = 3.19e-05 (2.435e-17)\n    5\t\tres[1] = 2.63e-04 (1.397e-19)\tres[2] = 2.31e-05 (1.900e-17)\n    6\t\tres[1] = 1.74e-04 (1.331e-19)\tres[2] = 1.84e-05 (2.353e-17)\n    7\t\tres[1] = 1.29e-04 (2.568e-20)\tres[2] = 1.52e-05 (3.622e-17)\n    8\t\tres[1] = 1.01e-04 (6.404e-20)\tres[2] = 1.28e-05 (3.491e-17)\n    9\t\tres[1] = 8.20e-05 (1.224e-19)\tres[2] = 1.09e-05 (2.222e-17)\n   10\t\tres[1] = 6.74e-05 (4.768e-20)\tres[2] = 9.24e-06 (2.359e-17)\n   11\t\tres[1] = 5.58e-05 (3.880e-20)\tres[2] = 7.87e-06 (2.596e-17)\n   12\t\tres[1] = 4.65e-05 (6.397e-20)\tres[2] = 6.70e-06 (3.064e-17)\n   13\t\tres[1] = 3.88e-05 (3.119e-20)\tres[2] = 5.71e-06 (2.453e-17)\n   14\t\tres[1] = 3.25e-05 (4.101e-20)\tres[2] = 4.87e-06 (3.064e-17)\n   15\t\tres[1] = 2.72e-05 (4.552e-20)\tres[2] = 4.15e-06 (2.526e-17)\n   16\t\tres[1] = 2.29e-05 (4.585e-20)\tres[2] = 3.54e-06 (3.672e-17)\n   17\t\tres[1] = 1.93e-05 (4.025e-20)\tres[2] = 3.02e-06 (1.700e-17)\n   18\t\tres[1] = 1.63e-05 (2.458e-20)\tres[2] = 2.58e-06 (2.353e-17)\n   19\t\tres[1] = 1.37e-05 (1.902e-20)\tres[2] = 2.21e-06 (2.404e-17)\n   20\t\tres[1] = 1.16e-05 (3.098e-20)\tres[2] = 1.89e-06 (2.710e-17)\n   21\t\tres[1] = 9.81e-06 (1.143e-20)\tres[2] = 1.62e-06 (2.964e-17)\n   22\t\tres[1] = 8.32e-06 (2.424e-20)\tres[2] = 1.39e-06 (3.704e-17)\n   23\t\tres[1] = 7.07e-06 (2.229e-20)\tres[2] = 1.20e-06 (3.127e-17)\n   24\t\tres[1] = 6.01e-06 (2.296e-20)\tres[2] = 1.03e-06 (2.327e-17)\n   25\t\tres[1] = 5.11e-06 (1.763e-20)\tres[2] = 8.91e-07 (2.642e-17)\n   26\t\tres[1] = 4.35e-06 (2.063e-20)\tres[2] = 7.71e-07 (2.532e-17)\n   27\t\tres[1] = 3.71e-06 (2.828e-20)\tres[2] = 6.70e-07 (2.596e-17)\n   28\t\tres[1] = 3.17e-06 (2.729e-20)\tres[2] = 5.84e-07 (2.776e-17)\n   29\t\tres[1] = 2.71e-06 (1.793e-20)\tres[2] = 5.10e-07 (3.688e-17)\n   30\t\tres[1] = 2.33e-06 (1.637e-20)\tres[2] = 4.48e-07 (2.194e-17)\n   31\t\tres[1] = 2.00e-06 (2.114e-20)\tres[2] = 3.94e-07 (4.291e-17)\n   32\t\tres[1] = 1.72e-06 (3.467e-20)\tres[2] = 3.48e-07 (2.619e-17)\n   33\t\tres[1] = 1.49e-06 (1.031e-20)\tres[2] = 3.09e-07 (3.123e-17)\n   34\t\tres[1] = 1.29e-06 (3.718e-20)\tres[2] = 2.75e-07 (2.887e-17)\n   35\t\tres[1] = 1.12e-06 (2.463e-20)\tres[2] = 2.46e-07 (3.417e-17)\n   36\t\tres[1] = 9.75e-07 (2.231e-20)\tres[2] = 2.21e-07 (2.429e-17)\n   37\t\tres[1] = 8.52e-07 (2.059e-20)\tres[2] = 1.99e-07 (2.781e-17)\n   38\t\tres[1] = 7.47e-07 (2.305e-20)\tres[2] = 1.80e-07 (2.404e-17)\n   39\t\tres[1] = 6.57e-07 (1.963e-20)\tres[2] = 1.63e-07 (3.142e-17)\n   40\t\tres[1] = 5.80e-07 (3.006e-20)\tres[2] = 1.48e-07 (2.453e-17)\n   41\t\tres[1] = 5.13e-07 (2.568e-20)\tres[2] = 1.34e-07 (3.417e-17)\n   42\t\tres[1] = 4.56e-07 (3.174e-20)\tres[2] = 1.23e-07 (3.606e-17)\n   43\t\tres[1] = 4.07e-07 (1.643e-20)\tres[2] = 1.12e-07 (2.404e-17)\n   44\t\tres[1] = 3.64e-07 (1.913e-20)\tres[2] = 1.03e-07 (2.110e-17)\n   45\t\tres[1] = 3.27e-07 (1.364e-20)\tres[2] = 9.41e-08 (3.103e-17)\n   46\t\tres[1] = 2.95e-07 (1.468e-20)\tres[2] = 8.64e-08 (2.429e-17)\n   47\t\tres[1] = 2.67e-07 (2.036e-20)\tres[2] = 7.94e-08 (4.065e-17)\n   48\t\tres[1] = 2.42e-07 (2.278e-20)\tres[2] = 7.30e-08 (2.619e-17)\n   49\t\tres[1] = 2.20e-07 (2.603e-20)\tres[2] = 6.72e-08 (1.836e-17)\n   50\t\tres[1] = 2.00e-07 (2.605e-20)\tres[2] = 6.19e-08 (2.532e-17)\n   51\t\tres[1] = 1.83e-07 (2.262e-20)\tres[2] = 5.70e-08 (2.194e-17)\n   52\t\tres[1] = 1.67e-07 (2.577e-20)\tres[2] = 5.25e-08 (2.797e-17)\n   53\t\tres[1] = 1.53e-07 (2.425e-20)\tres[2] = 4.84e-08 (3.049e-17)\n   54\t\tres[1] = 1.40e-07 (2.799e-20)\tres[2] = 4.46e-08 (2.532e-17)\n   55\t\tres[1] = 1.28e-07 (2.288e-20)\tres[2] = 4.12e-08 (3.273e-17)\n   56\t\tres[1] = 1.18e-07 (2.365e-20)\tres[2] = 3.80e-08 (3.417e-17)\n   57\t\tres[1] = 1.08e-07 (2.114e-20)\tres[2] = 3.50e-08 (3.417e-17)\n   58\t\tres[1] = 9.93e-08 (2.055e-20)\tres[2] = 3.23e-08 (2.964e-17)\n   59\t\tres[1] = 9.13e-08 (2.291e-20)\tres[2] = 2.98e-08 (3.487e-17)\n   60\t\tres[1] = 8.40e-08 (2.710e-20)\tres[2] = 2.75e-08 (3.399e-17)\n   61\t\tres[1] = 7.73e-08 (2.268e-20)\tres[2] = 2.54e-08 (2.404e-17)\n   62\t\tres[1] = 7.12e-08 (2.855e-20)\tres[2] = 2.34e-08 (2.139e-17)\n   63\t\tres[1] = 6.55e-08 (2.964e-20)\tres[2] = 2.16e-08 (3.108e-17)\n   64\t\tres[1] = 6.04e-08 (3.264e-20)\tres[2] = 1.99e-08 (1.836e-17)\n   65\t\tres[1] = 5.56e-08 (1.677e-20)\tres[2] = 1.84e-08 (2.882e-17)\n   66\t\tres[1] = 5.12e-08 (2.249e-20)\tres[2] = 1.70e-08 (1.993e-17)\n   67\t\tres[1] = 4.72e-08 (2.069e-20)\tres[2] = 1.57e-08 (4.553e-17)\n   68\t\tres[1] = 4.35e-08 (3.016e-20)\tres[2] = 1.44e-08 (3.346e-17)\n   69\t\tres[1] = 4.01e-08 (2.805e-20)\tres[2] = 1.33e-08 (2.803e-17)\n   70\t\tres[1] = 3.70e-08 (2.796e-20)\tres[2] = 1.23e-08 (3.328e-17)\n   71\t\tres[1] = 3.41e-08 (1.766e-20)\tres[2] = 1.14e-08 (2.532e-17)\n   72\t\tres[1] = 3.15e-08 (2.694e-20)\tres[2] = 1.05e-08 (1.876e-17)\n   73\t\tres[1] = 2.90e-08 (2.408e-20)\tres[2] = 9.67e-09 (3.025e-17)\n   74\t\tres[1] = 2.68e-08 (1.187e-20)\tres[2] = 8.92e-09 (4.722e-17)\n   75\t\tres[1] = 2.47e-08 (1.684e-20)\tres[2] = 8.23e-09 (2.117e-17)\n   76\t\tres[1] = 2.28e-08 (1.874e-20)\tres[2] = 7.60e-09 (4.885e-17)\n   77\t\tres[1] = 2.10e-08 (3.518e-20)\tres[2] = 7.01e-09 (3.741e-17)\n   78\t\tres[1] = 1.94e-08 (2.802e-20)\tres[2] = 6.47e-09 (3.688e-17)\n   79\t\tres[1] = 1.79e-08 (1.546e-20)\tres[2] = 5.97e-09 (1.963e-17)\n   80\t\tres[1] = 1.65e-08 (2.410e-20)\tres[2] = 5.51e-09 (3.737e-17)\n   81\t\tres[1] = 1.52e-08 (1.781e-20)\tres[2] = 5.08e-09 (3.255e-17)\n   82\t\tres[1] = 1.40e-08 (1.911e-20)\tres[2] = 4.69e-09 (2.089e-17)\n   83\t\tres[1] = 1.29e-08 (3.091e-20)\tres[2] = 4.33e-09 (2.508e-17)\n   84\t\tres[1] = 1.19e-08 (2.204e-20)\tres[2] = 4.00e-09 (2.866e-17)\n   85\t\tres[1] = 1.10e-08 (2.087e-20)\tres[2] = 3.69e-09 (3.399e-17)\n   86\t\tres[1] = 1.02e-08 (2.125e-20)\tres[2] = 3.40e-09 (3.127e-17)\n   87\t\tres[1] = 9.39e-09 (2.677e-20)\tres[2] = 3.14e-09 (4.235e-17)\n   88\t\tres[1] = 8.66e-09 (1.970e-20)\tres[2] = 2.90e-09 (4.120e-17)\n   89\t\tres[1] = 7.99e-09 (2.521e-20)\tres[2] = 2.67e-09 (3.832e-17)\n   90\t\tres[1] = 7.37e-09 (1.136e-20)\tres[2] = 2.47e-09 (3.753e-17)\n   91\t\tres[1] = 6.80e-09 (1.369e-20)\tres[2] = 2.28e-09 (2.737e-17)\n   92\t\tres[1] = 6.28e-09 (1.704e-20)\tres[2] = 2.10e-09 (2.819e-17)\n   93\t\tres[1] = 5.79e-09 (2.028e-20)\tres[2] = 1.94e-09 (2.693e-17)\n   94\t\tres[1] = 5.35e-09 (2.432e-20)\tres[2] = 1.79e-09 (3.350e-17)\n   95\t\tres[1] = 4.93e-09 (3.259e-20)\tres[2] = 1.65e-09 (2.550e-17)\n   96\t\tres[1] = 4.55e-09 (1.785e-20)\tres[2] = 1.52e-09 (3.672e-17)\n   97\t\tres[1] = 4.20e-09 (2.398e-20)\tres[2] = 1.41e-09 (2.353e-17)\n   98\t\tres[1] = 3.88e-09 (1.568e-20)\tres[2] = 1.30e-09 (2.327e-17)\n   99\t\tres[1] = 3.58e-09 (2.686e-20)\tres[2] = 1.20e-09 (2.001e-17)\n  100\t\tres[1] = 3.30e-09 (2.374e-20)\tres[2] = 1.11e-09 (2.887e-17)\n  101\t\tres[1] = 3.05e-09 (8.410e-21)\tres[2] = 1.02e-09 (2.882e-17)\n  102\t\tres[1] = 2.81e-09 (1.867e-20)\tres[2] = 9.41e-10 (2.308e-17)\n  103\t\tres[1] = 2.59e-09 (2.842e-20)\tres[2] = 8.69e-10 (4.719e-17)\n  104\t\tres[1] = 2.39e-09 (2.989e-20)\tres[2] = 8.02e-10 (1.868e-17)\n  105\t\tres[1] = 2.21e-09 (2.119e-20)\tres[2] = 7.40e-10 (2.228e-17)\n  106\t\tres[1] = 2.04e-09 (2.582e-20)\tres[2] = 6.83e-10 (2.687e-17)\n  107\t\tres[1] = 1.88e-09 (2.351e-20)\tres[2] = 6.30e-10 (3.439e-17)\n  108\t\tres[1] = 1.74e-09 (1.246e-20)\tres[2] = 5.81e-10 (2.023e-17)\n  109\t\tres[1] = 1.60e-09 (2.232e-20)\tres[2] = 5.37e-10 (2.089e-17)\n  110\t\tres[1] = 1.48e-09 (2.121e-20)\tres[2] = 4.95e-10 (2.308e-17)\n  111\t\tres[1] = 1.36e-09 (3.269e-20)\tres[2] = 4.57e-10 (2.908e-17)\n  112\t\tres[1] = 1.26e-09 (1.818e-20)\tres[2] = 4.22e-10 (2.117e-17)\n  113\t\tres[1] = 1.16e-09 (2.335e-20)\tres[2] = 3.89e-10 (3.346e-17)\n  114\t\tres[1] = 1.07e-09 (1.915e-20)\tres[2] = 3.59e-10 (2.861e-17)\n  115\t\tres[1] = 9.89e-10 (2.139e-20)\tres[2] = 3.31e-10 (3.291e-17)\n  116\t\tres[1] = 9.13e-10 (1.763e-20)\tres[2] = 3.06e-10 (3.203e-17)\n  117\t\tres[1] = 8.42e-10 (1.340e-20)\tres[2] = 2.82e-10 (1.430e-17)\n  118\t\tres[1] = 7.77e-10 (2.766e-20)\tres[2] = 2.60e-10 (2.508e-17)\n  119\t\tres[1] = 7.17e-10 (3.032e-20)\tres[2] = 2.40e-10 (3.816e-17)\n  120\t\tres[1] = 6.62e-10 (2.019e-20)\tres[2] = 2.22e-10 (2.985e-17)\n  121\t\tres[1] = 6.11e-10 (1.790e-20)\tres[2] = 2.05e-10 (4.402e-17)\n  122\t\tres[1] = 5.64e-10 (2.797e-20)\tres[2] = 1.89e-10 (2.194e-17)\n  123\t\tres[1] = 5.20e-10 (2.388e-20)\tres[2] = 1.74e-10 (3.504e-17)\n  124\t\tres[1] = 4.80e-10 (1.821e-20)\tres[2] = 1.61e-10 (4.295e-17)\n  125\t\tres[1] = 4.43e-10 (2.109e-20)\tres[2] = 1.48e-10 (2.555e-17)\n  126\t\tres[1] = 4.09e-10 (2.852e-20)\tres[2] = 1.37e-10 (2.710e-17)\n  127\t\tres[1] = 3.77e-10 (1.996e-20)\tres[2] = 1.26e-10 (2.327e-17)\n  128\t\tres[1] = 3.48e-10 (2.706e-20)\tres[2] = 1.17e-10 (2.596e-17)\n  129\t\tres[1] = 3.21e-10 (1.608e-20)\tres[2] = 1.08e-10 (3.417e-17)\n  130\t\tres[1] = 2.97e-10 (2.100e-20)\tres[2] = 9.93e-11 (2.404e-17)\n  131\t\tres[1] = 2.74e-10 (3.200e-20)\tres[2] = 9.17e-11 (3.123e-17)\n  132\t\tres[1] = 2.53e-10 (2.958e-20)\tres[2] = 8.46e-11 (2.861e-17)\n  133\t\tres[1] = 2.33e-10 (1.738e-20)\tres[2] = 7.81e-11 (3.259e-17)\n  134\t\tres[1] = 2.15e-10 (2.401e-20)\tres[2] = 7.21e-11 (3.572e-17)\n  135\t\tres[1] = 1.98e-10 (2.134e-20)\tres[2] = 6.65e-11 (2.803e-17)\n  136\t\tres[1] = 1.83e-10 (2.181e-20)\tres[2] = 6.14e-11 (2.737e-17)\n  137\t\tres[1] = 1.69e-10 (2.829e-20)\tres[2] = 5.66e-11 (3.542e-17)\n  138\t\tres[1] = 1.56e-10 (3.593e-20)\tres[2] = 5.23e-11 (3.180e-17)\n  139\t\tres[1] = 1.44e-10 (3.195e-20)\tres[2] = 4.82e-11 (3.773e-17)\n  140\t\tres[1] = 1.33e-10 (2.328e-20)\tres[2] = 4.45e-11 (1.700e-17)\n  141\t\tres[1] = 1.23e-10 (1.485e-20)\tres[2] = 4.11e-11 (3.350e-17)\n  142\t\tres[1] = 1.13e-10 (1.858e-20)\tres[2] = 3.79e-11 (2.502e-17)\n  143\t\tres[1] = 1.04e-10 (1.762e-20)\tres[2] = 3.50e-11 (3.708e-17)\n  144\t\tres[1] = 9.63e-11 (1.330e-20)\tres[2] = 3.23e-11 (2.532e-17)\n  145\t\tres[1] = 8.89e-11 (1.808e-20)\tres[2] = 2.98e-11 (2.194e-17)\n  146\t\tres[1] = 8.21e-11 (2.100e-20)\tres[2] = 2.75e-11 (2.596e-17)\n  147\t\tres[1] = 7.57e-11 (2.158e-20)\tres[2] = 2.54e-11 (2.508e-17)\n  148\t\tres[1] = 6.99e-11 (3.162e-20)\tres[2] = 2.34e-11 (2.710e-17)\n  149\t\tres[1] = 6.45e-11 (1.880e-20)\tres[2] = 2.16e-11 (2.359e-17)\n  150\t\tres[1] = 5.95e-11 (2.469e-20)\tres[2] = 1.99e-11 (3.504e-17)\n  151\t\tres[1] = 5.49e-11 (2.422e-20)\tres[2] = 1.84e-11 (3.049e-17)\n  152\t\tres[1] = 5.07e-11 (2.664e-20)\tres[2] = 1.70e-11 (3.944e-17)\n  153\t\tres[1] = 4.68e-11 (3.399e-20)\tres[2] = 1.57e-11 (4.333e-17)\n  154\t\tres[1] = 4.32e-11 (3.101e-20)\tres[2] = 1.45e-11 (2.882e-17)\n  155\t\tres[1] = 3.98e-11 (2.415e-20)\tres[2] = 1.33e-11 (3.404e-17)\n  156\t\tres[1] = 3.68e-11 (1.910e-20)\tres[2] = 1.23e-11 (4.181e-17)\n  157\t\tres[1] = 3.39e-11 (2.310e-20)\tres[2] = 1.14e-11 (2.737e-17)\n  158\t\tres[1] = 3.13e-11 (1.341e-20)\tres[2] = 1.05e-11 (1.970e-17)\n  159\t\tres[1] = 2.89e-11 (2.429e-20)\tres[2] = 9.68e-12 (2.602e-17)\n  160\t\tres[1] = 2.67e-11 (2.544e-20)\tres[2] = 8.93e-12 (3.199e-17)\n  161\t\tres[1] = 2.46e-11 (2.463e-20)\tres[2] = 8.24e-12 (2.969e-17)\n  162\t\tres[1] = 2.27e-11 (3.261e-20)\tres[2] = 7.60e-12 (3.203e-17)\n  163\t\tres[1] = 2.09e-11 (1.172e-20)\tres[2] = 7.02e-12 (1.876e-17)\n  164\t\tres[1] = 1.93e-11 (2.445e-20)\tres[2] = 6.48e-12 (3.555e-17)\n  165\t\tres[1] = 1.78e-11 (2.472e-20)\tres[2] = 5.98e-12 (1.735e-17)\n  166\t\tres[1] = 1.65e-11 (1.923e-20)\tres[2] = 5.52e-12 (1.778e-17)\n  167\t\tres[1] = 1.52e-11 (3.219e-20)\tres[2] = 5.09e-12 (2.526e-17)\n  168\t\tres[1] = 1.40e-11 (2.984e-20)\tres[2] = 4.70e-12 (3.030e-17)\n  169\t\tres[1] = 1.29e-11 (2.222e-20)\tres[2] = 4.33e-12 (2.944e-17)\n  170\t\tres[1] = 1.19e-11 (2.625e-20)\tres[2] = 4.00e-12 (3.273e-17)\n  171\t\tres[1] = 1.10e-11 (1.939e-20)\tres[2] = 3.69e-12 (3.346e-17)\n  172\t\tres[1] = 1.02e-11 (2.070e-20)\tres[2] = 3.41e-12 (3.626e-17)\n  173\t\tres[1] = 9.38e-12 (2.121e-20)\tres[2] = 3.14e-12 (3.676e-17)\n\n    ndof    |   || u - u_h ||    order | || ∇(u - u_h) ||   order |   || ϱ - ϱ_h ||    order |  || ϱu - ϱu_h ||   order |       #its         order |\n============|==========================|==========================|==========================|==========================|==========================|\n        95  |     3.176e-06      0.00  |     3.728e-05      0.00  |     8.646e-02      0.00  |     2.765e-06      0.00  |     1.730e+02      0.00  |\nxgrid = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 35 cells: 46 bfaces: 22\n\n\n    1\t\tres[1] = 2.02e-03 (4.667e-19)\tres[2] = 9.18e-05 (1.691e-17)\n    2\t\tres[1] = 1.76e-03 (1.578e-19)\tres[2] = 2.36e-05 (1.344e-17)\n    3\t\tres[1] = 3.52e-04 (1.231e-19)\tres[2] = 1.44e-05 (1.868e-17)\n    4\t\tres[1] = 1.46e-04 (1.231e-19)\tres[2] = 1.03e-05 (1.691e-17)\n    5\t\tres[1] = 9.07e-05 (8.366e-20)\tres[2] = 7.76e-06 (1.761e-17)\n    6\t\tres[1] = 6.33e-05 (6.666e-20)\tres[2] = 5.98e-06 (1.876e-17)\n    7\t\tres[1] = 4.67e-05 (7.037e-20)\tres[2] = 4.68e-06 (1.637e-17)\n    8\t\tres[1] = 3.54e-05 (3.746e-20)\tres[2] = 3.70e-06 (1.900e-17)\n    9\t\tres[1] = 2.74e-05 (4.080e-20)\tres[2] = 2.96e-06 (1.963e-17)\n   10\t\tres[1] = 2.14e-05 (4.722e-20)\tres[2] = 2.38e-06 (1.561e-17)\n   11\t\tres[1] = 1.70e-05 (2.347e-20)\tres[2] = 1.94e-06 (1.399e-17)\n   12\t\tres[1] = 1.35e-05 (2.165e-20)\tres[2] = 1.59e-06 (1.552e-17)\n   13\t\tres[1] = 1.09e-05 (3.206e-20)\tres[2] = 1.32e-06 (1.332e-17)\n   14\t\tres[1] = 8.77e-06 (1.384e-20)\tres[2] = 1.10e-06 (1.908e-17)\n   15\t\tres[1] = 7.11e-06 (1.816e-20)\tres[2] = 9.30e-07 (1.462e-17)\n   16\t\tres[1] = 5.80e-06 (1.311e-20)\tres[2] = 7.94e-07 (1.786e-17)\n   17\t\tres[1] = 4.74e-06 (1.074e-20)\tres[2] = 6.85e-07 (1.655e-17)\n   18\t\tres[1] = 3.89e-06 (1.563e-20)\tres[2] = 5.97e-07 (1.743e-17)\n   19\t\tres[1] = 3.22e-06 (1.157e-20)\tres[2] = 5.26e-07 (1.970e-17)\n   20\t\tres[1] = 2.69e-06 (8.984e-21)\tres[2] = 4.67e-07 (1.561e-17)\n   21\t\tres[1] = 2.27e-06 (9.763e-21)\tres[2] = 4.19e-07 (1.618e-17)\n   22\t\tres[1] = 1.93e-06 (1.080e-20)\tres[2] = 3.78e-07 (2.082e-17)\n   23\t\tres[1] = 1.65e-06 (1.312e-20)\tres[2] = 3.44e-07 (1.844e-17)\n   24\t\tres[1] = 1.43e-06 (1.220e-20)\tres[2] = 3.14e-07 (1.803e-17)\n   25\t\tres[1] = 1.24e-06 (8.579e-21)\tres[2] = 2.88e-07 (1.522e-17)\n   26\t\tres[1] = 1.09e-06 (8.329e-21)\tres[2] = 2.65e-07 (1.571e-17)\n   27\t\tres[1] = 9.72e-07 (8.038e-21)\tres[2] = 2.44e-07 (2.167e-17)\n   28\t\tres[1] = 8.69e-07 (8.134e-21)\tres[2] = 2.25e-07 (1.735e-17)\n   29\t\tres[1] = 7.83e-07 (8.953e-21)\tres[2] = 2.08e-07 (1.682e-17)\n   30\t\tres[1] = 7.10e-07 (1.076e-20)\tres[2] = 1.93e-07 (2.117e-17)\n   31\t\tres[1] = 6.47e-07 (7.865e-21)\tres[2] = 1.78e-07 (1.868e-17)\n   32\t\tres[1] = 5.92e-07 (1.249e-20)\tres[2] = 1.65e-07 (2.082e-17)\n   33\t\tres[1] = 5.43e-07 (9.350e-21)\tres[2] = 1.53e-07 (1.778e-17)\n   34\t\tres[1] = 5.00e-07 (5.974e-21)\tres[2] = 1.42e-07 (1.985e-17)\n   35\t\tres[1] = 4.60e-07 (8.842e-21)\tres[2] = 1.32e-07 (2.082e-17)\n   36\t\tres[1] = 4.24e-07 (9.142e-21)\tres[2] = 1.23e-07 (1.761e-17)\n   37\t\tres[1] = 3.93e-07 (1.336e-20)\tres[2] = 1.14e-07 (1.627e-17)\n   38\t\tres[1] = 3.64e-07 (8.296e-21)\tres[2] = 1.06e-07 (1.735e-17)\n   39\t\tres[1] = 3.37e-07 (1.142e-20)\tres[2] = 9.80e-08 (1.627e-17)\n   40\t\tres[1] = 3.13e-07 (8.513e-21)\tres[2] = 9.10e-08 (2.082e-17)\n   41\t\tres[1] = 2.90e-07 (6.164e-21)\tres[2] = 8.45e-08 (1.441e-17)\n   42\t\tres[1] = 2.69e-07 (1.130e-20)\tres[2] = 7.85e-08 (1.682e-17)\n   43\t\tres[1] = 2.50e-07 (9.543e-21)\tres[2] = 7.28e-08 (2.181e-17)\n   44\t\tres[1] = 2.32e-07 (1.078e-20)\tres[2] = 6.76e-08 (2.125e-17)\n   45\t\tres[1] = 2.16e-07 (1.233e-20)\tres[2] = 6.28e-08 (1.924e-17)\n   46\t\tres[1] = 2.00e-07 (8.019e-21)\tres[2] = 5.83e-08 (1.637e-17)\n   47\t\tres[1] = 1.86e-07 (1.146e-20)\tres[2] = 5.41e-08 (1.726e-17)\n   48\t\tres[1] = 1.73e-07 (7.739e-21)\tres[2] = 5.02e-08 (1.819e-17)\n   49\t\tres[1] = 1.60e-07 (7.280e-21)\tres[2] = 4.66e-08 (2.379e-17)\n   50\t\tres[1] = 1.49e-07 (1.159e-20)\tres[2] = 4.33e-08 (1.743e-17)\n   51\t\tres[1] = 1.38e-07 (1.187e-20)\tres[2] = 4.02e-08 (2.208e-17)\n   52\t\tres[1] = 1.28e-07 (1.032e-20)\tres[2] = 3.73e-08 (1.700e-17)\n   53\t\tres[1] = 1.19e-07 (1.126e-20)\tres[2] = 3.46e-08 (2.194e-17)\n   54\t\tres[1] = 1.11e-07 (6.787e-21)\tres[2] = 3.21e-08 (1.786e-17)\n   55\t\tres[1] = 1.03e-07 (1.047e-20)\tres[2] = 2.98e-08 (1.673e-17)\n   56\t\tres[1] = 9.53e-08 (7.041e-21)\tres[2] = 2.77e-08 (1.571e-17)\n   57\t\tres[1] = 8.85e-08 (9.914e-21)\tres[2] = 2.57e-08 (2.074e-17)\n   58\t\tres[1] = 8.22e-08 (1.092e-20)\tres[2] = 2.39e-08 (2.045e-17)\n   59\t\tres[1] = 7.63e-08 (1.188e-20)\tres[2] = 2.21e-08 (1.682e-17)\n   60\t\tres[1] = 7.08e-08 (9.233e-21)\tres[2] = 2.06e-08 (1.860e-17)\n   61\t\tres[1] = 6.57e-08 (1.053e-20)\tres[2] = 1.91e-08 (2.023e-17)\n   62\t\tres[1] = 6.10e-08 (1.408e-20)\tres[2] = 1.77e-08 (1.884e-17)\n   63\t\tres[1] = 5.67e-08 (1.130e-20)\tres[2] = 1.64e-08 (1.512e-17)\n   64\t\tres[1] = 5.26e-08 (7.382e-21)\tres[2] = 1.53e-08 (2.416e-17)\n   65\t\tres[1] = 4.88e-08 (1.007e-20)\tres[2] = 1.42e-08 (1.618e-17)\n   66\t\tres[1] = 4.53e-08 (1.050e-20)\tres[2] = 1.31e-08 (2.053e-17)\n   67\t\tres[1] = 4.21e-08 (1.032e-20)\tres[2] = 1.22e-08 (1.828e-17)\n   68\t\tres[1] = 3.91e-08 (9.966e-21)\tres[2] = 1.13e-08 (1.978e-17)\n   69\t\tres[1] = 3.63e-08 (7.803e-21)\tres[2] = 1.05e-08 (1.263e-17)\n   70\t\tres[1] = 3.37e-08 (1.075e-20)\tres[2] = 9.76e-09 (2.366e-17)\n   71\t\tres[1] = 3.13e-08 (7.167e-21)\tres[2] = 9.06e-09 (1.673e-17)\n   72\t\tres[1] = 2.91e-08 (1.336e-20)\tres[2] = 8.41e-09 (1.939e-17)\n   73\t\tres[1] = 2.70e-08 (1.293e-20)\tres[2] = 7.81e-09 (1.786e-17)\n   74\t\tres[1] = 2.51e-08 (7.327e-21)\tres[2] = 7.25e-09 (2.228e-17)\n   75\t\tres[1] = 2.34e-08 (1.934e-20)\tres[2] = 6.74e-09 (1.947e-17)\n   76\t\tres[1] = 2.17e-08 (7.886e-21)\tres[2] = 6.26e-09 (1.955e-17)\n   77\t\tres[1] = 2.01e-08 (8.463e-21)\tres[2] = 5.81e-09 (2.347e-17)\n   78\t\tres[1] = 1.87e-08 (8.846e-21)\tres[2] = 5.40e-09 (2.132e-17)\n   79\t\tres[1] = 1.74e-08 (8.993e-21)\tres[2] = 5.01e-09 (2.422e-17)\n   80\t\tres[1] = 1.61e-08 (1.096e-20)\tres[2] = 4.65e-09 (1.717e-17)\n   81\t\tres[1] = 1.50e-08 (1.492e-20)\tres[2] = 4.32e-09 (1.227e-17)\n   82\t\tres[1] = 1.39e-08 (9.650e-21)\tres[2] = 4.01e-09 (1.955e-17)\n   83\t\tres[1] = 1.29e-08 (1.239e-20)\tres[2] = 3.73e-09 (1.860e-17)\n   84\t\tres[1] = 1.20e-08 (1.071e-20)\tres[2] = 3.46e-09 (1.876e-17)\n   85\t\tres[1] = 1.11e-08 (9.553e-21)\tres[2] = 3.21e-09 (2.308e-17)\n   86\t\tres[1] = 1.03e-08 (8.527e-21)\tres[2] = 2.98e-09 (1.691e-17)\n   87\t\tres[1] = 9.60e-09 (9.444e-21)\tres[2] = 2.77e-09 (2.089e-17)\n   88\t\tres[1] = 8.92e-09 (7.766e-21)\tres[2] = 2.57e-09 (2.096e-17)\n   89\t\tres[1] = 8.28e-09 (1.524e-20)\tres[2] = 2.39e-09 (2.089e-17)\n   90\t\tres[1] = 7.69e-09 (9.307e-21)\tres[2] = 2.22e-09 (2.074e-17)\n   91\t\tres[1] = 7.14e-09 (1.087e-20)\tres[2] = 2.06e-09 (2.096e-17)\n   92\t\tres[1] = 6.63e-09 (5.635e-21)\tres[2] = 1.91e-09 (1.761e-17)\n   93\t\tres[1] = 6.16e-09 (1.445e-20)\tres[2] = 1.78e-09 (1.963e-17)\n   94\t\tres[1] = 5.72e-09 (7.971e-21)\tres[2] = 1.65e-09 (1.778e-17)\n   95\t\tres[1] = 5.31e-09 (7.635e-21)\tres[2] = 1.53e-09 (2.125e-17)\n   96\t\tres[1] = 4.93e-09 (7.005e-21)\tres[2] = 1.42e-09 (1.580e-17)\n   97\t\tres[1] = 4.58e-09 (9.548e-21)\tres[2] = 1.32e-09 (1.512e-17)\n   98\t\tres[1] = 4.25e-09 (1.143e-20)\tres[2] = 1.23e-09 (1.819e-17)\n   99\t\tres[1] = 3.95e-09 (1.276e-20)\tres[2] = 1.14e-09 (2.404e-17)\n  100\t\tres[1] = 3.67e-09 (8.117e-21)\tres[2] = 1.06e-09 (1.963e-17)\n  101\t\tres[1] = 3.41e-09 (9.663e-21)\tres[2] = 9.83e-10 (1.627e-17)\n  102\t\tres[1] = 3.16e-09 (6.706e-21)\tres[2] = 9.13e-10 (1.819e-17)\n  103\t\tres[1] = 2.94e-09 (1.131e-20)\tres[2] = 8.48e-10 (1.828e-17)\n  104\t\tres[1] = 2.73e-09 (9.136e-21)\tres[2] = 7.87e-10 (2.340e-17)\n  105\t\tres[1] = 2.53e-09 (7.777e-21)\tres[2] = 7.31e-10 (1.970e-17)\n  106\t\tres[1] = 2.35e-09 (8.056e-21)\tres[2] = 6.79e-10 (1.512e-17)\n  107\t\tres[1] = 2.19e-09 (1.158e-20)\tres[2] = 6.30e-10 (1.892e-17)\n  108\t\tres[1] = 2.03e-09 (8.436e-21)\tres[2] = 5.85e-10 (2.053e-17)\n  109\t\tres[1] = 1.88e-09 (7.405e-21)\tres[2] = 5.44e-10 (2.228e-17)\n  110\t\tres[1] = 1.75e-09 (1.046e-20)\tres[2] = 5.05e-10 (2.466e-17)\n  111\t\tres[1] = 1.62e-09 (1.162e-20)\tres[2] = 4.69e-10 (1.655e-17)\n  112\t\tres[1] = 1.51e-09 (8.215e-21)\tres[2] = 4.35e-10 (1.609e-17)\n  113\t\tres[1] = 1.40e-09 (1.110e-20)\tres[2] = 4.04e-10 (1.908e-17)\n  114\t\tres[1] = 1.30e-09 (9.805e-21)\tres[2] = 3.75e-10 (1.868e-17)\n  115\t\tres[1] = 1.21e-09 (8.600e-21)\tres[2] = 3.49e-10 (1.673e-17)\n  116\t\tres[1] = 1.12e-09 (1.195e-20)\tres[2] = 3.24e-10 (2.201e-17)\n  117\t\tres[1] = 1.04e-09 (1.008e-20)\tres[2] = 3.01e-10 (2.030e-17)\n  118\t\tres[1] = 9.68e-10 (8.715e-21)\tres[2] = 2.79e-10 (2.008e-17)\n  119\t\tres[1] = 8.99e-10 (1.085e-20)\tres[2] = 2.59e-10 (1.691e-17)\n  120\t\tres[1] = 8.34e-10 (9.510e-21)\tres[2] = 2.41e-10 (1.955e-17)\n  121\t\tres[1] = 7.75e-10 (7.895e-21)\tres[2] = 2.24e-10 (1.482e-17)\n  122\t\tres[1] = 7.20e-10 (9.458e-21)\tres[2] = 2.08e-10 (2.248e-17)\n  123\t\tres[1] = 6.68e-10 (1.208e-20)\tres[2] = 1.93e-10 (2.074e-17)\n  124\t\tres[1] = 6.21e-10 (1.088e-20)\tres[2] = 1.79e-10 (1.803e-17)\n  125\t\tres[1] = 5.76e-10 (6.848e-21)\tres[2] = 1.66e-10 (1.786e-17)\n  126\t\tres[1] = 5.35e-10 (1.068e-20)\tres[2] = 1.54e-10 (2.060e-17)\n  127\t\tres[1] = 4.97e-10 (7.548e-21)\tres[2] = 1.43e-10 (2.275e-17)\n  128\t\tres[1] = 4.61e-10 (1.209e-20)\tres[2] = 1.33e-10 (1.803e-17)\n  129\t\tres[1] = 4.29e-10 (7.481e-21)\tres[2] = 1.24e-10 (1.735e-17)\n  130\t\tres[1] = 3.98e-10 (7.219e-21)\tres[2] = 1.15e-10 (1.752e-17)\n  131\t\tres[1] = 3.70e-10 (1.075e-20)\tres[2] = 1.07e-10 (1.735e-17)\n  132\t\tres[1] = 3.43e-10 (8.287e-21)\tres[2] = 9.90e-11 (1.700e-17)\n  133\t\tres[1] = 3.19e-10 (7.984e-21)\tres[2] = 9.19e-11 (1.900e-17)\n  134\t\tres[1] = 2.96e-10 (5.859e-21)\tres[2] = 8.54e-11 (1.794e-17)\n  135\t\tres[1] = 2.75e-10 (8.170e-21)\tres[2] = 7.93e-11 (1.803e-17)\n  136\t\tres[1] = 2.55e-10 (1.250e-20)\tres[2] = 7.36e-11 (1.682e-17)\n  137\t\tres[1] = 2.37e-10 (8.653e-21)\tres[2] = 6.84e-11 (1.955e-17)\n  138\t\tres[1] = 2.20e-10 (1.132e-20)\tres[2] = 6.35e-11 (2.103e-17)\n  139\t\tres[1] = 2.04e-10 (1.054e-20)\tres[2] = 5.90e-11 (1.828e-17)\n  140\t\tres[1] = 1.90e-10 (8.938e-21)\tres[2] = 5.48e-11 (1.580e-17)\n  141\t\tres[1] = 1.76e-10 (1.061e-20)\tres[2] = 5.08e-11 (2.023e-17)\n  142\t\tres[1] = 1.64e-10 (9.221e-21)\tres[2] = 4.72e-11 (1.769e-17)\n  143\t\tres[1] = 1.52e-10 (6.579e-21)\tres[2] = 4.38e-11 (1.769e-17)\n  144\t\tres[1] = 1.41e-10 (1.059e-20)\tres[2] = 4.07e-11 (1.868e-17)\n  145\t\tres[1] = 1.31e-10 (1.065e-20)\tres[2] = 3.78e-11 (1.664e-17)\n  146\t\tres[1] = 1.22e-10 (8.866e-21)\tres[2] = 3.51e-11 (2.125e-17)\n  147\t\tres[1] = 1.13e-10 (8.396e-21)\tres[2] = 3.26e-11 (1.803e-17)\n  148\t\tres[1] = 1.05e-10 (9.700e-21)\tres[2] = 3.03e-11 (1.532e-17)\n  149\t\tres[1] = 9.74e-11 (9.196e-21)\tres[2] = 2.81e-11 (1.451e-17)\n  150\t\tres[1] = 9.05e-11 (1.083e-20)\tres[2] = 2.61e-11 (1.618e-17)\n  151\t\tres[1] = 8.40e-11 (1.123e-20)\tres[2] = 2.42e-11 (1.561e-17)\n  152\t\tres[1] = 7.80e-11 (7.817e-21)\tres[2] = 2.25e-11 (2.082e-17)\n  153\t\tres[1] = 7.25e-11 (9.169e-21)\tres[2] = 2.09e-11 (1.844e-17)\n  154\t\tres[1] = 6.73e-11 (6.858e-21)\tres[2] = 1.94e-11 (1.388e-17)\n  155\t\tres[1] = 6.25e-11 (8.393e-21)\tres[2] = 1.80e-11 (1.561e-17)\n  156\t\tres[1] = 5.80e-11 (7.602e-21)\tres[2] = 1.67e-11 (1.388e-17)\n  157\t\tres[1] = 5.39e-11 (8.796e-21)\tres[2] = 1.55e-11 (1.947e-17)\n  158\t\tres[1] = 5.00e-11 (9.172e-21)\tres[2] = 1.44e-11 (1.932e-17)\n  159\t\tres[1] = 4.65e-11 (1.049e-20)\tres[2] = 1.34e-11 (1.985e-17)\n  160\t\tres[1] = 4.32e-11 (8.646e-21)\tres[2] = 1.25e-11 (2.082e-17)\n  161\t\tres[1] = 4.01e-11 (1.149e-20)\tres[2] = 1.16e-11 (1.811e-17)\n  162\t\tres[1] = 3.72e-11 (9.776e-21)\tres[2] = 1.07e-11 (2.067e-17)\n  163\t\tres[1] = 3.46e-11 (1.315e-20)\tres[2] = 9.97e-12 (1.811e-17)\n  164\t\tres[1] = 3.21e-11 (7.116e-21)\tres[2] = 9.26e-12 (1.908e-17)\n  165\t\tres[1] = 2.98e-11 (1.609e-20)\tres[2] = 8.60e-12 (1.778e-17)\n  166\t\tres[1] = 2.77e-11 (8.544e-21)\tres[2] = 7.98e-12 (2.441e-17)\n  167\t\tres[1] = 2.57e-11 (1.001e-20)\tres[2] = 7.41e-12 (1.778e-17)\n  168\t\tres[1] = 2.39e-11 (1.021e-20)\tres[2] = 6.88e-12 (2.067e-17)\n  169\t\tres[1] = 2.22e-11 (1.082e-20)\tres[2] = 6.39e-12 (1.571e-17)\n  170\t\tres[1] = 2.06e-11 (9.223e-21)\tres[2] = 5.94e-12 (2.248e-17)\n  171\t\tres[1] = 1.91e-11 (1.049e-20)\tres[2] = 5.51e-12 (1.892e-17)\n  172\t\tres[1] = 1.77e-11 (1.191e-20)\tres[2] = 5.12e-12 (1.884e-17)\n  173\t\tres[1] = 1.65e-11 (1.431e-20)\tres[2] = 4.75e-12 (1.441e-17)\n  174\t\tres[1] = 1.53e-11 (1.120e-20)\tres[2] = 4.42e-12 (2.181e-17)\n  175\t\tres[1] = 1.42e-11 (8.267e-21)\tres[2] = 4.10e-12 (1.700e-17)\n  176\t\tres[1] = 1.32e-11 (1.315e-20)\tres[2] = 3.81e-12 (1.451e-17)\n  177\t\tres[1] = 1.23e-11 (7.509e-21)\tres[2] = 3.54e-12 (2.030e-17)\n  178\t\tres[1] = 1.14e-11 (7.450e-21)\tres[2] = 3.28e-12 (1.743e-17)\n  179\t\tres[1] = 1.06e-11 (1.295e-20)\tres[2] = 3.05e-12 (1.844e-17)\n  180\t\tres[1] = 9.81e-12 (1.176e-20)\tres[2] = 2.83e-12 (1.691e-17)\n\n    ndof    |   || u - u_h ||    order | || ∇(u - u_h) ||   order |   || ϱ - ϱ_h ||    order |  || ϱu - ϱu_h ||   order |       #its         order |\n============|==========================|==========================|==========================|==========================|==========================|\n        95  |     3.176e-06      0.00  |     3.728e-05      0.00  |     8.646e-02      0.00  |     2.765e-06      0.00  |     1.730e+02      0.00  |\n       242  |     6.733e-07      3.32  |     1.118e-05      2.57  |     4.606e-02      1.35  |     6.842e-07      2.99  |     1.800e+02      -0.08  |\nxgrid = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 115 cells: 183 bfaces: 45\n\n\n    1\t\tres[1] = 4.87e-04 (2.128e-19)\tres[2] = 1.39e-05 (9.097e-18)\n    2\t\tres[1] = 4.23e-04 (5.039e-20)\tres[2] = 2.93e-06 (8.877e-18)\n    3\t\tres[1] = 1.03e-04 (3.377e-20)\tres[2] = 1.19e-06 (1.059e-17)\n    4\t\tres[1] = 3.41e-05 (1.990e-20)\tres[2] = 6.45e-07 (8.972e-18)\n    5\t\tres[1] = 1.48e-05 (1.877e-20)\tres[2] = 4.56e-07 (1.024e-17)\n    6\t\tres[1] = 7.59e-06 (1.551e-20)\tres[2] = 3.61e-07 (9.087e-18)\n    7\t\tres[1] = 4.56e-06 (1.294e-20)\tres[2] = 3.06e-07 (8.674e-18)\n    8\t\tres[1] = 3.08e-06 (1.203e-20)\tres[2] = 2.67e-07 (9.452e-18)\n    9\t\tres[1] = 2.28e-06 (1.043e-20)\tres[2] = 2.37e-07 (8.619e-18)\n   10\t\tres[1] = 1.81e-06 (1.026e-20)\tres[2] = 2.12e-07 (8.877e-18)\n   11\t\tres[1] = 1.50e-06 (9.234e-21)\tres[2] = 1.91e-07 (9.755e-18)\n   12\t\tres[1] = 1.28e-06 (7.544e-21)\tres[2] = 1.73e-07 (9.688e-18)\n   13\t\tres[1] = 1.11e-06 (7.984e-21)\tres[2] = 1.57e-07 (8.941e-18)\n   14\t\tres[1] = 9.70e-07 (6.638e-21)\tres[2] = 1.43e-07 (8.856e-18)\n   15\t\tres[1] = 8.57e-07 (6.953e-21)\tres[2] = 1.30e-07 (8.972e-18)\n   16\t\tres[1] = 7.61e-07 (5.825e-21)\tres[2] = 1.19e-07 (8.113e-18)\n   17\t\tres[1] = 6.78e-07 (5.884e-21)\tres[2] = 1.09e-07 (9.832e-18)\n   18\t\tres[1] = 6.07e-07 (6.618e-21)\tres[2] = 9.96e-08 (8.898e-18)\n   19\t\tres[1] = 5.46e-07 (5.411e-21)\tres[2] = 9.14e-08 (1.018e-17)\n   20\t\tres[1] = 4.92e-07 (5.219e-21)\tres[2] = 8.40e-08 (9.889e-18)\n   21\t\tres[1] = 4.45e-07 (3.933e-21)\tres[2] = 7.73e-08 (9.492e-18)\n   22\t\tres[1] = 4.03e-07 (4.114e-21)\tres[2] = 7.12e-08 (1.009e-17)\n   23\t\tres[1] = 3.66e-07 (4.326e-21)\tres[2] = 6.56e-08 (9.372e-18)\n   24\t\tres[1] = 3.33e-07 (3.298e-21)\tres[2] = 6.05e-08 (1.056e-17)\n   25\t\tres[1] = 3.04e-07 (3.392e-21)\tres[2] = 5.58e-08 (9.332e-18)\n   26\t\tres[1] = 2.78e-07 (3.035e-21)\tres[2] = 5.15e-08 (8.674e-18)\n   27\t\tres[1] = 2.54e-07 (3.447e-21)\tres[2] = 4.76e-08 (8.113e-18)\n   28\t\tres[1] = 2.33e-07 (3.887e-21)\tres[2] = 4.40e-08 (1.063e-17)\n   29\t\tres[1] = 2.14e-07 (2.787e-21)\tres[2] = 4.07e-08 (9.382e-18)\n   30\t\tres[1] = 1.96e-07 (2.921e-21)\tres[2] = 3.76e-08 (9.482e-18)\n   31\t\tres[1] = 1.81e-07 (3.038e-21)\tres[2] = 3.48e-08 (9.056e-18)\n   32\t\tres[1] = 1.66e-07 (2.766e-21)\tres[2] = 3.22e-08 (8.532e-18)\n   33\t\tres[1] = 1.53e-07 (2.830e-21)\tres[2] = 2.98e-08 (9.889e-18)\n   34\t\tres[1] = 1.41e-07 (2.643e-21)\tres[2] = 2.76e-08 (1.018e-17)\n   35\t\tres[1] = 1.30e-07 (2.402e-21)\tres[2] = 2.56e-08 (9.521e-18)\n   36\t\tres[1] = 1.20e-07 (2.212e-21)\tres[2] = 2.37e-08 (1.021e-17)\n   37\t\tres[1] = 1.11e-07 (2.198e-21)\tres[2] = 2.19e-08 (1.004e-17)\n   38\t\tres[1] = 1.02e-07 (2.208e-21)\tres[2] = 2.03e-08 (1.040e-17)\n   39\t\tres[1] = 9.45e-08 (2.789e-21)\tres[2] = 1.88e-08 (8.308e-18)\n   40\t\tres[1] = 8.73e-08 (2.259e-21)\tres[2] = 1.74e-08 (9.342e-18)\n   41\t\tres[1] = 8.07e-08 (2.500e-21)\tres[2] = 1.61e-08 (9.322e-18)\n   42\t\tres[1] = 7.46e-08 (2.284e-21)\tres[2] = 1.49e-08 (9.045e-18)\n   43\t\tres[1] = 6.90e-08 (2.508e-21)\tres[2] = 1.38e-08 (1.047e-17)\n   44\t\tres[1] = 6.38e-08 (2.104e-21)\tres[2] = 1.28e-08 (9.452e-18)\n   45\t\tres[1] = 5.90e-08 (2.601e-21)\tres[2] = 1.18e-08 (9.442e-18)\n   46\t\tres[1] = 5.45e-08 (2.254e-21)\tres[2] = 1.10e-08 (9.541e-18)\n   47\t\tres[1] = 5.04e-08 (2.480e-21)\tres[2] = 1.02e-08 (9.918e-18)\n   48\t\tres[1] = 4.66e-08 (2.469e-21)\tres[2] = 9.40e-09 (9.803e-18)\n   49\t\tres[1] = 4.31e-08 (2.475e-21)\tres[2] = 8.70e-09 (9.870e-18)\n   50\t\tres[1] = 3.97e-08 (2.083e-21)\tres[2] = 8.05e-09 (9.803e-18)\n   51\t\tres[1] = 3.66e-08 (2.474e-21)\tres[2] = 7.45e-09 (9.045e-18)\n   52\t\tres[1] = 3.38e-08 (2.433e-21)\tres[2] = 6.90e-09 (9.870e-18)\n   53\t\tres[1] = 3.13e-08 (2.377e-21)\tres[2] = 6.39e-09 (9.736e-18)\n   54\t\tres[1] = 2.89e-08 (2.425e-21)\tres[2] = 5.91e-09 (1.000e-17)\n   55\t\tres[1] = 2.68e-08 (2.045e-21)\tres[2] = 5.47e-09 (1.069e-17)\n   56\t\tres[1] = 2.48e-08 (2.314e-21)\tres[2] = 5.07e-09 (7.830e-18)\n   57\t\tres[1] = 2.29e-08 (2.509e-21)\tres[2] = 4.69e-09 (8.044e-18)\n   58\t\tres[1] = 2.12e-08 (2.894e-21)\tres[2] = 4.34e-09 (9.736e-18)\n   59\t\tres[1] = 1.96e-08 (2.493e-21)\tres[2] = 4.02e-09 (8.771e-18)\n   60\t\tres[1] = 1.81e-08 (2.321e-21)\tres[2] = 3.72e-09 (9.551e-18)\n   61\t\tres[1] = 1.67e-08 (2.534e-21)\tres[2] = 3.44e-09 (9.003e-18)\n   62\t\tres[1] = 1.55e-08 (2.698e-21)\tres[2] = 3.18e-09 (1.004e-17)\n   63\t\tres[1] = 1.43e-08 (2.310e-21)\tres[2] = 2.95e-09 (8.509e-18)\n   64\t\tres[1] = 1.33e-08 (2.106e-21)\tres[2] = 2.73e-09 (9.707e-18)\n   65\t\tres[1] = 1.23e-08 (2.392e-21)\tres[2] = 2.52e-09 (9.842e-18)\n   66\t\tres[1] = 1.14e-08 (2.282e-21)\tres[2] = 2.34e-09 (8.993e-18)\n   67\t\tres[1] = 1.06e-08 (2.016e-21)\tres[2] = 2.16e-09 (9.251e-18)\n   68\t\tres[1] = 9.78e-09 (2.439e-21)\tres[2] = 2.00e-09 (9.975e-18)\n   69\t\tres[1] = 9.05e-09 (2.347e-21)\tres[2] = 1.85e-09 (9.880e-18)\n   70\t\tres[1] = 8.38e-09 (2.132e-21)\tres[2] = 1.71e-09 (1.007e-17)\n   71\t\tres[1] = 7.75e-09 (2.500e-21)\tres[2] = 1.59e-09 (9.056e-18)\n   72\t\tres[1] = 7.17e-09 (2.369e-21)\tres[2] = 1.47e-09 (1.043e-17)\n   73\t\tres[1] = 6.63e-09 (2.269e-21)\tres[2] = 1.36e-09 (9.993e-18)\n   74\t\tres[1] = 6.14e-09 (1.856e-21)\tres[2] = 1.26e-09 (9.241e-18)\n   75\t\tres[1] = 5.68e-09 (1.933e-21)\tres[2] = 1.16e-09 (1.016e-17)\n   76\t\tres[1] = 5.25e-09 (2.246e-21)\tres[2] = 1.08e-09 (1.070e-17)\n   77\t\tres[1] = 4.86e-09 (2.163e-21)\tres[2] = 9.98e-10 (9.472e-18)\n   78\t\tres[1] = 4.50e-09 (2.173e-21)\tres[2] = 9.23e-10 (1.054e-17)\n   79\t\tres[1] = 4.16e-09 (2.326e-21)\tres[2] = 8.54e-10 (9.659e-18)\n   80\t\tres[1] = 3.85e-09 (2.266e-21)\tres[2] = 7.91e-10 (1.010e-17)\n   81\t\tres[1] = 3.56e-09 (2.594e-21)\tres[2] = 7.32e-10 (9.097e-18)\n   82\t\tres[1] = 3.30e-09 (2.517e-21)\tres[2] = 6.77e-10 (1.030e-17)\n   83\t\tres[1] = 3.05e-09 (2.152e-21)\tres[2] = 6.27e-10 (9.965e-18)\n   84\t\tres[1] = 2.82e-09 (2.359e-21)\tres[2] = 5.80e-10 (1.046e-17)\n   85\t\tres[1] = 2.61e-09 (2.334e-21)\tres[2] = 5.37e-10 (9.717e-18)\n   86\t\tres[1] = 2.42e-09 (2.156e-21)\tres[2] = 4.97e-10 (1.034e-17)\n   87\t\tres[1] = 2.24e-09 (2.581e-21)\tres[2] = 4.60e-10 (1.016e-17)\n   88\t\tres[1] = 2.07e-09 (2.023e-21)\tres[2] = 4.26e-10 (9.220e-18)\n   89\t\tres[1] = 1.92e-09 (2.245e-21)\tres[2] = 3.94e-10 (1.095e-17)\n   90\t\tres[1] = 1.77e-09 (2.540e-21)\tres[2] = 3.65e-10 (9.927e-18)\n   91\t\tres[1] = 1.64e-09 (2.004e-21)\tres[2] = 3.38e-10 (9.492e-18)\n   92\t\tres[1] = 1.52e-09 (2.362e-21)\tres[2] = 3.13e-10 (9.392e-18)\n   93\t\tres[1] = 1.41e-09 (2.557e-21)\tres[2] = 2.89e-10 (9.432e-18)\n   94\t\tres[1] = 1.30e-09 (2.860e-21)\tres[2] = 2.68e-10 (1.026e-17)\n   95\t\tres[1] = 1.20e-09 (2.167e-21)\tres[2] = 2.48e-10 (8.930e-18)\n   96\t\tres[1] = 1.12e-09 (2.501e-21)\tres[2] = 2.29e-10 (8.781e-18)\n   97\t\tres[1] = 1.03e-09 (2.359e-21)\tres[2] = 2.12e-10 (8.909e-18)\n   98\t\tres[1] = 9.55e-10 (2.087e-21)\tres[2] = 1.96e-10 (9.261e-18)\n   99\t\tres[1] = 8.84e-10 (2.277e-21)\tres[2] = 1.82e-10 (9.580e-18)\n  100\t\tres[1] = 8.18e-10 (2.322e-21)\tres[2] = 1.68e-10 (9.261e-18)\n  101\t\tres[1] = 7.57e-10 (2.044e-21)\tres[2] = 1.56e-10 (9.138e-18)\n  102\t\tres[1] = 7.01e-10 (1.959e-21)\tres[2] = 1.44e-10 (9.571e-18)\n  103\t\tres[1] = 6.49e-10 (2.080e-21)\tres[2] = 1.33e-10 (8.217e-18)\n  104\t\tres[1] = 6.00e-10 (1.973e-21)\tres[2] = 1.23e-10 (9.462e-18)\n  105\t\tres[1] = 5.56e-10 (2.173e-21)\tres[2] = 1.14e-10 (9.600e-18)\n  106\t\tres[1] = 5.14e-10 (2.033e-21)\tres[2] = 1.06e-10 (8.749e-18)\n  107\t\tres[1] = 4.76e-10 (2.052e-21)\tres[2] = 9.79e-11 (9.066e-18)\n  108\t\tres[1] = 4.41e-10 (2.273e-21)\tres[2] = 9.06e-11 (9.261e-18)\n  109\t\tres[1] = 4.08e-10 (2.383e-21)\tres[2] = 8.39e-11 (8.728e-18)\n  110\t\tres[1] = 3.77e-10 (1.939e-21)\tres[2] = 7.76e-11 (1.005e-17)\n  111\t\tres[1] = 3.49e-10 (2.517e-21)\tres[2] = 7.19e-11 (8.909e-18)\n  112\t\tres[1] = 3.23e-10 (2.337e-21)\tres[2] = 6.65e-11 (8.684e-18)\n  113\t\tres[1] = 2.99e-10 (2.059e-21)\tres[2] = 6.16e-11 (1.076e-17)\n  114\t\tres[1] = 2.77e-10 (2.470e-21)\tres[2] = 5.70e-11 (8.813e-18)\n  115\t\tres[1] = 2.56e-10 (2.523e-21)\tres[2] = 5.27e-11 (9.678e-18)\n  116\t\tres[1] = 2.37e-10 (2.016e-21)\tres[2] = 4.88e-11 (9.803e-18)\n  117\t\tres[1] = 2.20e-10 (2.128e-21)\tres[2] = 4.52e-11 (9.851e-18)\n  118\t\tres[1] = 2.03e-10 (2.394e-21)\tres[2] = 4.18e-11 (9.717e-18)\n  119\t\tres[1] = 1.88e-10 (1.951e-21)\tres[2] = 3.87e-11 (8.749e-18)\n  120\t\tres[1] = 1.74e-10 (1.955e-21)\tres[2] = 3.58e-11 (9.322e-18)\n  121\t\tres[1] = 1.61e-10 (2.200e-21)\tres[2] = 3.31e-11 (1.035e-17)\n  122\t\tres[1] = 1.49e-10 (2.299e-21)\tres[2] = 3.07e-11 (8.674e-18)\n  123\t\tres[1] = 1.38e-10 (2.125e-21)\tres[2] = 2.84e-11 (1.039e-17)\n  124\t\tres[1] = 1.28e-10 (1.973e-21)\tres[2] = 2.63e-11 (9.432e-18)\n  125\t\tres[1] = 1.18e-10 (2.505e-21)\tres[2] = 2.43e-11 (1.053e-17)\n  126\t\tres[1] = 1.09e-10 (2.227e-21)\tres[2] = 2.25e-11 (9.014e-18)\n  127\t\tres[1] = 1.01e-10 (2.033e-21)\tres[2] = 2.08e-11 (9.946e-18)\n  128\t\tres[1] = 9.37e-11 (2.324e-21)\tres[2] = 1.93e-11 (9.291e-18)\n  129\t\tres[1] = 8.67e-11 (2.444e-21)\tres[2] = 1.79e-11 (9.342e-18)\n  130\t\tres[1] = 8.02e-11 (2.283e-21)\tres[2] = 1.65e-11 (9.462e-18)\n  131\t\tres[1] = 7.42e-11 (2.180e-21)\tres[2] = 1.53e-11 (1.039e-17)\n  132\t\tres[1] = 6.87e-11 (1.915e-21)\tres[2] = 1.42e-11 (9.014e-18)\n  133\t\tres[1] = 6.36e-11 (2.389e-21)\tres[2] = 1.31e-11 (9.190e-18)\n  134\t\tres[1] = 5.89e-11 (2.055e-21)\tres[2] = 1.21e-11 (8.888e-18)\n  135\t\tres[1] = 5.45e-11 (1.998e-21)\tres[2] = 1.12e-11 (9.851e-18)\n  136\t\tres[1] = 5.04e-11 (2.065e-21)\tres[2] = 1.04e-11 (1.007e-17)\n  137\t\tres[1] = 4.67e-11 (2.302e-21)\tres[2] = 9.61e-12 (8.983e-18)\n  138\t\tres[1] = 4.32e-11 (2.339e-21)\tres[2] = 8.89e-12 (1.020e-17)\n  139\t\tres[1] = 4.00e-11 (2.088e-21)\tres[2] = 8.23e-12 (9.580e-18)\n  140\t\tres[1] = 3.70e-11 (2.253e-21)\tres[2] = 7.62e-12 (9.521e-18)\n  141\t\tres[1] = 3.42e-11 (2.104e-21)\tres[2] = 7.05e-12 (9.823e-18)\n  142\t\tres[1] = 3.17e-11 (2.016e-21)\tres[2] = 6.53e-12 (9.880e-18)\n  143\t\tres[1] = 2.93e-11 (2.168e-21)\tres[2] = 6.04e-12 (1.023e-17)\n  144\t\tres[1] = 2.72e-11 (2.416e-21)\tres[2] = 5.59e-12 (9.678e-18)\n  145\t\tres[1] = 2.51e-11 (2.381e-21)\tres[2] = 5.17e-12 (9.392e-18)\n  146\t\tres[1] = 2.33e-11 (2.343e-21)\tres[2] = 4.79e-12 (8.781e-18)\n  147\t\tres[1] = 2.15e-11 (2.327e-21)\tres[2] = 4.43e-12 (8.520e-18)\n  148\t\tres[1] = 1.99e-11 (2.030e-21)\tres[2] = 4.10e-12 (8.263e-18)\n  149\t\tres[1] = 1.84e-11 (2.449e-21)\tres[2] = 3.80e-12 (1.038e-17)\n  150\t\tres[1] = 1.71e-11 (2.213e-21)\tres[2] = 3.51e-12 (9.580e-18)\n  151\t\tres[1] = 1.58e-11 (1.999e-21)\tres[2] = 3.25e-12 (1.032e-17)\n  152\t\tres[1] = 1.46e-11 (2.338e-21)\tres[2] = 3.01e-12 (1.007e-17)\n  153\t\tres[1] = 1.35e-11 (2.353e-21)\tres[2] = 2.79e-12 (9.035e-18)\n  154\t\tres[1] = 1.25e-11 (2.179e-21)\tres[2] = 2.58e-12 (1.001e-17)\n  155\t\tres[1] = 1.16e-11 (2.074e-21)\tres[2] = 2.39e-12 (1.030e-17)\n  156\t\tres[1] = 1.07e-11 (2.064e-21)\tres[2] = 2.21e-12 (9.755e-18)\n  157\t\tres[1] = 9.93e-12 (2.081e-21)\tres[2] = 2.04e-12 (9.492e-18)\n\n    ndof    |   || u - u_h ||    order | || ∇(u - u_h) ||   order |   || ϱ - ϱ_h ||    order |  || ϱu - ϱu_h ||   order |       #its         order |\n============|==========================|==========================|==========================|==========================|==========================|\n        95  |     3.176e-06      0.00  |     3.728e-05      0.00  |     8.646e-02      0.00  |     2.765e-06      0.00  |     1.730e+02      0.00  |\n       242  |     6.733e-07      3.32  |     1.118e-05      2.57  |     4.606e-02      1.35  |     6.842e-07      2.99  |     1.800e+02      -0.08  |\n       893  |     1.384e-07      2.42  |     2.447e-06      2.33  |     2.276e-02      1.08  |     1.391e-07      2.44  |     1.570e+02      0.21  |\nxgrid = ExtendableGrid{Float64, Int32};\ndim: 2 nodes: 395 cells: 707 bfaces: 81\n\n\n    1\t\tres[1] = 1.39e-04 (6.461e-20)\tres[2] = 2.05e-06 (4.498e-18)\n    2\t\tres[1] = 1.31e-04 (2.828e-20)\tres[2] = 4.63e-07 (4.339e-18)\n    3\t\tres[1] = 3.08e-05 (1.889e-20)\tres[2] = 2.03e-07 (4.663e-18)\n    4\t\tres[1] = 1.03e-05 (1.471e-20)\tres[2] = 1.16e-07 (4.493e-18)\n    5\t\tres[1] = 4.23e-06 (1.192e-20)\tres[2] = 8.98e-08 (4.730e-18)\n    6\t\tres[1] = 2.05e-06 (1.010e-20)\tres[2] = 7.09e-08 (4.606e-18)\n    7\t\tres[1] = 1.14e-06 (8.263e-21)\tres[2] = 5.98e-08 (4.643e-18)\n    8\t\tres[1] = 7.69e-07 (6.698e-21)\tres[2] = 5.03e-08 (4.478e-18)\n    9\t\tres[1] = 5.70e-07 (5.898e-21)\tres[2] = 4.30e-08 (4.605e-18)\n   10\t\tres[1] = 4.56e-07 (4.985e-21)\tres[2] = 3.69e-08 (4.554e-18)\n   11\t\tres[1] = 3.74e-07 (4.044e-21)\tres[2] = 3.19e-08 (4.500e-18)\n   12\t\tres[1] = 3.12e-07 (3.882e-21)\tres[2] = 2.77e-08 (4.480e-18)\n   13\t\tres[1] = 2.64e-07 (3.609e-21)\tres[2] = 2.42e-08 (4.402e-18)\n   14\t\tres[1] = 2.24e-07 (2.781e-21)\tres[2] = 2.13e-08 (4.553e-18)\n   15\t\tres[1] = 1.93e-07 (2.606e-21)\tres[2] = 1.88e-08 (4.715e-18)\n   16\t\tres[1] = 1.66e-07 (2.623e-21)\tres[2] = 1.67e-08 (4.529e-18)\n   17\t\tres[1] = 1.45e-07 (2.183e-21)\tres[2] = 1.48e-08 (4.577e-18)\n   18\t\tres[1] = 1.27e-07 (1.967e-21)\tres[2] = 1.32e-08 (4.609e-18)\n   19\t\tres[1] = 1.11e-07 (2.065e-21)\tres[2] = 1.19e-08 (4.535e-18)\n   20\t\tres[1] = 9.79e-08 (1.777e-21)\tres[2] = 1.07e-08 (4.720e-18)\n   21\t\tres[1] = 8.65e-08 (1.505e-21)\tres[2] = 9.64e-09 (4.903e-18)\n   22\t\tres[1] = 7.66e-08 (1.516e-21)\tres[2] = 8.72e-09 (4.705e-18)\n   23\t\tres[1] = 6.81e-08 (1.310e-21)\tres[2] = 7.90e-09 (4.802e-18)\n   24\t\tres[1] = 6.07e-08 (1.257e-21)\tres[2] = 7.18e-09 (4.656e-18)\n   25\t\tres[1] = 5.43e-08 (1.288e-21)\tres[2] = 6.54e-09 (4.609e-18)\n   26\t\tres[1] = 4.86e-08 (1.218e-21)\tres[2] = 5.97e-09 (4.563e-18)\n   27\t\tres[1] = 4.37e-08 (1.053e-21)\tres[2] = 5.46e-09 (4.512e-18)\n   28\t\tres[1] = 3.93e-08 (9.633e-22)\tres[2] = 4.99e-09 (4.943e-18)\n   29\t\tres[1] = 3.54e-08 (9.175e-22)\tres[2] = 4.58e-09 (4.713e-18)\n   30\t\tres[1] = 3.20e-08 (9.547e-22)\tres[2] = 4.20e-09 (4.687e-18)\n   31\t\tres[1] = 2.90e-08 (8.626e-22)\tres[2] = 3.86e-09 (4.652e-18)\n   32\t\tres[1] = 2.62e-08 (8.212e-22)\tres[2] = 3.55e-09 (4.754e-18)\n   33\t\tres[1] = 2.38e-08 (7.901e-22)\tres[2] = 3.26e-09 (4.432e-18)\n   34\t\tres[1] = 2.17e-08 (8.027e-22)\tres[2] = 3.01e-09 (4.907e-18)\n   35\t\tres[1] = 1.97e-08 (7.490e-22)\tres[2] = 2.77e-09 (4.792e-18)\n   36\t\tres[1] = 1.80e-08 (7.262e-22)\tres[2] = 2.55e-09 (4.630e-18)\n   37\t\tres[1] = 1.64e-08 (7.629e-22)\tres[2] = 2.36e-09 (4.834e-18)\n   38\t\tres[1] = 1.50e-08 (6.727e-22)\tres[2] = 2.18e-09 (4.785e-18)\n   39\t\tres[1] = 1.37e-08 (6.718e-22)\tres[2] = 2.01e-09 (4.884e-18)\n   40\t\tres[1] = 1.26e-08 (6.344e-22)\tres[2] = 1.86e-09 (4.803e-18)\n   41\t\tres[1] = 1.15e-08 (6.459e-22)\tres[2] = 1.71e-09 (4.708e-18)\n   42\t\tres[1] = 1.06e-08 (6.050e-22)\tres[2] = 1.58e-09 (4.664e-18)\n   43\t\tres[1] = 9.70e-09 (6.183e-22)\tres[2] = 1.46e-09 (4.573e-18)\n   44\t\tres[1] = 8.92e-09 (6.319e-22)\tres[2] = 1.35e-09 (4.475e-18)\n   45\t\tres[1] = 8.20e-09 (5.829e-22)\tres[2] = 1.25e-09 (4.953e-18)\n   46\t\tres[1] = 7.55e-09 (5.468e-22)\tres[2] = 1.16e-09 (4.648e-18)\n   47\t\tres[1] = 6.96e-09 (6.160e-22)\tres[2] = 1.07e-09 (4.688e-18)\n   48\t\tres[1] = 6.41e-09 (5.800e-22)\tres[2] = 9.92e-10 (4.617e-18)\n   49\t\tres[1] = 5.92e-09 (5.284e-22)\tres[2] = 9.17e-10 (4.430e-18)\n   50\t\tres[1] = 5.46e-09 (5.744e-22)\tres[2] = 8.49e-10 (4.840e-18)\n   51\t\tres[1] = 5.04e-09 (5.470e-22)\tres[2] = 7.86e-10 (4.898e-18)\n   52\t\tres[1] = 4.65e-09 (5.683e-22)\tres[2] = 7.27e-10 (4.768e-18)\n   53\t\tres[1] = 4.29e-09 (5.479e-22)\tres[2] = 6.73e-10 (4.636e-18)\n   54\t\tres[1] = 3.97e-09 (5.342e-22)\tres[2] = 6.23e-10 (4.717e-18)\n   55\t\tres[1] = 3.66e-09 (5.767e-22)\tres[2] = 5.77e-10 (4.754e-18)\n   56\t\tres[1] = 3.38e-09 (5.737e-22)\tres[2] = 5.34e-10 (4.739e-18)\n   57\t\tres[1] = 3.13e-09 (5.488e-22)\tres[2] = 4.94e-10 (5.152e-18)\n   58\t\tres[1] = 2.89e-09 (5.797e-22)\tres[2] = 4.57e-10 (4.909e-18)\n   59\t\tres[1] = 2.67e-09 (5.201e-22)\tres[2] = 4.23e-10 (4.763e-18)\n   60\t\tres[1] = 2.47e-09 (5.615e-22)\tres[2] = 3.92e-10 (5.118e-18)\n   61\t\tres[1] = 2.28e-09 (5.760e-22)\tres[2] = 3.63e-10 (4.581e-18)\n   62\t\tres[1] = 2.11e-09 (5.315e-22)\tres[2] = 3.36e-10 (4.970e-18)\n   63\t\tres[1] = 1.95e-09 (5.672e-22)\tres[2] = 3.11e-10 (4.794e-18)\n   64\t\tres[1] = 1.80e-09 (5.888e-22)\tres[2] = 2.88e-10 (4.578e-18)\n   65\t\tres[1] = 1.67e-09 (6.386e-22)\tres[2] = 2.66e-10 (4.720e-18)\n   66\t\tres[1] = 1.54e-09 (5.564e-22)\tres[2] = 2.47e-10 (4.801e-18)\n   67\t\tres[1] = 1.43e-09 (5.758e-22)\tres[2] = 2.28e-10 (5.012e-18)\n   68\t\tres[1] = 1.33e-09 (5.587e-22)\tres[2] = 2.11e-10 (5.210e-18)\n   69\t\tres[1] = 1.23e-09 (5.609e-22)\tres[2] = 1.96e-10 (4.779e-18)\n   70\t\tres[1] = 1.14e-09 (5.712e-22)\tres[2] = 1.81e-10 (5.065e-18)\n   71\t\tres[1] = 1.05e-09 (5.653e-22)\tres[2] = 1.68e-10 (4.927e-18)\n   72\t\tres[1] = 9.73e-10 (5.576e-22)\tres[2] = 1.55e-10 (4.521e-18)\n   73\t\tres[1] = 9.00e-10 (5.665e-22)\tres[2] = 1.44e-10 (4.814e-18)\n   74\t\tres[1] = 8.33e-10 (5.290e-22)\tres[2] = 1.33e-10 (4.554e-18)\n   75\t\tres[1] = 7.72e-10 (5.680e-22)\tres[2] = 1.23e-10 (5.062e-18)\n   76\t\tres[1] = 7.14e-10 (5.122e-22)\tres[2] = 1.14e-10 (4.685e-18)\n   77\t\tres[1] = 6.61e-10 (5.536e-22)\tres[2] = 1.05e-10 (4.937e-18)\n   78\t\tres[1] = 6.11e-10 (5.566e-22)\tres[2] = 9.76e-11 (4.906e-18)\n   79\t\tres[1] = 5.66e-10 (5.620e-22)\tres[2] = 9.03e-11 (5.009e-18)\n   80\t\tres[1] = 5.24e-10 (5.354e-22)\tres[2] = 8.36e-11 (4.969e-18)\n   81\t\tres[1] = 4.85e-10 (5.607e-22)\tres[2] = 7.74e-11 (4.673e-18)\n   82\t\tres[1] = 4.49e-10 (5.484e-22)\tres[2] = 7.17e-11 (4.655e-18)\n   83\t\tres[1] = 4.15e-10 (5.189e-22)\tres[2] = 6.63e-11 (4.823e-18)\n   84\t\tres[1] = 3.84e-10 (5.206e-22)\tres[2] = 6.14e-11 (5.040e-18)\n   85\t\tres[1] = 3.55e-10 (5.562e-22)\tres[2] = 5.68e-11 (4.596e-18)\n   86\t\tres[1] = 3.28e-10 (5.616e-22)\tres[2] = 5.26e-11 (4.855e-18)\n   87\t\tres[1] = 3.04e-10 (5.591e-22)\tres[2] = 4.87e-11 (4.866e-18)\n   88\t\tres[1] = 2.81e-10 (5.520e-22)\tres[2] = 4.51e-11 (4.839e-18)\n   89\t\tres[1] = 2.61e-10 (5.310e-22)\tres[2] = 4.17e-11 (4.898e-18)\n   90\t\tres[1] = 2.41e-10 (5.609e-22)\tres[2] = 3.86e-11 (4.729e-18)\n   91\t\tres[1] = 2.23e-10 (5.572e-22)\tres[2] = 3.58e-11 (4.830e-18)\n   92\t\tres[1] = 2.07e-10 (5.957e-22)\tres[2] = 3.31e-11 (5.209e-18)\n   93\t\tres[1] = 1.91e-10 (5.689e-22)\tres[2] = 3.06e-11 (5.023e-18)\n   94\t\tres[1] = 1.77e-10 (5.859e-22)\tres[2] = 2.84e-11 (4.528e-18)\n   95\t\tres[1] = 1.64e-10 (5.698e-22)\tres[2] = 2.63e-11 (4.528e-18)\n   96\t\tres[1] = 1.52e-10 (5.161e-22)\tres[2] = 2.43e-11 (4.898e-18)\n   97\t\tres[1] = 1.40e-10 (5.324e-22)\tres[2] = 2.25e-11 (4.847e-18)\n   98\t\tres[1] = 1.30e-10 (5.632e-22)\tres[2] = 2.08e-11 (4.880e-18)\n   99\t\tres[1] = 1.20e-10 (5.318e-22)\tres[2] = 1.93e-11 (5.022e-18)\n  100\t\tres[1] = 1.11e-10 (5.419e-22)\tres[2] = 1.78e-11 (4.731e-18)\n  101\t\tres[1] = 1.03e-10 (5.539e-22)\tres[2] = 1.65e-11 (4.779e-18)\n  102\t\tres[1] = 9.54e-11 (5.360e-22)\tres[2] = 1.53e-11 (5.023e-18)\n  103\t\tres[1] = 8.82e-11 (5.605e-22)\tres[2] = 1.42e-11 (4.380e-18)\n  104\t\tres[1] = 8.17e-11 (5.765e-22)\tres[2] = 1.31e-11 (5.340e-18)\n  105\t\tres[1] = 7.56e-11 (5.601e-22)\tres[2] = 1.21e-11 (4.927e-18)\n  106\t\tres[1] = 7.00e-11 (5.544e-22)\tres[2] = 1.12e-11 (4.781e-18)\n  107\t\tres[1] = 6.48e-11 (5.529e-22)\tres[2] = 1.04e-11 (4.970e-18)\n  108\t\tres[1] = 6.00e-11 (5.656e-22)\tres[2] = 9.62e-12 (4.879e-18)\n  109\t\tres[1] = 5.55e-11 (5.526e-22)\tres[2] = 8.90e-12 (4.688e-18)\n  110\t\tres[1] = 5.14e-11 (5.721e-22)\tres[2] = 8.24e-12 (5.066e-18)\n  111\t\tres[1] = 4.76e-11 (6.176e-22)\tres[2] = 7.63e-12 (4.964e-18)\n  112\t\tres[1] = 4.40e-11 (5.514e-22)\tres[2] = 7.06e-12 (5.025e-18)\n  113\t\tres[1] = 4.07e-11 (5.290e-22)\tres[2] = 6.54e-12 (4.833e-18)\n  114\t\tres[1] = 3.77e-11 (5.601e-22)\tres[2] = 6.05e-12 (4.947e-18)\n  115\t\tres[1] = 3.49e-11 (5.555e-22)\tres[2] = 5.60e-12 (5.059e-18)\n  116\t\tres[1] = 3.23e-11 (5.767e-22)\tres[2] = 5.19e-12 (4.695e-18)\n  117\t\tres[1] = 2.99e-11 (5.321e-22)\tres[2] = 4.80e-12 (4.851e-18)\n  118\t\tres[1] = 2.77e-11 (5.543e-22)\tres[2] = 4.44e-12 (4.499e-18)\n  119\t\tres[1] = 2.56e-11 (5.419e-22)\tres[2] = 4.11e-12 (4.861e-18)\n  120\t\tres[1] = 2.37e-11 (5.742e-22)\tres[2] = 3.81e-12 (4.982e-18)\n  121\t\tres[1] = 2.20e-11 (5.781e-22)\tres[2] = 3.52e-12 (4.990e-18)\n  122\t\tres[1] = 2.03e-11 (5.610e-22)\tres[2] = 3.26e-12 (4.680e-18)\n  123\t\tres[1] = 1.88e-11 (5.356e-22)\tres[2] = 3.02e-12 (4.925e-18)\n  124\t\tres[1] = 1.74e-11 (5.258e-22)\tres[2] = 2.80e-12 (4.505e-18)\n  125\t\tres[1] = 1.61e-11 (5.370e-22)\tres[2] = 2.59e-12 (5.006e-18)\n  126\t\tres[1] = 1.49e-11 (5.518e-22)\tres[2] = 2.40e-12 (4.913e-18)\n  127\t\tres[1] = 1.38e-11 (5.318e-22)\tres[2] = 2.22e-12 (4.626e-18)\n  128\t\tres[1] = 1.28e-11 (5.861e-22)\tres[2] = 2.05e-12 (5.058e-18)\n  129\t\tres[1] = 1.18e-11 (5.466e-22)\tres[2] = 1.90e-12 (4.781e-18)\n  130\t\tres[1] = 1.09e-11 (5.701e-22)\tres[2] = 1.76e-12 (4.659e-18)\n  131\t\tres[1] = 1.01e-11 (5.516e-22)\tres[2] = 1.63e-12 (4.841e-18)\n  132\t\tres[1] = 9.37e-12 (5.593e-22)\tres[2] = 1.51e-12 (5.035e-18)\n\n    ndof    |   || u - u_h ||    order | || ∇(u - u_h) ||   order |   || ϱ - ϱ_h ||    order |  || ϱu - ϱu_h ||   order |       #its         order |\n============|==========================|==========================|==========================|==========================|==========================|\n        95  |     3.176e-06      0.00  |     3.728e-05      0.00  |     8.646e-02      0.00  |     2.765e-06      0.00  |     1.730e+02      0.00  |\n       242  |     6.733e-07      3.32  |     1.118e-05      2.57  |     4.606e-02      1.35  |     6.842e-07      2.99  |     1.800e+02      -0.08  |\n       893  |     1.384e-07      2.42  |     2.447e-06      2.33  |     2.276e-02      1.08  |     1.391e-07      2.44  |     1.570e+02      0.21  |\n      3305  |     2.168e-08      2.83  |     4.214e-07      2.69  |     1.204e-02      0.97  |     2.003e-08      2.96  |     1.320e+02      0.27  |","category":"page"},{"location":"examples/Example280_CompressibleStokes/","page":"280 : Compressible Stokes","title":"280 : Compressible Stokes","text":"(Image: )","category":"page"},{"location":"itemintegrators/#Item-Integrators","page":"Item Integrators","title":"Item Integrators","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Item integrators compute certain quantities of the Solution, like a posteriori errors estimators, norms, drag/lift coefficients or other statistics.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegrator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegrator","text":"function ItemIntegrator(\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs). If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegrator{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegrator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example202_MixedPoissonProblem/#:-Poisson-Problem-(Mixed)","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"","category":"section"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"(source code)","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"This example computes the solution u and its stress mathbfsigma = - mu nabla u of the two-dimensional Poisson problem in the mixed form","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"beginaligned\nmathbfsigma + mu nabla u = 0\nmathrmdiv mathbfsigma  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"module Example202_MixedPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# bilinearform kernel for mixed Poisson problem\nfunction blf!(result, u_ops, qpinfo)\n\tσ, divσ, u = view(u_ops, 1:2), view(u_ops, 3), view(u_ops, 4)\n\tμ = qpinfo.params[1]\n\tresult[1] = σ[1] / μ\n\tresult[2] = σ[2] / μ\n\tresult[3] = -u[1]\n\tresult[4] = divσ[1]\n\treturn nothing\nend\n# right-hand side data\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2]\n\treturn nothing\nend\n# boundary data\nfunction boundarydata!(result, qpinfo)\n\tresult[1] = 0\n\treturn nothing\nend\n\nfunction main(; nrefs = 5, μ = 0.25, Plotter = nothing, hdivdg = false, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tσ = Unknown(\"σ\"; name = \"pseudostress\")\n\tu = Unknown(\"u\"; name = \"potential\")\n\tp = Unknown(\"p\"; name = \"LM hdiv continuity\") # only_used if hdivdg == true\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, σ)\n\tif hdivdg\n\t\tassign_unknown!(PD, p)\n\t\tassign_operator!(PD, BilinearOperator([jump(normalflux(σ))], [id(p)]; transposed_copy = 1, entities = ON_IFACES, kwargs...))\n\t\tassign_operator!(PD, HomogeneousData(p; regions = 1:4))\n\tend\n\tassign_operator!(PD, BilinearOperator(blf!, [id(σ), div(σ), id(u)]; params = [μ], kwargs...))\n\tassign_operator!(PD, LinearOperator(boundarydata!, [normalflux(σ)]; entities = ON_BFACES, regions = 1:4, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, FixDofs(u; dofs = [1], vals = [0]))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\tFES = Dict(u => FESpace{L2P0{1}}(xgrid),\n\t\tσ => FESpace{HDIVRT0{2}}(xgrid; broken = hdivdg),\n\t\tp => hdivdg ? FESpace{L2P0{1}, ON_FACES}(xgrid) : nothing)\n\n\t# solve\n\tsol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n\t# plot\n\tplot([id(u), id(σ)], sol; Plotter = Plotter)\nend\n\nend # module","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"Default output:","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"julia> Example202_MixedPoissonProblem.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.62\n END\t---------\t8.011e-13\t0.02\t0.05\t0.07\t\t3.12\t17.57\t20.69\n\tfinished\t\t\t\tSUM -->\t0.06\t\t\tSUM -->\t21.31\n","category":"page"},{"location":"examples/Example202_MixedPoissonProblem/","page":"202 : Poisson-Problem (Mixed)","title":"202 : Poisson-Problem (Mixed)","text":"(Image: )","category":"page"},{"location":"bilinearoperator/#BilinearOperator","page":"BilinearOperator","title":"BilinearOperator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the ground finite element space (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces. For all other discontinuous operator evaluations there is the possibility to use BilinerOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.","category":"page"},{"location":"bilinearoperator/#Constructors","page":"BilinearOperator","title":"Constructors","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-2","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tA::AbstractMatrix,\n\tu_test,\n\tu_ansatz = u_test;\n\tkwargs...)\n\nGenerates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments utest and uansatz specify where to put the (blocks of the) matrix in the system.\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#DG-BilinearForms","page":"BilinearOperator","title":"DG BilinearForms","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions.","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.\n\nKeyword arguments:\n\nlump: lump the operator (= only assemble the diagonal). Default: false\nfactor: factor that should be multiplied during assembly. Default: 1\ncallback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperatorDG''\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#Examples","page":"BilinearOperator","title":"Examples","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Below two examples illustrate some use cases.","category":"page"},{"location":"bilinearoperator/#Example-Stokes-operator","page":"BilinearOperator","title":"Example - Stokes operator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"For the linear operator of a Stokes problem a kernel could look like","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"μ = 0.1 # viscosity parameter\nfunction kernel!(result, input, qpinfo)\n    ∇u, p = view(input,1:4), view(input, 5)\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the coressponding BilinearOperator constructor call reads","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\np = Unknown(\"p\"; name = \"pressure\")\nBilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since input[5] does not couple with result[5].","category":"page"},{"location":"bilinearoperator/#Example-interior-penalty-stabilization","page":"BilinearOperator","title":"Example - interior penalty stabilization","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"function stab_kernel!(result, input, qpinfo)\n    result .= input .* qpinfo.volume^2\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the BilinearOperatorDG constructor call","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\")\nassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))","category":"page"},{"location":"combinedofs/#CombineDofs","page":"CombineDofs","title":"CombineDofs","text":"","category":"section"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/combinedofs.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"combinedofs/#ExtendableFEM.CombineDofs","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, dofsX, dofsY, factors; kwargs...)\n\nWhen assembled, the dofsX of the unknown uX will be coupled with the dofsY of uY, e.g., for periodic boundary conditions.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\n\n\n\n\n\n","category":"type"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"The following function might be useful to find out the dofs the need to be coupled for periodic boundary conditions:","category":"page"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"get_periodic_coupling_info","category":"page"},{"location":"combinedofs/#ExtendableFEM.get_periodic_coupling_info","page":"CombineDofs","title":"ExtendableFEM.get_periodic_coupling_info","text":"function get_periodic_coupling_info(FES, xgrid, b1, b2, is_opposite::Function; factor_vectordofs = \"auto\")\n\ncomputes the dofs that have to be coupled for periodic boundary conditions on the given xgrid for boundary regions b1, b2. The isopposite function evaluates if two provided face midpoints are on opposite sides to each other (the mesh xgrid should be appropriate). For vector-valued FETypes the user can provide factorvectordofs to incorporate a sign change if needed. This is automatically done for all Hdiv-conforming elements and (for the normal-weighted face bubbles of) the Bernardi-Raugel element H1BR. \n\n\n\n\n\n","category":"function"},{"location":"examples/Example285_CahnHilliard/#:-Cahn-Hilliard-Equations","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"","category":"section"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"(source code)","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"This example studies the mixed form of the Cahn-Hilliard equations that seeks (cmu) such that","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"beginaligned\nc_t - mathbfdiv (M nabla mu)  = 0\nmu - partial f  partial c + lambda nabla^2c  = 0\nendaligned","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"with f(c) = 100c^2(1-c)^2, constant parameters M and lambda and (random) initial concentration as defined in the code below.","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"module Example285_CahnHilliard\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing ForwardDiff\n\n# parameters and initial condition\nconst f = (c) -> 100 * c^2 * (1 - c)^2\nconst dfdc = (c) -> ForwardDiff.derivative(f, c)\n\nfunction c0!(result, qpinfo)\n\tresult[1] = 0.63 + 0.02 * (0.5 - rand())\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\torder = 1,                              # finite element order for c and μ\n\tnref = 5,                               # refinement level\n\tM = 1.0,\n\tλ = 1e-2,\n    iterations_until_next_plot = 20,\n\tτ = 5 / 1000000,                        # time step (for main evolution phase)\n    τ_increase = 1.1,                      # increase factor for τ after each plot\n\tPlotter = nothing,                      # Plotter (e.g. PyPlot)\n\tkwargs...,\n)\n\n\t# initial grid and final time\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [1, 1]), nref)\n\n\t# define unknowns\n\tc = Unknown(\"c\"; name = \"concentration\", dim = 1)\n\tμ = Unknown(\"μ\"; name = \"chemical potential\", dim = 1)\n\n\t# define main level set problem\n\tPD = ProblemDescription(\"Cahn-Hilliard equation\")\n\tassign_unknown!(PD, c)\n\tassign_unknown!(PD, μ)\n\tassign_operator!(PD, BilinearOperator([grad(c)], [grad(μ)]; factor = M, store = true))\n\tassign_operator!(PD, BilinearOperator([id(μ)]; store = true))\n\tassign_operator!(PD, BilinearOperator([grad(μ)], [grad(c)]; factor = -λ, store = true))\n\n\t# add nonlinear reaction part (= -df/dc times test function)\n\tfunction kernel_dfdc!(result, input, qpinfo)\n\t\tresult[1] = -dfdc(input[1])\n\tend\n\tassign_operator!(PD, NonlinearOperator(kernel_dfdc!, [id(μ)], [id(c)]; bonus_quadorder = 1))\n\n\t# generate FESpace and solution vector and interpolate initial state\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tsol = FEVector([FES, FES]; tags = PD.unknowns)\n\tinterpolate!(sol[c], c0!)\n\n\t# init plot (if order > 1, solution is upscaled to finer grid for plotting)\n\tp = GridVisualizer(; Plotter = Plotter, layout = (7, 3), clear = true, resolution = (900, 2100))\n\tif order > 1\n\t\txgrid_upscale = uniform_refine(xgrid, order - 1)\n\t\tSolutionUpscaled = FEVector(FESpace{H1P1{1}}(xgrid_upscale))\n\t\tlazy_interpolate!(SolutionUpscaled[1], sol)\n\telse\n\t\txgrid_upscale = xgrid\n\t\tSolutionUpscaled = sol\n\tend\n\tnodevals = nodevalues_view(SolutionUpscaled[1])\n\tscalarplot!(p[1, 1], xgrid_upscale, nodevals[1]; limits = (0.61, 0.65), xlabel = \"\", ylabel = \"\", levels = 1, title = \"c (t = 0)\")\n\n\t# prepare backward Euler time derivative\n\tM = FEMatrix(FES)\n\tb = FEVector(FES)\n\tassemble!(M, BilinearOperator([id(1)]; factor = 1.0 / τ))\n\tassign_operator!(PD, BilinearOperator(M, [c]; kwargs...))\n\tassign_operator!(PD, LinearOperator(b, [c]; kwargs...))\n\n\t# generate solver configuration\n\tSC = SolverConfiguration(PD, [FES, FES]; init = sol, maxiterations = 50, target_residual = 1e-6, kwargs...)\n\n\t# advance in time, plot from time to time\n\tt = 0\n\tfor j ∈ 1:20\n\t\t# do some timesteps until next plot\n\t\tfor it ∈ 1:iterations_until_next_plot\n\t\t\tt += τ\n\t\t\t# update time derivative\n\t\t\tb.entries .= M.entries * view(sol[c])\n\t\t\tExtendableFEM.solve(PD, [FES, FES], SC; time = t)\n\t\tend\n\n\t\t# enlarge time step a little bit\n\t\tτ *= τ_increase\n\t\tM.entries.cscmatrix.nzval ./= τ_increase\n\n        # plot at current time\n\t\tif order > 1\n\t\t\tlazy_interpolate!(SolutionUpscaled[1], sol)\n\t\tend\n\t\tscalarplot!(p[1+Int(floor((j) / 3)), 1+(j)%3], xgrid_upscale, nodevals[1]; xlabel = \"\", ylabel = \"\", limits = (-0.1, 1.1), levels = 1, title = \"c (t = $(Float32(t)))\")\n\tend\nend\nend","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example285_CahnHilliard/","page":"285 : Cahn-Hilliard Equations","title":"285 : Cahn-Hilliard Equations","text":"(Image: )","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/#:-Axisymmetric-Stokes","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"","category":"section"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"(source code)","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"This example solves the 3D stagnation point flow via the 2.5D axisymmetric formulation of the Navier–Stokes problem that seeks a velocity mathbfu = (u_z u_r) and pressure p such that","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"beginaligned\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z - r^-2 right) u_r\n+ (u_r partial_r + u_z partial_z) u_r + partial_r p  = mathbff_r\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z right) u_z\n+ (u_r partial_r + u_z partial_z) u_z + partial_z p  = mathbff_z\n(partial_r + r^-1)u_r + partial_z u_z  = 0\nendaligned","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"with exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"The axisymmetric formulation assumes that the velocity in some 3D-domain, that is obtained by rotation of a 2D domain Omega, only depends on the distance r to the rotation axis and the z-coordinate tangential to the x-axis, but not on the angular coordinate of the cylindric coordinates. The implementation employs r-dependent bilinear forms and a Cartesian grid for the 2D (zr) domain that is assumed to be rotated around the r=0-axis.","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"This leads to the weak formulation","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"beginaligned\na(uv) + b(pv)  = (fv) \n         b(qu)  = 0\nendaligned","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"with the bilinear forms","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"beginaligned\na(uv) = int_Omega left( nabla u  nabla v + r^-2 u_r v_r right) r dr dz\nb(qv) = int_Omega q left( mathrmdiv(v) + r^-1 u_r right) r dr dz\nendaligned","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"where the usual Cartesian differential operators can be used. The factor 2pi from the integral over the rotation angle drops out on both sides.","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"module Example260_AxisymmetricNavierStokesProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n\nfunction kernel_convection!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input, 3:6)\n    r = qpinfo.x[1]\n    result[1] = r*(∇u[1]*u[1] + ∇u[2]*u[2])\n    result[2] = r*(∇u[3]*u[1] + ∇u[4]*u[2])\n    return nothing\nend\n\nfunction kernel_stokes_axisymmetric!(result, u_ops, qpinfo)\n    u, ∇u, p = view(u_ops,1:2), view(u_ops,3:6), view(u_ops, 7)\n    r = qpinfo.x[1]\n    μ = qpinfo.params[1]\n    # add Laplacian\n    result[1] = μ/r * u[1] - p[1]\n    result[2] = 0\n    result[3] = μ*r * ∇u[1] - r*p[1]\n    result[4] = μ*r * ∇u[2]\n    result[5] = μ*r * ∇u[3]\n    result[6] = μ*r * ∇u[4] - r*p[1]\n    result[7] = -(r*(∇u[1]+∇u[4]) + u[1])\n    return nothing\nend\n\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[1]\n    result[2] = -2*x[2]\nend\n\nfunction kernel_l2div(result, u_ops, qpinfo)\n    u, divu = view(u_ops,1:2), view(u_ops,3)\n    result[1] = (qpinfo.x[1]*divu[1] + u[1])^2\nend\n\n\nfunction main(; μ = 0.1, nrefs = 4, nonlinear = false, uniform = false, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_axisymmetric!, [id(u),grad(u),id(p)]; params = [μ], kwargs...))#; jacobian = kernel_jacobian!))\n    if nonlinear\n        assign_operator!(PD, NonlinearOperator(kernel_convection!, [id(u)], [id(u),grad(u)]; bonus_quadorder = 1, kwargs...))#; jacobian = kernel_jacobian!))\n    end\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:2))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [4], mask = (1,0,1)))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = (0,1,1)))\n    @show PD\n\n    # grid\n    if uniform\n        xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    else\n        xgrid = simplexgrid(Triangulate;\n        points=[0 0 ; 1 0 ; 1 1 ; 0 1]',\n        bfaces=[1 2 ; 2 3 ; 3 4 ; 4 1 ]',\n        bfaceregions=[1, 2, 3, 4],\n        regionpoints=[0.5 0.5;]',\n        regionnumbers=[1],\n        regionvolumes=[4.0^(-nrefs-1)])\n    end\n\n    # solve\n    FES = [FESpace{H1P2{2,2}}(xgrid), FESpace{H1P1{1}}(xgrid)]\n    sol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n    # compute divergence in cylindrical coordinates by volume integrals\n    DivIntegrator = ItemIntegrator(kernel_l2div, [id(u), div(u)]; quadorder = 2, resultdim = 1)\n    @info \"||div(u)|| = $(sqrt(sum(evaluate(DivIntegrator, sol))))\"\n\n    # plot\n    plot([id(u)], sol; Plotter = Plotter)\nend\n\nend # module","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"Default output:","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"julia> Example260_AxisymmetricNavierStokesProblem.main()\nPD = \nPDE-DESCRIPTION\n    • name = My problem\n\n  <<<UNKNOWNS>>>\n    • u (name = velocity)    • p (name = pressure)\n  <<<OPERATORS>>>\n    • BilinearOperator([:u, :p], [\"X(u)\", \"X(p)\"]; entities = ON_CELLS)\n    • BoundaryData(u)\n    • HomogeneousData(u, regions = [4])\n    • HomogeneousData(u, regions = [1])\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.37\n END\t---------\t5.438e-13\t0.20\t0.06\t0.26\t\t7.57\t32.73\t40.31\n\tfinished\t\t\t\tSUM -->\t0.26\t\t\tSUM -->\t40.67\n","category":"page"},{"location":"examples/Example260_AxisymmetricNavierStokesProblem/","page":"260 : Axisymmetric Stokes","title":"260 : Axisymmetric Stokes","text":"(Image: )","category":"page"},{"location":"problemdescription/#Problem-Description","page":"Problem Description","title":"Problem Description","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Central object is the ProblemDescription which is given as a weak form of your problem and usually does not need any information on the discretisation at this point (but of course can depend on region numbers).","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"ProblemDescription","category":"page"},{"location":"problemdescription/#ExtendableFEM.ProblemDescription","page":"Problem Description","title":"ExtendableFEM.ProblemDescription","text":"struct ProblemDescription\n\nStructure holding data for a problem description with the following fields:\n\nname::String: The name of the problem used for printout messages. Default: \"My Problem\"\n\nunknowns::Vector{Unknown}: A vector of Unknowns that are involved in the problem.\n\noperators::Vector{AbstractOperator}: A vector of operators that are involved in the problem.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#Constructors-and-assign-functions","page":"Problem Description","title":"Constructors and assign functions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"problemdescription.jl\"]\nOrder   = [:function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.assign_operator!-Tuple{ProblemDescription, AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.assign_operator!","text":"assign_operator!(PD::ProblemDescription, o::AbstractOperator)\n\nAssigns the AbstractOperator o to the ProblemDescription PD and returns its position in the operators array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.assign_unknown!-Tuple{ProblemDescription, Unknown}","page":"Problem Description","title":"ExtendableFEM.assign_unknown!","text":"assign_unknown!(PD::ProblemDescription, u::Unknown)\n\nAssigns the Unknown u to the ProblemDescription PD and returns its position in the unknowns array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.replace_operator!-Tuple{ProblemDescription, Any, AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.replace_operator!","text":"replace_operator!(PD::ProblemDescription, j::Int, o::AbstractOperator)\n\nReplaces the j-th operator of the ProblemDescription PD by the new operator o. Here, j is the position in operator array returned by the assign_operator! function. Nothing is returned (as the new operator gets position j).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Unknowns","page":"Problem Description","title":"Unknowns","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"An Unknown is an identifies that encodes a physical quantity in the ProblemDescription.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"unknowns.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Unknown","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"struct Unknown\n\nStructure holding information for an unknwon with the following fields:\n\nname::String: The name of the unknown used for printout messages.\n\nidentifier::Any: The identifier of the unknown used for assignments to operators.\n\nparameters::Dict{Symbol, Any}: Further properties of the unknown can be stored in a Dict, see constructor.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Unknown-Tuple{String}","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"function Unknown(\n\tu::String;\n\tidentifier = Symbol(u),\n\tname = u,\n\tkwargs...)\n\nGenerates and returns an Unknown with the specified name, identifier and other traits.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nalgebraic_constraint: is this unknown an algebraic constraint?. Default: nothing\nsymbol_ansatz: symbol for ansatz functions of this unknown in printouts. Default: nothing\nsymbol_test: symbol for test functions of this unknown in printouts. Default: nothing\ndimension: dimension of the unknown. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Operators","page":"Problem Description","title":"Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Operator is a quite general concept and is everything that makes modifications to the system matrix, hence classical represenations of weak discretisations of differential operators, penalisations for boundary conditions or global constraints, or stabilisation terms.","category":"page"},{"location":"problemdescription/#Types-of-operators","page":"Problem Description","title":"Types of operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The three most important operator classes are:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"NonlinearOperator (e.g. the convection term in a Navier-Stokes problem)\nBilinearOperator (e.g. the Laplacian in a Poisson problem)\nLinearOperator (e.g. the right-hand side in a Poisson or Navier-Stokes problem)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"To assing boundary conditions or global constraints there are three possibilities:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"InterpolateBoundaryData\nHomogeneousData\nFixDofs\nCombineDofs","category":"page"},{"location":"problemdescription/#Entities-and-Regions","page":"Problem Description","title":"Entities and Regions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Each operator assembles on certain entities of the mesh, the default is a cell-wise assembly. Most operators have the entities kwarg to changes that. Restrictions to subsets of the entities can be made via the regions kwarg.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Entities Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate on the cells of the mesh\nON_FACES assemble/interpolate on all faces of the mesh\nON_IFACES assemble/interpolate on the interior faces of the mesh\nON_BFACES assemble/interpolate on the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate on all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate on the boundary edges of the mesh (in 3D)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/#:-Nonlinear-Poisson-Equation","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"","category":"section"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"(source code)","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"This examples solves the nonlinear Poisson problem","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"beginaligned\n- epsilon partial^2 u  partial x^2 + e^u - e^-u  = f  textin  Omega\nendaligned","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"where","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"f(x) = begincases\n1  x geq 05\n-1  x  05\nendcases","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"on the domain Omega = (01) with Dirichlet boundary conditions u(0) = 0 and u(1) = 1.","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"module Example105_NonlinearPoissonEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# rigt-hand side data\nfunction f!(result, qpinfo)\n\tresult[1] = qpinfo.x[1] < 0.5 ? -1 : 1\nend\n# boundary data\nfunction boundary_data!(result, qpinfo)\n\tresult[1] = qpinfo.x[1]\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion oeprator\nfunction nonlinear_kernel!(result, input, qpinfo)\n\tu, ∇u, ϵ = input[1], input[2], qpinfo.params[1]\n\tresult[1] = exp(u) - exp(-u)\n\tresult[2] = ϵ * ∇u\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 5e-2, ϵ = 1e-3, order = 2, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Nonlinear Poisson Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; params = [ϵ], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; store = true, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, boundary_data!; kwargs...))\n\n\t# discretize: grid + FE space\n\txgrid = simplexgrid(0:h:1)\n\tFES = FESpace{H1Pk{1, 1, order}}(xgrid)\n\n\t# generate a solution vector and solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot discrete and exact solution (on finer grid)\n\tplot([id(u)], sol; Plotter = Plotter)\nend\nend","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"Default output:","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"julia> Example105_NonlinearPoissonEquation.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n   1\t1.662e-01\t5.093e-17\t0.00\t0.00\t0.00\t\t0.11\t0.06\t0.17\n   2\t6.621e-03\t5.524e-17\t0.00\t0.00\t0.00\t\t0.01\t0.04\t0.05\n   3\t2.729e-05\t5.290e-17\t0.00\t0.00\t0.00\t\t0.01\t0.04\t0.05\n   4\t4.733e-10\t5.114e-17\t0.00\t0.00\t0.00\t\t0.01\t0.04\t0.05\n END\t6.182e-17\t\t\t0.00\t\t0.00\t\t0.01\t\t0.01\n\tconverged\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.34\n","category":"page"},{"location":"examples/Example105_NonlinearPoissonEquation/","page":"105 : Nonlinear Poisson Equation","title":"105 : Nonlinear Poisson Equation","text":"(Image: )","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/#:-Eigenvalue-problem-for-the-Laplacian","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"","category":"section"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"(source code)","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"This example computes the pairs of eigenvalues and eigenvectors (lambdau) in mathbbR times H^1_0(Omega) of the Laplacian, i.e,","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"beginaligned\n-Delta u  = lambda u quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"on a two-dimensional L-shaped domain with homogeneous boundary conditions with the help of an iterative solver from KrylovKit.jl.","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"module Example204_LaplaceEVProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing GridVisualize\nusing KrylovKit\n\nfunction main(; which = 1:12, ncols = 3, nrefs = 4, order = 1, Plotter = nothing, kwargs...)\n\n\t# discretize\n\txgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# assemble operators\n\tA = FEMatrix(FES)\n\tB = FEMatrix(FES)\n\tu = FEVector(FES)\n\tassemble!(A, BilinearOperator([grad(1)]; kwargs...))\n\tassemble!(A, BilinearOperator([id(1)]; entities = ON_BFACES, factor = 1e5, kwargs...))\n\tassemble!(B, BilinearOperator([id(1)]; kwargs...))\n\n\t# solver generalized eigenvalue problem iteratively with KrylovKit\n\tλs, x, info = geneigsolve((A.entries, B.entries), maximum(which), :SR; maxiter = 2000, issymmetric = true, tol = 1e-8)\n\t@assert info.converged >= maximum(which)\n\n\t# plot requested eigenvalue pairs\n\tnEVs = length(which)\n\tnrows = Int(ceil(nEVs / ncols))\n    p = GridVisualizer(; Plotter = Plotter, layout = (nrows, ncols), clear = true, resolution = (900,900/ncols*nrows))\n    col, row = 0, 1\n    for j in which\n        col += 1\n        if col == ncols + 1\n            col, row = 1, row + 1\n        end\n\t\tλ = λs[j]\n\t\t@info \"λ[$j] = $λ, residual = $(sum(info.residual[j]))\"\n\t\tu.entries .= Real.(x[j])\n        scalarplot!(p[row,col], id(1), u; Plotter = Plotter, title = \"λ[$j] = $(Float16(λ))\")\n    end\nend\n\nend # module","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"Default output:","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"julia> Example204_LaplaceEVProblem.main()","category":"page"},{"location":"examples/Example204_LaplaceEVProblem/","page":"204 : Eigenvalue problem for the Laplacian","title":"204 : Eigenvalue problem for the Laplacian","text":"(Image: )","category":"page"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times, the printouts in the documentation are taken from a second run after compilations are done","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/#:-Reaction-Convection-Diffusion-Problem","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"","category":"section"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"(source code)","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"-nu Delta u + mathbfbeta cdot nabla u + alpha u = f quad textin  Omega","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta, some scalar-valued function alpha and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"We prescribe an analytic solution with mathbfbeta = (10) and alpha = 01 and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"module Example220_ReactionConvectionDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\nconst α = 0.01\nconst β = [1.0, 0]\nconst ν = 1e-5\n\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[1] * x[2] * (x[1] - 1) * (x[2] - 1) + x[1]\nend\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[2] * (2 * x[1] - 1) * (x[2] - 1) + 1\n\tresult[2] = x[1] * (2 * x[2] - 1) * (x[1] - 1)\nend\nfunction Δu!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = 2 * (x[2] * (x[2] - 1) + x[1] * (x[1] - 1))\nend\n\nfunction rhs()\n\t∇u = zeros(Float64, 2)\n\tΔu = zeros(Float64, 1)\n\tu = zeros(Float64, 1)\n\tfunction closure(result, qpinfo)\n\t\t∇u!(∇u, qpinfo)\n\t\tu!(u, qpinfo)\n\t\tΔu!(Δu, qpinfo)\n\t\tresult[1] = -ν * Δu[1] + α * u[1] + dot(β, ∇u)\n\tend\nend\n\nfunction kernel_DCR!(result, input, qpinfo)\n\tu, ∇u = view(input, 1), view(input, 2:3)\n\tresult[1] = α * u[1] + dot(β, ∇u)\n\tresult[2] = ν * ∇u[1]\n\tresult[3] = ν * ∇u[2]\n\treturn nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# stab_kernel!\nfunction stab_kernel!(result, ∇u, qpinfo)\n\tresult .= ∇u .* qpinfo.volume^2\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, τ = 1e-2, nlevels = 5, order = 2, kwargs...)\n\n\t# create problem description\n\tPD = ProblemDescription(\"reaction-convection-diffusion problem\")\n\tu = Unknown(\"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator(kernel_DCR!, [id(u), grad(u)]; bonus_quadorder = 1, kwargs...))\n\tassign_operator!(PD, LinearOperator(rhs(), [id(u)]; bonus_quadorder = 2, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4, kwargs...))\n\n\t# add a gradient jump (interior penalty) stabilisation for dominant convection\n\tif τ > 0\n\t\tassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = τ))\n\tend\n\n\t# prepare error calculation\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n\tResults = zeros(Float64, nlevels, 4)\n\tNDofs = zeros(Int, nlevels)\n\n\t# refinement loop over levels\n\tsol = nothing\n\txgrid = grid_unitsquare(Triangle2D) # initial grid\n\tfor level ∈ 1:nlevels\n\t\t# uniform mesh refinement\n\t\txgrid = uniform_refine(xgrid)\n\n\t\t# generate FESpace and solve\n\t\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\t\tsol = solve(PD, FES)\n\n\t\t# compute L2 and H1 errors and save data\n\t\tNDofs[level] = length(sol.entries)\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tResults[level, 1] = sqrt(sum(view(error, 1, :)))\n\t\tResults[level, 3] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\n\t\t# interpolate (just for comparison)\n\t\tI = FEVector(FES)\n\t\tinterpolate!(I[1], u!)\n\t\terror = evaluate(ErrorIntegratorExact, I)\n\t\tResults[level, 2] = sqrt(sum(view(error, 1, :)))\n\t\tResults[level, 4] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\tend\n\n\t# plot\n\tp = plot([id(u), grad(u)], sol; add = 1, Plotter = Plotter)\n\tplot_convergencehistory!(p[2,1], NDofs, Results; add_h_powers = [order, order + 1], X_to_h = X -> X .^ (-1 / 2), legend = :lb, ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"], limits = (1e-8, 1e-1))\n\n\t# print convergence history\n\tprint_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\nend\nend","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"Default output:","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"julia> Example220_ReactionConvectionDiffusion.main()\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t2.547e-16\t0.00\t0.00\t0.00\t\t0.30\t0.17\t0.47\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.49\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t3.194e-16\t0.01\t0.00\t0.01\t\t0.44\t0.50\t0.94\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t0.97\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.06\n END\t---------\t4.501e-16\t0.02\t0.00\t0.02\t\t1.27\t2.37\t3.64\n\tfinished\t\t\t\tSUM -->\t0.02\t\t\tSUM -->\t3.69\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.16\n END\t---------\t4.862e-16\t0.06\t0.02\t0.08\t\t3.31\t9.70\t13.00\n\tfinished\t\t\t\tSUM -->\t0.08\t\t\tSUM -->\t13.16\n\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.56\n END\t---------\t5.495e-16\t0.25\t0.10\t0.35\t\t12.76\t45.38\t58.14\n\tfinished\t\t\t\tSUM -->\t0.35\t\t\tSUM -->\t58.69\n\n\n    ndofs   |   || u - u_h ||    order |   || u - Iu ||     order | || ∇(u - u_h) ||   order |  || ∇(u - Iu) ||   order |\n============|==========================|==========================|==========================|==========================|\n        41  |     1.487e-03      0.00  |     7.408e-04      0.00  |     2.187e-02      0.00  |     1.449e-02      0.00  |\n       145  |     1.510e-04      3.62  |     9.003e-05      3.34  |     4.907e-03      2.37  |     3.574e-03      2.22  |\n       545  |     1.695e-05      3.30  |     1.117e-05      3.15  |     1.181e-03      2.15  |     8.905e-04      2.10  |\n      2113  |     1.925e-06      3.21  |     1.394e-06      3.07  |     2.855e-04      2.10  |     2.224e-04      2.05  |\n      8321  |     2.245e-07      3.14  |     1.742e-07      3.03  |     6.972e-05      2.06  |     5.560e-05      2.02  |","category":"page"},{"location":"examples/Example220_ReactionConvectionDiffusion/","page":"220 : Reaction-Convection-Diffusion-Problem","title":"220 : Reaction-Convection-Diffusion-Problem","text":"(Image: )","category":"page"},{"location":"pdesolvers/#Stationary-Solvers","page":"Stationary Solvers","title":"Stationary Solvers","text":"","category":"section"},{"location":"pdesolvers/#Meshes-and-FESpaces","page":"Stationary Solvers","title":"Meshes and FESpaces","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Meshes are expected in the form of an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl. There is also an extension to read meshes from gmsh files.","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"FESpace{FEType}(grid::ExtendableGrid)","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Here, FEType denotes the type of finite element. A list of available FETypes can be found in the Documentation of ExtendableFEMBase.jl.","category":"page"},{"location":"pdesolvers/#Solve-(monolithic)","page":"Stationary Solvers","title":"Solve (monolithic)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. ","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"solve","category":"page"},{"location":"pdesolvers/#CommonSolve.solve","page":"Stationary Solvers","title":"CommonSolve.solve","text":"function solve(\n\tPD::ProblemDescription,\n\t[FES::Union{<:FESpace,Vector{<:FESpace}}],\n\tSC = nothing;\n\tunknowns = PD.unknowns,\n\tkwargs...)\n\nReturns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nThis function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\ntime: current time to be used in all time-dependent operators. Default: 0.0\nspy: show unicode spy plot of system matrix during solve. Default: false\nshow_config: show configuration at the beginning of solve. Default: false\npreconlinear: function that computes preconditioner for methodlinear incase an iterative solver is chosen. Default: nothing\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_matrix: show system matrix after assembly. Default: false\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\nDepending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"note: Note\nThe type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat costumized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.","category":"page"},{"location":"pdesolvers/#Solve-(iterating-subproblems)","page":"Stationary Solvers","title":"Solve (iterating subproblems)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"SolverConfiguration","category":"page"},{"location":"pdesolvers/#ExtendableFEM.SolverConfiguration","page":"Stationary Solvers","title":"ExtendableFEM.SolverConfiguration","text":"function iterate_until_stationarity(\n\tSolverConfiguration(Problem::ProblemDescription\n\t[FES::Union{<:FESpace, Vector{<:FESpace}}];\n\tinit = nothing,\n\tunknowns = Problem.unknowns,\n\tkwargs...)\n\nReturns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\ntime: current time to be used in all time-dependent operators. Default: 0.0\nspy: show unicode spy plot of system matrix during solve. Default: false\nshow_config: show configuration at the beginning of solve. Default: false\npreconlinear: function that computes preconditioner for methodlinear incase an iterative solver is chosen. Default: nothing\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_matrix: show system matrix after assembly. Default: false\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"iterate_until_stationarity","category":"page"},{"location":"pdesolvers/#ExtendableFEM.iterate_until_stationarity","page":"Stationary Solvers","title":"ExtendableFEM.iterate_until_stationarity","text":"function iterate_until_stationarity(\n\tSCs::Array{<:SolverConfiguration, 1},\n\tFES = nothing;\n\tmaxsteps = 1000,\n\tinit = nothing,\n\tunknowns = [SC.PD.unknowns for SC in SCs],\n\tkwargs...)\n\nIterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corressponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.\n\nUsing the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by\n\nSolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)\n\nwith the usual keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"examples/Example290_PoroElasticity/#:-Poro-Elasticity","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"","category":"section"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"(source code)","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"This example concerns the three-field solution (mathbfwmathbfup) of Biot's consolidation model in poroelasticity given by","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"beginaligned\n-(lambda + mu) nabla (mathrmdiv mathbfv) - mu Delta mathbfv + alpha nabla p  = f quad textin  Omega times 0T\npartial_t (c_o + α mathrmdiv(mathbfv)) + mathrmdiv(wmathbfw)  = g quad textin  Omega times 0T\nK^-1 mathbfw + nabla p  = 0 quad textin  Omega times 0T\nendaligned","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"and suitable boundary conditions and given initial state.","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"The discretisation involves an Hdiv-conforming reconstruction operator to avoid Poisson locking which results in a scheme similar to the one suggested in the reference below. As a test problem the first benchmark problem from the same reference is used.","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"reference: Reference\n\"A study of two modes of locking in poroelasticity\",\nS.-Y. Yi,\nSIAM J. Numer. Anal. 55(4) (2017),\n>Journal-Link<","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"module Example290_PoroElasticity\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\nusing GridVisualize\nusing Symbolics\n\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; μ = 1, λ = 1, K = 1, c0 = 1, α = 1)\n\n\t@variables x y t\n\n\t# displacement and pressure\n\tu = [exp(-t) * (sin(2 * pi * y) * (-1 + cos(2 * pi * x)) + sin(pi * x) * sin(pi * y) / (μ + λ))\n\t\texp(-t) * (sin(2 * pi * x) * (1 - cos(2 * pi * y)) + sin(pi * x) * sin(pi * y) / (μ + λ))]\n\tp = exp(-t) * sin(pi * x) * sin(pi * y)\n\n\t# gradient of displacement\n\t∇u = Symbolics.jacobian(u, [x, y])\n\t∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n\t# gradient of pressure\n\t∇p = [Symbolics.gradient(p, [x])[1], Symbolics.gradient(p, [y])[1]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1, 1], [x])+Symbolics.gradient(∇u[1, 2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2, 1], [x])+Symbolics.gradient(∇u[2, 2], [y]))[1],\n\t]\n\tΔp = Symbolics.gradient(∇p[1], [x]) + Symbolics.gradient(∇p[2], [y])\n\tdivu = ∇u[1, 1] + ∇u[2, 2]\n\t∇divu = [Symbolics.gradient(divu, [x])[1], Symbolics.gradient(divu, [y])[1]]\n\tdivu_dt = Symbolics.gradient(divu, [t])\n\n\tf = -μ * Δu .+ α * ∇p .- (μ + λ) * ∇divu\n\tg = c0 * Symbolics.gradient(p, [t]) - K * Δp + α * divu_dt\n\n\tu_eval = build_function(u, x, y, t, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, t, expression = Val{false})\n\tg_eval = build_function(g, x, y, t, expression = Val{false})\n\tf_eval = build_function(f, x, y, t, expression = Val{false})\n\tp_eval = build_function(p, x, y, t, expression = Val{false})\n\t∇p_eval = build_function(∇p, x, y, t, expression = Val{false})\n\n\treturn f_eval[2], g_eval[2], u_eval[2], ∇u_eval[2], p_eval, ∇p_eval[2]\nend\n\nfunction linear_kernel!(result, input, qpinfo)\n\t∇u, divu, p, w, divw = view(input, 1:4), view(input, 5), view(input, 6), view(input, 7:8), view(input, 9)\n\tμ, λ, α, K = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3], qpinfo.params[4]\n\tresult[1] = μ * ∇u[1] + (λ + μ) * divu[1] - p[1]\n\tresult[2] = μ * ∇u[2]\n\tresult[3] = μ * ∇u[3]\n\tresult[4] = μ * ∇u[4] + (λ + μ) * divu[1] - p[1]\n\tresult[5] = divu[1]\n\tresult[6] = divw[1]\n\tresult[7] = w[1] / K\n\tresult[8] = w[2] / K\n\tresult[9] = -p[1]\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!, ∇u!, p!)\n\tfunction closure(result, u, qpinfo)\n\t\tu!(view(result, 1:2), qpinfo)\n\t\t∇u!(view(result, 3:6), qpinfo)\n\t\tp!(view(result, 7), qpinfo)\n\t\tview(result, 1:7) .-= u\n\t\tresult .= result .^ 2\n\tend\nend\n\nfunction main(; α = 0.93, E = 1e5, ν = 0.4, K = 1e-7, nrefs = 6, T = 0.5, τ = 1e-2, c0 = 1, order = 1, reconstruct = true, Plotter = nothing, kwargs...)\n\n\t# calculate Lame' parameter\n\tμ = E / (2 * (1 + ν))\n\tλ = E * ν / ((1 - 2 * ν) * (1 + ν))\n\n\t# initial and exact state for u and p at time t0\n\tf_eval, g_eval, u_eval, ∇u_eval, p_eval, ∇p_eval = prepare_data!(; μ = μ, λ = λ, K = K, c0 = c0, α = α)\n\tf!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\tg!(result, qpinfo) = (g_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_∇p!(result, qpinfo) = (∇p_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\n\t# problem description\n\tPD = ProblemDescription(\"Heat Equation\")\n\tu = Unknown(\"u\"; name = \"displacement\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tw = Unknown(\"w\"; name = \"Darcy velocity\")\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_unknown!(PD, w)\n\n\t# prepare reconstruction operator\n\tif reconstruct\n\t\tFES_Reconst = order == 1 ? HDIVBDM1{2} : HDIVBDM2{2}\n\t\tdivu = apply(u, Reconstruct{FES_Reconst, Divergence})\n\t\tidu = apply(u, Reconstruct{FES_Reconst, Identity})\n\telse\n\t\tdivu = div(u)\n\t\tidu = id(u)\n\tend\n\n\t# linear operator\n\tassign_operator!(PD, BilinearOperator(linear_kernel!, [grad(u), divu, id(p), id(w), div(w)]; params = [μ, λ, α, K], store = true, kwargs...))\n\n\t# right-hand side data\n\tassign_operator!(PD, LinearOperator(f!, [idu]; kwargs...))\n\tassign_operator!(PD, LinearOperator(g!, [id(p)]; kwargs...))\n\n\t# boundary conditions\n\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4))\n\tassign_operator!(PD, InterpolateBoundaryData(p, exact_p!; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n\t# prepare solution vector\n\tif order == 1\n\t\tFES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid; broken = true), FESpace{HDIVRT0{2}}(xgrid)]\n\telseif order == 2\n\t\tFES = [FESpace{H1P2B{2, 2}}(xgrid), FESpace{H1P1{1}}(xgrid; broken = true), FESpace{HDIVRT1{2}}(xgrid)]\n\tend\n\tsol = FEVector(FES; tags = PD.unknowns)\n\n\t# initial data\n\tinterpolate!(sol[u], exact_u!; bonus_quadorder = 5, time = 0)\n\tinterpolate!(sol[p], exact_p!; bonus_quadorder = 5, time = 0)\n\n\t# init plotter and plot initial data and grid\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (3, 2), clear = true, size = (800, 1200))\n\tscalarplot!(plt[1, 1], id(u), sol; abs = true, title = \"u_h (t = 0)\")\n\tscalarplot!(plt[2, 1], id(p), sol; title = \"p_h (t = 0)\")\n\tgridplot!(plt[3, 1], xgrid; linewidth = 1)\n\n\t# compute mass matrix\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(2)]; factor = c0))\n\tassemble!(M, BilinearOperator([id(2)], [div(1)]; factor = -α))\n\n\t# add backward Euler time derivative\n\tassign_operator!(PD, BilinearOperator(M, [u, p, w]; factor = 1 / τ, kwargs...))\n\tassign_operator!(PD, LinearOperator(M, [u, p, w], [u, p, w]; factor = 1 / τ, kwargs...))\n\n\t# generate solver configuration\n\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, verbosity = -1, constant_matrix = true, kwargs...)\n\n\t# iterate tspan\n\tt = 0\n\tfor it ∈ 1:Int(floor(T / τ))\n\t\tt += τ\n\t\t@info \"t = $t\"\n\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\tend\n\n\t# error calculation\n\tErrorIntegrator = ItemIntegrator(exact_error!(exact_u!, exact_∇u!, exact_p!), [id(u), grad(u), id(p)]; quadorder = 2 * (order + 1), kwargs...)\n\terror = evaluate(ErrorIntegrator, sol; time = T)\n\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\tH1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n\tL2errorP = sqrt(sum(view(error, 7, :)))\n\t@info \"|| u - u_h || = $L2errorU\n\t|| ∇(u - u_h) || = $H1errorU\n\t|| p - p_h || = $L2errorP\"\n\n\t# plot final state\n\tscalarplot!(plt[1, 2], id(u), sol; abs = true, title = \"u_h (t = $T)\")\n\tscalarplot!(plt[2, 2], id(p), sol; title = \"p_h (t = $T)\")\n\tscalarplot!(plt[3, 2], id(w), sol; abs = true, title = \"|w_h| (t = $T)\")\nend\n\nend # module","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"Default output:","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"julia> Example290_PoroElasticity.main()","category":"page"},{"location":"examples/Example290_PoroElasticity/","page":"290 : Poro-Elasticity","title":"290 : Poro-Elasticity","text":"(Image: )","category":"page"},{"location":"examples/Example103_BurgersEquation/#:-Burger's-Equation","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"","category":"section"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"(source code)","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"This example solves the Burger's equation","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"beginaligned\nu_t - mu Delta u + mathrmdiv f(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"with periodic boundary conditions.","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"module Example103_BurgersEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\n\nfunction kernel_nonlinear!(result, u, qpinfo)\n\tresult[1] = u[1]^2 / 2\nend\n\nfunction initial_data!(result, qpinfo)\n\tresult[1] = abs(qpinfo.x[1]) < 0.5 ? 1 : 0\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\tν = 0.01,\n\th = 0.005,\n\tT = 2,\n\torder = 2,\n\tτ = 0.01,\n\tPlotter = nothing,\n\tuse_diffeq = true,\n\tsolver = Rosenbrock23(autodiff = false),\n\tkwargs...)\n\n\t# load mesh and exact solution\n\txgrid = simplexgrid(-2:h:2)\n\n\t# generate empty PDEDescription for three unknowns (h, u)\n\tPD = ProblemDescription(\"Burger's Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [grad(u)], [id(u)]; bonus_quadorder = 2))\n\tassign_operator!(PD, BilinearOperator([grad(u)]; store = true, factor = ν))\n\tassign_operator!(PD, CombineDofs(u, u, [1], [num_nodes(xgrid)], [1.0]; kwargs...))\n\n\t# prepare solution vector and initial data\n\tFES = FESpace{H1Pk{1, 1, order}}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], initial_data!)\n\n\t# init plotter and plot u0\n\tp = plot([id(u), id(u)], sol; Plotter = Plotter, title_add = \" (t = 0)\")\n\n\t# generate mass matrix\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(1)]; lump = 2))\n\n\tif (use_diffeq)\n\t\t# generate DifferentialEquations.ODEProblem\n\t\tprob = ExtendableFEM.generate_ODEProblem(PD, FES, (0.0, T); init = sol, mass_matrix = M)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-6, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor(T / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state\n\tplot!(p, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\nend\nend","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"Default output:","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"julia> Example103_BurgersEquation.main()","category":"page"},{"location":"examples/Example103_BurgersEquation/","page":"103 : Burger's Equation","title":"103 : Burger's Equation","text":"(Image: )","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/#:-Poisson-L-shape-Adaptive-Mesh-Refinement","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"section"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"(source code)","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"This example computes the standard-residual error estimator for the H^1 error e = u - u_h of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"eta^2(u_h) = sum_T in mathcalT lvert T rvert  f + Delta u_h ^2_L^2(T)\n+ sum_F in mathcalF lvert F rvert  nabla u_h cdot mathbfn ^2_L^2(F)","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"This example script showcases the evaluation of 2nd order derivatives like the Laplacian and adaptive mesh refinement.","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"module Example210_LshapeAdaptivePoissonProblem\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tr2 = x[1]^2 + x[2]^2\n\tφ = atan(x[2], x[1])\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\tresult[1] = r2^(1 / 3) * sin(2 * φ / 3)\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tφ = atan(x[2], x[1])\n\tr2 = x[1]^2 + x[2]^2\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\t∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n\t∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n\tresult[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n\tresult[2] = sin(φ) * ∂r + cos(φ) * ∂φ\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# kernel for face interpolation of normal jumps of gradient\nfunction gradnormalflux!(result, ∇u, qpinfo)\n\titem = qpinfo.item\n\tnormal = view(qpinfo.params, :, item)\n\tresult[1] = dot(∇u, normal)\nend\n\n# kernel for face refinement indicator\nfunction η_face!(result, gradjump, qpinfo)\n\tresult .= qpinfo.volume * gradjump .^ 2\nend\n\n# kernel for cell refinement indicator\nfunction η_cell!(result, Δu, qpinfo)\n\tresult .= qpinfo.volume * Δu .^ 2\nend\n\nfunction main(; maxdofs = 4000, θ = 0.5, μ = 1.0, nrefs = 1, order = 2, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Poisson problem\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n\t# discretize\n\txgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n\n\t# define item integrators for estimation and error calculation\n\tErrorIntegratorFace = ItemIntegrator(η_face!, [id(1)]; quadorder = 2 * order, entities = ON_IFACES, kwargs...)\n\tErrorIntegratorCell = ItemIntegrator(η_cell!, [Δ(1)]; quadorder = 2 * (order - 2), entities = ON_CELLS, kwargs...)\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n\n\tNDofs = zeros(Int, 0)\n\tResultsL2 = zeros(Float64, 0)\n\tResultsH1 = zeros(Float64, 0)\n\tResultsη = zeros(Float64, 0)\n\tsol = nothing\n\tndofs = 0\n\tlevel = 0\n\twhile ndofs < maxdofs\n\t\tlevel += 1\n\n\t\t# SOLVE : create a solution vector and solve the problem\n\t\tprintln(\"------- LEVEL $level\")\n\t\tif ndofs < 1000\n\t\t\tprintln(stdout, unicode_gridplot(xgrid))\n\t\tend\n\t\t@time begin\n\t\t\t# solve\n\t\t\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\t\t\tsol = ExtendableFEM.solve(PD, FES; u = [u], kwargs...)\n\t\t\tndofs = length(sol[1])\n\t\t\tpush!(NDofs, ndofs)\n\t\t\tprintln(\"\\t ndof =  $ndofs\")\n\t\t\tprint(\"@time  solver =\")\n\t\tend\n\n\t\t# ESTIMATE : calculate local error estimator contributions\n\t\t@time begin\n\t\t\t# calculate error estimator\n\t\t\tJumpInterpolator = FaceInterpolator(gradnormalflux!, [jump(grad(u))]; resultdim = 1, order = order - 1, params = xgrid[FaceNormals], kwargs...)\n\t\t\tη_F = evaluate(ErrorIntegratorFace, evaluate!(JumpInterpolator, sol))\n\t\t\tη_F[xgrid[BFaceFaces]] .= 0\n\n\t\t\tη_T = evaluate(ErrorIntegratorCell, sol)\n\t\t\tfacecells = xgrid[FaceCells]\n\t\t\tfor face ∈ 1:size(facecells, 2)\n\t\t\t\tη_F[face] += η_T[facecells[1, face]]\n\t\t\t\tif facecells[2, face] > 0\n\t\t\t\t\tη_F[face] += η_T[facecells[2, face]]\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t# calculate total estimator\n\t\t\tpush!(Resultsη, sqrt(sum(η_F)))\n\t\t\tprint(\"@time  η eval =\")\n\t\tend\n\n\t\t# calculate exact L2 error, H1 error\n\t\t@time begin\n\t\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\t\tpush!(ResultsL2, sqrt(sum(view(error, 1, :))))\n\t\t\tpush!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n\t\t\tprint(\"@time  e eval =\")\n\t\tend\n\n\t\tif ndofs >= maxdofs\n\t\t\tbreak\n\t\tend\n\n\t\t# MARK+REFINE : mesh refinement\n\t\t@time begin\n\t\t\tif θ >= 1 ## uniform mesh refinement\n\t\t\t\txgrid = uniform_refine(xgrid)\n\t\t\telse ## adaptive mesh refinement\n\t\t\t\t# refine by red-green-blue refinement (incl. closuring)\n\t\t\t\tfacemarker = bulk_mark(xgrid, view(η_F, :), θ; indicator_AT = ON_FACES)\n\t\t\t\txgrid = RGB_refine(xgrid, facemarker)\n\t\t\tend\n\t\t\tprint(\"@time  refine =\")\n\t\tend\n\t\tprintln(\"\\t    η =  $(Resultsη[level])\\n\\t    e =  $(ResultsH1[level])\")\n\tend\n\n\t# plot\n\tp = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\tscalarplot!(p[1, 1], id(u), sol; levels = 7, title = \"u_h\")\n\tplot_convergencehistory!(p[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\tgridplot!(p[2, 1], xgrid; linewidth = 1)\n\tgridplot!(p[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n\t# print convergence history\n\tprint_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\nend\n\nend # module","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"Default output:","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"julia> Example210_LshapeAdaptivePoissonProblem.main()\n------- LEVEL 1\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.02\n END\t---------\t1.988e-15\t0.00\t0.00\t0.00\t\t0.10\t0.13\t0.23\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.25\n\n\t ndof =  65\n@time  solver =  0.001835 seconds (1.84 k allocations: 295.188 KiB)\n@time  η eval =  0.000793 seconds (1.33 k allocations: 83.758 KiB)\n@time  e eval =  0.000416 seconds (472 allocations: 32.188 KiB)\n@time  refine =  0.000037 seconds (61 allocations: 7.969 KiB)\n\t    η =  1.0136544491990602\n\t    e =  0.12088162458820484\n------- LEVEL 2\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⡴⠥⠤⠤⢤⡧⠤⠤⠤⢵⢔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢗⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.268e-15\t0.00\t0.00\t0.00\t\t0.11\t0.14\t0.24\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.27\n\n\t ndof =  85\n@time  solver =  0.001527 seconds (1.84 k allocations: 310.367 KiB)\n@time  η eval =  0.000712 seconds (1.53 k allocations: 96.555 KiB)\n@time  e eval =  0.000503 seconds (470 allocations: 32.250 KiB)\n@time  refine =  0.000037 seconds (62 allocations: 11.750 KiB)\n\t    η =  0.6070065806022737\n\t    e =  0.07212627945120852\n------- LEVEL 3\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣴⠥⠤⠤⢤⣧⠤⠤⠤⢵⣔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⡠⠊⣇⠔⠁⠑⢄⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡟⢍⢹⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠝⢅⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢷⠥⠤⠤⠵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.563e-15\t0.00\t0.00\t0.00\t\t0.11\t0.18\t0.29\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.32\n\n\t ndof =  111\n@time  solver =  0.001627 seconds (1.86 k allocations: 363.617 KiB)\n@time  η eval =  0.000749 seconds (1.78 k allocations: 109.617 KiB)\n@time  e eval =  0.000583 seconds (470 allocations: 32.516 KiB)\n@time  refine =  0.000036 seconds (64 allocations: 13.219 KiB)\n\t    η =  0.40677133325934156\n\t    e =  0.0482293571503376\n------- LEVEL 4\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣴⠥⠤⠤⢤⣧⠤⠤⠤⢵⣔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⣵⡻⣿⠾⣹⠑⢄⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡟⢍⢹⣻⡟⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠝⢗⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢷⠥⠤⠤⠵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.963e-15\t0.00\t0.00\t0.00\t\t0.15\t0.21\t0.36\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.39\n\n\t ndof =  137\n@time  solver =  0.001759 seconds (1.88 k allocations: 442.586 KiB)\n@time  η eval =  0.001028 seconds (2.02 k allocations: 122.477 KiB)\n@time  e eval =  0.000704 seconds (470 allocations: 32.828 KiB)\n@time  refine =  0.000044 seconds (68 allocations: 18.234 KiB)\n\t    η =  0.2921985504768297\n\t    e =  0.03448375985345018\n------- LEVEL 5\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣴⠥⠤⠤⢤⣧⠤⠤⠤⢵⣔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⣵⣿⣿⡾⣹⠑⢄⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡟⢍⢹⣻⡿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠝⢗⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢷⠥⠤⠤⠵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.913e-15\t0.00\t0.00\t0.00\t\t0.15\t0.27\t0.42\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.45\n\n\t ndof =  163\n@time  solver =  0.001881 seconds (1.89 k allocations: 506.430 KiB)\n@time  η eval =  0.001040 seconds (2.27 k allocations: 138.039 KiB)\n@time  e eval =  0.000875 seconds (470 allocations: 33.141 KiB)\n@time  refine =  0.000050 seconds (70 allocations: 19.781 KiB)\n\t    η =  0.2318262809680798\n\t    e =  0.027182306884589353\n------- LEVEL 6\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡏⠉⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠀⠀⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢀⠔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣴⠥⠤⠤⢤⣧⠤⠤⠤⢵⣷⠥⠤⠤⠤⡧⠤⠤⠤⢵⢔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠀⠀⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⠔⠁⡇⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⣵⣿⣿⡾⣹⠑⢄⡇⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⡟⢍⢹⣻⡿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⠝⢗⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⢑⢴⠥⠤⠤⠤⣧⠤⠤⠤⢵⣷⠥⠤⠤⠵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠑⢄⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠑⢄⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢗⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣔⣁⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.03\n END\t---------\t2.868e-15\t0.00\t0.00\t0.00\t\t0.17\t0.37\t0.54\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.57\n\n\t ndof =  225\n@time  solver =  0.002291 seconds (1.91 k allocations: 634.812 KiB)\n@time  η eval =  0.001184 seconds (2.88 k allocations: 169.039 KiB)\n@time  e eval =  0.001096 seconds (470 allocations: 33.875 KiB)\n@time  refine =  0.000053 seconds (72 allocations: 23.031 KiB)\n\t    η =  0.16521774252356994\n\t    e =  0.02013144451368136\n------- LEVEL 7\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⠉⢹│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⠀⠀⠀⢸│ \n    │⡇⠀⠀⠀⢑⡴⠥⠤⠤⢤⡧⠤⠤⠤⢵⣔⠁⠀⠀⠀⡇⠀⠀⠀⢑⣔⠁⠀⠀⠀⡇⠀⠀⠀⠑⢄⠀⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⡇⠀⠀⠑⢄⣇⠔⠁⠀⠀⡇⠀⠀⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⢉⠝⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⢀⢵⢅⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⢷⠥⠤⠤⠤⡧⠤⠤⠤⢵⣷⠥⠤⠤⢤⣷⠥⢼⡤⣵⣷⠥⠤⠤⢤⡧⠤⠤⠤⢵⢔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣼⣞⣣⣇⣑⣄⠔⠁⡇⠀⢀⠔⠁⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠀⠀⣇⠔⢹⣵⣿⣿⡾⣹⠑⢄⣇⠔⠁⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⢉⠝⡟⢍⢹⣻⡿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⢀⠕⢗⠒⡗⢒⢿⢗⠚⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⢑⢴⠥⠤⠤⠤⣷⠥⠤⠤⢵⣷⠥⢼⠤⢵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠑⢄⠔⠁⡇⠑⢼⠔⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠑⢄⣇⠔⠁⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇⠀⠀⠀⢑⢗⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣀⣀⣀⣀⣀⣀⣀⣑⣄⣇⣔⣁⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.04\n END\t---------\t5.500e-15\t0.00\t0.00\t0.00\t\t0.30\t0.53\t0.82\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t0.86\n\n\t ndof =  315\n@time  solver =  0.002897 seconds (1.93 k allocations: 936.750 KiB)\n@time  η eval =  0.001359 seconds (3.77 k allocations: 225.336 KiB)\n@time  e eval =  0.001761 seconds (470 allocations: 34.875 KiB)\n@time  refine =  0.000072 seconds (75 allocations: 39.156 KiB)\n\t    η =  0.11628117656103873\n\t    e =  0.01424333452296225\n------- LEVEL 8\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⡴⠥⠤⠤⢤⡧⠤⠤⠤⢵⣴⠥⠤⠤⢤⡧⠤⠤⠤⢵⣔⠁⠀⠀⠀⡇⠀⠀⠀⢑⢔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⠑⢄⣇⠔⠁⠀⠀⡇⠀⠀⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⡟⢍⢹⢉⠝⡟⢍⠉⢉⠝⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⢽⢅⠀⡇⢀⢵⢅⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⣷⠥⠤⠤⢤⣧⠤⠤⠤⢵⣷⠥⢼⡤⣵⣷⢥⣼⡤⣵⣷⠥⠤⠤⢤⡧⠤⠤⠤⢵⢔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⣔⣁⣇⣑⣼⣞⣣⣷⣟⣼⣞⣣⣇⣑⣄⠔⠁⡇⠀⢀⠔⠁⠀⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠑⢄⣇⠔⠁⠑⢄⣯⠾⣹⣵⣿⣿⣿⣿⣷⢏⣇⠔⠁⠑⢄⣇⠔⠁⠀⠀⠀⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⢉⠝⣟⣽⢿⣿⣿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⢀⠕⢗⠒⡟⢒⢿⢿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⢑⢷⠥⠤⠤⠤⣷⠥⠤⠤⢵⣷⠥⢼⠯⢵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠑⢄⠔⠁⡇⠑⢼⠔⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⠔⠁⠀⠀⠀⠀⠀⠑⢄⣇⠔⠁⠑⢄⣇⠔⠁⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⢑⢔⠁⠀⠀⠀⡇⠀⠀⠀⢑⢗⠁⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣔⣁⣀⣀⣀⣀⣀⣑⣄⣇⣔⣁⣀⣀⣀⣀⣀⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.05\n END\t---------\t5.607e-15\t0.00\t0.00\t0.00\t\t0.39\t0.71\t1.10\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t1.15\n\n\t ndof =  451\n@time  solver =  0.003827 seconds (1.97 k allocations: 1.204 MiB)\n@time  η eval =  0.001936 seconds (5.29 k allocations: 311.805 KiB)\n@time  e eval =  0.002150 seconds (470 allocations: 36.438 KiB)\n@time  refine =  0.000092 seconds (75 allocations: 53.375 KiB)\n\t    η =  0.08247990319840433\n\t    e =  0.009890770104296608\n------- LEVEL 9\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⠉⠉⡟⢍⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⢵⢅⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⡴⠥⠤⠤⢤⡧⠤⠤⠤⢵⣴⠥⠤⠤⢤⡧⠤⠤⠤⢵⣗⠁⢸⠀⢑⡧⠤⠤⠤⢵⣔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠔⠁⡇⠀⢀⠔⠁⡇⠑⢼⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⠁⠀⠀⣇⠔⢹⠑⢄⣇⠔⠁⠀⠀⣇⠔⢹⠑⢄⣇⠔⠁⠀⠀⡇⠀⠀⠑⢼│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⢉⠝⡟⢍⢹⢉⠝⡟⢍⠉⢉⠝⡏⡩⢻⢉⠝⡟⢍⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⢀⠕⢅⠀⡇⢀⢽⢗⠒⡗⢒⢷⢗⠒⡟⢒⢾⠓⡲⡗⢒⠗⢅⠀⡇⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⣷⠥⠤⠤⢤⣷⠥⠤⠤⢵⣷⠥⢼⡤⣵⣷⢥⣼⡤⣵⣷⠥⢼⠮⢤⣷⠥⠤⠤⢵⢷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣇⣑⣄⣔⣁⣇⣑⣼⣾⣣⣷⣟⣼⣞⣣⣇⣑⣼⠔⠁⡇⠑⢄⣔⣁⣀⣑⣄⠔⢹│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠑⢄⣇⠔⢹⠑⢄⣯⠾⣻⣿⣿⣿⣿⣿⣷⢏⣯⠾⣹⠑⢄⣇⠔⠁⠑⢄⢀⠔⠁⠑⢼│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⢹⢉⠝⣟⣽⢿⣿⣿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⢀⠝⢗⠒⡟⢒⢿⢿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣧⠤⠤⠤⢵⣷⠥⠤⠤⠤⣷⠥⠤⠤⢵⣷⠥⢼⠯⢵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠑⢄⠔⠁⡇⠑⢄⠀⠀⡇⠑⢄⠔⠁⡇⠑⢼⠔⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⠔⠁⠑⢄⡇⠀⠀⠑⢄⣇⠔⠁⠑⢄⣇⠔⠁⠑⢄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⡟⢍⠉⢉⠝⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⢵⢅⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠀⠀⢑⢷⠥⠤⠤⠤⡧⠤⠤⠤⢵⣗⠁⢸⠀⢑⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⢀⠔⠁⠀⠑⢄⠀⠀⡇⠀⢀⠔⠁⡇⠑⢼⠔⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣔⣁⣀⣀⣀⣀⣀⣑⣄⣇⣔⣁⣀⣀⣇⣔⣁⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.06\n END\t---------\t5.847e-15\t0.00\t0.00\t0.00\t\t0.55\t1.06\t1.61\n\tfinished\t\t\t\tSUM -->\t0.00\t\t\tSUM -->\t1.67\n\n\t ndof =  666\n@time  solver =  0.005257 seconds (2.28 k allocations: 1.755 MiB)\n@time  η eval =  0.002617 seconds (7.64 k allocations: 431.023 KiB)\n@time  e eval =  0.003348 seconds (472 allocations: 39.531 KiB)\n@time  refine =  0.000127 seconds (87 allocations: 65.562 KiB)\n\t    η =  0.057172241179725726\n\t    e =  0.006812212792947163\n------- LEVEL 10\n    ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀gridplot⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \n    ┌────────────────────────────────────────┐ \n    │⡟⢍⠉⠉⠉⠉⠉⠉⢉⠝⡟⢍⠉⢉⠝⡏⠉⠉⢉⠝⡟⢍⠉⠉⠉⡟⢍⠉⢉⠝⡟⢍⠉⠉⠉⠉⠉⠉⢉⢽│ \n    │⡇⠀⠑⢄⠀⠀⢀⠔⠁⠀⡇⢀⢵⢅⠀⡇⢀⠔⠁⠀⡇⠀⠑⢄⠀⡇⢀⢵⢅⠀⡇⠀⠑⢄⠀⠀⢀⠔⠁⢸│ \n    │⡇⠀⠀⠀⢑⣴⠥⠤⠤⢤⡷⠥⣼⠤⢵⣷⠥⠤⠤⢤⣧⠤⠤⠤⢵⣗⠁⢸⠀⢑⡧⠤⠤⠤⢵⣔⠁⠀⠀⢸│ \n    │⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣧⣊⣸⠔⠁⡇⠑⢄⠔⠁⡇⠑⢄⣔⣁⣇⣑⣼⠔⠁⡇⠀⢀⠔⠁⡇⠑⢄⠀⢸│ \n    │⣇⠔⠁⠀⠀⣇⠔⢹⡠⠊⣇⠔⢹⠑⢄⣇⠔⢹⠑⢄⣇⠔⢹⡠⠊⣇⠔⢹⠑⢄⣇⠔⠁⠀⠀⡇⠀⠀⠑⢼│ \n    │⡟⢍⠉⢉⠝⡏⡩⢻⢉⠝⡟⢍⢹⢉⠝⣟⣽⢻⢉⠝⣟⣽⢻⢉⠝⡏⡩⢻⢉⠝⡟⢍⠉⢉⠝⡏⠉⠉⢉⢽│ \n    │⡇⢀⠕⢗⠒⡟⢒⠞⢗⠒⡗⢒⢿⢗⡶⡯⣧⣿⣗⡶⡟⢒⢿⢗⠒⡟⢒⢾⠓⡲⡗⢒⠗⢅⠀⡇⢀⠔⠁⢸│ \n    │⡷⠥⠤⠤⢵⣷⠥⠤⠤⢵⣷⢥⡼⡯⣵⣿⣷⣽⡯⣵⣷⢥⣼⡤⣵⣷⠥⢼⠮⢤⣷⠥⠤⠤⢵⢷⠥⠤⠤⢼│ \n    │⡇⠀⢀⠔⠁⡇⠑⢄⣔⣁⣷⣛⣭⣿⣝⣿⣟⣽⣿⣫⣿⣟⣼⣞⣣⣇⣑⣼⠔⠁⡇⠑⢄⣔⣁⣀⣑⣄⠔⢹│ \n    │⣇⠔⠁⠀⠀⣇⠔⠁⠑⢄⣇⠔⢹⡽⢏⣯⡿⣻⣿⣿⣿⣿⣿⣷⢏⣯⠾⣹⠑⢄⣇⠔⠁⠑⢄⢀⠔⠁⠑⢼│ \n    │⡟⢍⠉⠉⠉⡟⢍⠉⢉⠝⣟⣽⢻⣫⡿⣿⣿⢿⣿⣿⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉│ \n    │⡇⠀⠑⢄⠀⡇⢀⢵⠓⡲⡯⣧⣟⣗⣾⣿⣷⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣧⠤⠤⠤⢵⣷⠥⢼⡮⠤⣿⢭⣶⠯⢵⣿⣷⣽⡯⣵⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠑⢄⠔⠁⡇⠑⢼⣈⣢⣷⣛⣼⣔⣁⡷⡟⣼⢾⢣⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⠔⠁⠑⢄⣇⠔⠁⠑⢄⣇⠔⢹⠑⢄⣯⠿⣓⡿⢏⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡟⢍⠉⠉⠉⡏⠉⠉⢉⠝⡟⢍⢹⠫⡉⡟⢍⢹⢉⠝⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠀⠑⢄⠀⡇⢀⠔⠁⠀⡇⢀⠝⢖⠚⡗⢒⢿⢅⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣧⠤⠤⠤⢵⣷⠥⠤⠤⠤⡷⠥⠤⠤⢵⣗⠁⢸⠀⢑⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⡇⠑⢄⠔⠁⡇⠑⢄⠀⠀⡇⠀⢀⠔⠁⡇⠑⢼⠔⠁⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    │⣇⣔⣁⣑⣄⣇⣀⣀⣑⣄⣇⣔⣁⣀⣀⣇⣔⣁⣑⣄⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n    └────────────────────────────────────────┘ \n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.09\n END\t---------\t8.245e-15\t0.00\t0.00\t0.01\t\t0.85\t1.60\t2.46\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t2.54\n\n\t ndof =  1007\n@time  solver =  0.007543 seconds (2.49 k allocations: 2.636 MiB)\n@time  η eval =  0.003649 seconds (12.32 k allocations: 645.852 KiB)\n@time  e eval =  0.004755 seconds (470 allocations: 42.750 KiB)\n@time  refine =  0.000187 seconds (95 allocations: 127.891 KiB)\n\t    η =  0.0381871224836708\n\t    e =  0.004524743867373229\n------- LEVEL 11\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.12\n END\t---------\t1.046e-14\t0.01\t0.01\t0.01\t\t1.30\t2.36\t3.66\n\tfinished\t\t\t\tSUM -->\t0.01\t\t\tSUM -->\t3.78\n\n\t ndof =  1549\n@time  solver =  0.011117 seconds (2.75 k allocations: 3.929 MiB)\n@time  η eval =  0.005400 seconds (20.65 k allocations: 982.367 KiB)\n@time  e eval =  0.007193 seconds (472 allocations: 48.938 KiB)\n@time  refine =  0.000256 seconds (109 allocations: 156.094 KiB)\n\t    η =  0.025276908432074842\n\t    e =  0.002998068228097714\n------- LEVEL 12\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.17\n END\t---------\t1.229e-14\t0.01\t0.03\t0.04\t\t1.32\t3.44\t4.76\n\tfinished\t\t\t\tSUM -->\t0.04\t\t\tSUM -->\t4.93\n\n\t ndof =  2295\n@time  solver =  0.036815 seconds (3.05 k allocations: 5.112 MiB, 54.90% gc time)\n@time  η eval =  0.008198 seconds (32.32 k allocations: 1.427 MiB)\n@time  e eval =  0.010919 seconds (472 allocations: 57.625 KiB)\n@time  refine =  0.000383 seconds (104 allocations: 228.047 KiB)\n\t    η =  0.01709211530104225\n\t    e =  0.0020104230857149736\n------- LEVEL 13\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.25\n END\t---------\t1.560e-14\t0.01\t0.01\t0.02\t\t1.97\t5.29\t7.27\n\tfinished\t\t\t\tSUM -->\t0.02\t\t\tSUM -->\t7.51\n\n\t ndof =  3497\n@time  solver =  0.024332 seconds (3.72 k allocations: 7.815 MiB)\n@time  η eval =  0.011387 seconds (51.01 k allocations: 2.171 MiB)\n@time  e eval =  0.016298 seconds (472 allocations: 71.438 KiB)\n@time  refine =  0.000540 seconds (127 allocations: 357.109 KiB)\n\t    η =  0.011328829368444024\n\t    e =  0.001318771126224443\n------- LEVEL 14\n #IT\t------- RESIDUALS -------\t---- DURATION (s) ----\t\t---- ALLOCATIONS (MiB) ----\n   \tNONLINEAR\tLINEAR\t\tASSEMB\tSOLVE\tTOTAL\t\tASSEMB\tSOLVE\tTOTAL\n INI\t\t\t\t\t\t\t0.00\t\t\t\t0.36\n END\t---------\t1.921e-14\t0.02\t0.02\t0.03\t\t2.72\t7.41\t10.13\n\tfinished\t\t\t\tSUM -->\t0.03\t\t\tSUM -->\t10.49\n\n\t ndof =  5242\n@time  solver =  0.034981 seconds (4.60 k allocations: 10.870 MiB)\n@time  η eval =  0.016050 seconds (78.17 k allocations: 3.282 MiB)\n@time  e eval =  0.024390 seconds (472 allocations: 91.562 KiB)\n\n    ndofs   |   || u - u_h ||    order | || ∇(u - u_h) ||   order |         η          order |\n============|==========================|==========================|==========================|\n        65  |     8.809e-03      0.00  |     1.209e-01      0.00  |     1.014e+00      0.00  |\n        85  |     4.021e-03      5.85  |     7.213e-02      3.85  |     6.070e-01      3.82  |\n       111  |     1.821e-03      5.94  |     4.823e-02      3.02  |     4.068e-01      3.00  |\n       137  |     1.173e-03      4.18  |     3.448e-02      3.19  |     2.922e-01      3.14  |\n       163  |     1.019e-03      1.62  |     2.718e-02      2.74  |     2.318e-01      2.66  |\n       225  |     6.199e-04      3.08  |     2.013e-02      1.86  |     1.652e-01      2.10  |\n       315  |     3.593e-04      3.24  |     1.424e-02      2.06  |     1.163e-01      2.09  |\n       451  |     2.276e-04      2.55  |     9.891e-03      2.03  |     8.248e-02      1.91  |\n       666  |     1.276e-04      2.97  |     6.812e-03      1.91  |     5.717e-02      1.88  |\n      1007  |     7.500e-05      2.57  |     4.525e-03      1.98  |     3.819e-02      1.95  |\n      1549  |     3.177e-05      3.99  |     2.998e-03      1.91  |     2.528e-02      1.92  |\n      2295  |     2.082e-05      2.15  |     2.010e-03      2.03  |     1.709e-02      1.99  |\n      3497  |     1.068e-05      3.17  |     1.319e-03      2.00  |     1.133e-02      1.95  |\n      5242  |     5.317e-06      3.45  |     8.757e-04      2.02  |     7.565e-03      1.99  |","category":"page"},{"location":"examples/Example210_LshapeAdaptivePoissonProblem/","page":"210 : Poisson L-shape Adaptive Mesh Refinement","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"(Image: )","category":"page"}]
}
