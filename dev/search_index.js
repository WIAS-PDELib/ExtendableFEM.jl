var documenterSearchIndex = {"docs":
[{"location":"module_examples/Example220_ReactionConvectionDiffusion/#220-:-Reaction-Convection-Diffusion-Problem","page":"Example220_ReactionConvectionDiffusion","title":"220 : Reaction-Convection-Diffusion-Problem","text":"","category":"section"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"(source code)","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"-nu Delta u + mathbfbeta cdot nabla u + alpha u = f quad textin  Omega","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta, some scalar-valued function alpha and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"We prescribe an analytic solution with mathbfbeta = (10) and alpha = 01 and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"(Image: )","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"module Example220_ReactionConvectionDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\nconst α = 0.01\nconst β = [1.0, 0]\nconst ν = 1e-5\n\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[1] * x[2] * (x[1] - 1) * (x[2] - 1) + x[1]\nend\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[2] * (2 * x[1] - 1) * (x[2] - 1) + 1\n\tresult[2] = x[1] * (2 * x[2] - 1) * (x[1] - 1)\nend\nfunction Δu!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = 2 * (x[2] * (x[2] - 1) + x[1] * (x[1] - 1))\nend\n\nfunction rhs()\n\t∇u = zeros(Float64, 2)\n\tΔu = zeros(Float64, 1)\n\tu = zeros(Float64, 1)\n\tfunction closure(result, qpinfo)\n\t\t∇u!(∇u, qpinfo)\n\t\tu!(u, qpinfo)\n\t\tΔu!(Δu, qpinfo)\n\t\tresult[1] = -ν * Δu[1] + α * u[1] + dot(β, ∇u)\n\tend\nend\n\nfunction kernel_DCR!(result, input, qpinfo)\n\tu, ∇u = view(input, 1), view(input, 2:3)\n\tresult[1] = α * u[1] + dot(β, ∇u)\n\tresult[2] = ν * ∇u[1]\n\tresult[3] = ν * ∇u[2]\n\treturn nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# stab_kernel!\nfunction stab_kernel!(result, ∇u, qpinfo)\n\tresult .= ∇u .* qpinfo.volume^2\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, τ = 1e-2, nlevels = 5, order = 2, kwargs...)\n\n\t# create problem description\n\tPD = ProblemDescription(\"reaction-convection-diffusion problem\")\n\tu = Unknown(\"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator(kernel_DCR!, [id(u), grad(u)]; bonus_quadorder = 1, kwargs...))\n\tassign_operator!(PD, LinearOperator(rhs(), [id(u)]; bonus_quadorder = 2, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4, kwargs...))\n\n\t# add a gradient jump (interior penalty) stabilisation for dominant convection\n\tif τ > 0\n\t\tassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = τ))\n\tend\n\n\t# prepare error calculation\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n\tResults = zeros(Float64, nlevels, 4)\n\tNDofs = zeros(Int, nlevels)\n\n\t# refinement loop over levels\n\tsol = nothing\n\txgrid = grid_unitsquare(Triangle2D) # initial grid\n\tfor level ∈ 1:nlevels\n\t\t# uniform mesh refinement\n\t\txgrid = uniform_refine(xgrid)\n\n\t\t# generate FESpace and solve\n\t\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\t\tsol = solve(PD, FES)\n\n\t\t# compute L2 and H1 errors and save data\n\t\tNDofs[level] = length(sol.entries)\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tResults[level, 1] = sqrt(sum(view(error, 1, :)))\n\t\tResults[level, 3] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\n\t\t# interpolate (just for comparison)\n\t\tI = FEVector(FES)\n\t\tinterpolate!(I[1], u!)\n\t\terror = evaluate(ErrorIntegratorExact, I)\n\t\tResults[level, 2] = sqrt(sum(view(error, 1, :)))\n\t\tResults[level, 4] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\tend\n\n\t# plot\n\tplt = plot([id(u), grad(u)], sol; add = 1, ncols = 3, Plotter = Plotter)\n\tplot_convergencehistory!(plt[1,3], NDofs, Results; add_h_powers = [order, order + 1], X_to_h = X -> X .^ (-1 / 2), legend = :lb, ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"], limits = (1e-8, 1e-1))\n\n\t# print convergence history\n\tprint_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\n\n\treturn Results, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/#225-:-Obstacle-Problem","page":"Example225_ObstacleProblem","title":"225 : Obstacle Problem","text":"","category":"section"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"This example computes the solution u of the nonlinear obstacle problem that seeks the minimiser of the energy functional","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tE(u) = frac12 int_Omega lvert nabla u rvert^2 dx - int_Omega f u dx\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"with some right-hand side f within the set of admissible functions that lie above an obstacle  chi","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tmathcalK = lbrace u in H^1_0(Omega)  u geq chi rbrace\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"The obstacle constraint is realised via a penalty term","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tfrac1epsilon  min(0 u - chi) ^2_L^2\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"that is added to the energy above and is automatically differentiated for a Newton scheme. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"module Example225_ObstacleProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define obstacle and penalty kernel\nconst χ! = (result, x) -> (result[1] = (cos(4 * x[1] * π) * cos(4 * x[2] * π) - 1) / 20)\nfunction obstacle_penalty_kernel!(result, input, qpinfo)\n\tχ!(result, qpinfo.x) # eval obstacle\n\tresult[1] = min(0, input[1] - result[1])\n\treturn nothing\nend\n\nfunction main(; Plotter = nothing, ϵ = 1e-4, nrefs = 6, order = 1, kwargs...)\n\n\t# choose initial mesh\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(obstacle_penalty_kernel!, [id(u)]; factor = 1 / ϵ, kwargs...))\n\tassign_operator!(PD, BilinearOperator([grad(u)]; kwargs...))\n\tassign_operator!(PD, LinearOperator([id(u)]; factor = -1, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n\n\t# create finite element space\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplt = plot([id(u), grad(u)], sol; Plotter = Plotter, ncols = 3)\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/#108-:-Robin-Boundary-Condition","page":"Example108_RobinBoundaryCondition","title":"108 : Robin Boundary Condition","text":"","category":"section"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"(source code)","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"This demonstrates the assignment of a mixed Robin boundary condition for a nonlinear 1D convection-diffusion-reaction PDE on the unit interval, i.e.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"beginaligned\n-partial^2 u  partial x^2 + u partial u  partial x + u  = f  textin  Omega\nu + partial u  partial_x  = g  textat  Gamma_1 =  0 \nu  = u_D  textat  Gamma_2 =  1 \nendaligned","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"tested with data f(x) = e^2x, g = 2 and u_D = e such that u(x) = e^x is the exact solution.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"(Image: )","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"module Example108_RobinBoundaryCondition\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\n\n# data and exact solution\nfunction f!(result, qpinfo)\n\tresult[1] = exp(2 * qpinfo.x[1])\nend\nfunction u!(result, qpinfo)\n\tresult[1] = exp(qpinfo.x[1])\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion oeprator\nfunction nonlinear_kernel!(result, input, qpinfo)\n\tu, ∇u = input[1], input[2]\n\tresult[1] = u * ∇u + u \t# convection + reaction (will be multiplied with v)\n\tresult[2] = ∇u         \t# diffusion (will be multiplied with ∇v)\n\treturn nothing\nend\n\n# kernel for Robin boundary condition\nfunction robin_kernel!(result, input, qpinfo)\n\tresult[1] = 2 - input[1] # = g - u (will be multiplied with v)\n\treturn nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 1e-1, h_fine = 1e-3, order = 2, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; kwargs...))\n\tassign_operator!(PD, BilinearOperator(robin_kernel!, [id(u)]; entities = ON_BFACES, regions = [1], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = [2], kwargs...))\n\n\t# generate coarse and fine mesh\n\txgrid = simplexgrid(0:h:1)\n\n\t# choose finite element type and generate FESpace\n\tFEType = H1Pk{1, 1, order}\n\tFES = FESpace{FEType}(xgrid)\n\n\t# generate a solution vector and solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot discrete and exact solution (on finer grid)\n\tplt = GridVisualizer(Plotter = Plotter, layout = (1, 1))\n\tscalarplot!(plt[1, 1], id(u), sol; color = :black, label = \"u_h\", markershape = :circle, markersize = 10, markevery = 1)\n\txgrid_fine = simplexgrid(0:h_fine:1)\n\tscalarplot!(plt[1, 1], xgrid_fine, view(nodevalues(xgrid_fine, u!), 1, :), clear = false, color = (1, 0, 0), label = \"u\", legend = :rb, markershape = :none)\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"linearoperator/#LinearOperator","page":"LinearOperator","title":"LinearOperator","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"A linear operator allows to add vectors to the right-hand side of the system that usually refer to right-hand side data or linearisations of PDE operators (see remark in NonlinearOperator example). If the linear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluate more than the degrees of freedom on the face) there is the possibility to use LinearOperatorDG. It is also possible to assign a vector assembled by the user as a LinearOperator.","category":"page"},{"location":"linearoperator/#Constructors","page":"LinearOperator","title":"Constructors","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Vector{<:Union{Int64, Unknown}}, Vector{<:Union{Int64, Unknown}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tA,\n\tu_test,\n\tu_args;\n\tkwargs...)\n\nGenerates a linear form from a user-provided matrix A, which can be an AbstractMatrix or a FEMatrix with multiple blocks. The arguments uargs specify which coefficients of the current solution should be multiplied with the matrix and utest specifies where to put the (blocks of the) resulting vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Any}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tb,\n\tu_test;\n\tkwargs...)\n\nGenerates a linear form from a user-provided vector b, which can be an AbstractVector or a FEVector with multiple blocks. The argument u_test specifies where to put the (blocks of the) vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tkernel!::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: LinearOperator(kernel!, [id(1)]; kwargs...) generates the right-hand side for a Poisson problem, where kernel! evaluates the right-hand side.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#Example-right-hand-side","page":"LinearOperator","title":"Example - right-hand side","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"For a right-hand side operator of a Poisson problem with some given function f(x) a kernel could look like","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"function kernel!(result, qpinfo)\n    result[1] = f(qpinfo.x)\nend","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"and the coressponding LinearOperator constructor call reads","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"u = Unknown(\"u\")\nNonlinearOperator(kernel!, [id(u)])","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"The second argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the test function.","category":"page"},{"location":"linearoperator/#LinearOperatorDG","page":"LinearOperator","title":"LinearOperatorDG","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"LinearOperatorDG is intended for linear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the (discontinous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the (discontinuous) operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nKeyword arguments:\n\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example310_DivFreeBasis/#310-:-Div-free-RT0-basis","page":"Example310_DivFreeBasis","title":"310 : Div-free RT0 basis","text":"","category":"section"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"(source code)","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"This example computes the best-approximation mathbfpsi_h of a divergence-free velocity mathbfu = mathrmcurl mathbfpsi by solving for a curl-potential mathbfphi_h in N_0 with","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"beginaligned\n(mathrmcurl mathbfphi_h mathrmcurl mathbftheta_h)  = (mathbfu mathrmcurl mathbftheta_h) quad textfor all  mathbftheta in N_0\nendaligned","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"Here, N_0 denotes the lowest-order Nedelec space which renders the problem ill-posed unless one selects a linear independent basis. This is done with the algorithm suggested in the reference below.","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"reference: Reference\n\"Decoupling three-dimensional mixed problems using divergence-free finite elements\",\nR. Scheichl,\nSIAM J. Sci. Comput. 23(5) (2002),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"(Image: )","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"module Example310_DivFreeBasis\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing Symbolics\n\n# exact data for problem generated by symbolics\nfunction prepare_data()\n\n\t@variables x y z\n\n\t# stream function ξ\n\tξ = [x*y*z,x*y*z,x*y*z]\n\n\t# velocity u = curl ξ\n\t∇ξ = Symbolics.jacobian(ξ, [x, y, z])\n\tu = [∇ξ[3,2] - ∇ξ[2,3], ∇ξ[1,3] - ∇ξ[3,1], ∇ξ[2,1] - ∇ξ[1,2]]\n\n\t# build function\n\tu_eval = build_function(u, x, y, z, expression = Val{false})\n\n\treturn u_eval[2]\nend\n\nfunction main(;\n\tnrefs = 4,                      ## number of refinement levels\n\tbonus_quadorder = 2,            ## additional quadrature order for data evaluations\n\tdivfree_basis = true,\t\t\t## if true uses curl(N0), if false uses mixed FEM RT0xP0\n\tPlotter = nothing,              ## Plotter (e.g. PyPlot)\n\tkwargs...)\n\n\t# prepare problem data\n\tu_eval = prepare_data()\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.x[3]))\n\n\t# prepare plots\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (800, 800))\n\n\t# prepare error calculation\n\tfunction exact_error!(result, u, qpinfo)\n\t\texact_u!(view(result, 1:3), qpinfo)\n\t\tresult .-= u\n\t\tresult .= result .^ 2\n\tend\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [divfree_basis ? curl3(1) : id(1)]; bonus_quadorder = 2 + bonus_quadorder, kwargs...)\n\tNDofs = zeros(Int, nrefs)\n\tL2error = zeros(Float64, nrefs)\n\n\tsol = nothing\n\tfor lvl ∈ 1:nrefs\n\t\t# grid\n\t\txgrid = uniform_refine(grid_unitcube(Tetrahedron3D), lvl)\n\n\t\tif divfree_basis\n\n\t\t\t# use Nedelec FESpace and determine linear independent basis\n\t\t\tFES = FESpace{HCURLN0{3}}(xgrid)\n\n\t\t\t@time begin\n\t\t\t\t# get subset of edges, spanning the node graph\n\t\t\t\tspanning_tree = get_spanning_edge_subset(xgrid)\n\n\t\t\t\t# get all other edges = linear independent degrees of freedom\n\t\t\t\tsubset = setdiff(1:num_edges(xgrid), spanning_tree)\n\t\t\tend\n\t\t\tNDofs[lvl] = length(subset)\n\n\t\t\t# assemble full Nedelec curl-curl problem...\n\t\t\tu = Unknown(\"u\"; name = \"curl potential of velocity\")\n\t\t\tPD = ProblemDescription(\"curl-curl formulation\")\n\t\t\tassign_unknown!(PD, u)\n\t\t\tassign_operator!(PD, BilinearOperator([curl3(u)]))\n\t\t\tassign_operator!(PD, LinearOperator(exact_u!, [curl3(u)]; bonus_quadorder = bonus_quadorder))\n\n\t\t\t# ...and solve with subset\n\t\t\tsol = solve(PD, FES; restrict_dofs = [subset[:]])\n\t\telse\n\t\t\t# use RT0 functions + side constraint for divergence\n\t\t\tFES = [FESpace{HDIVRT0{3}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n\t\t\tNDofs[lvl] = FES[1].ndofs + FES[2].ndofs\n\n\t\t\tu = Unknown(\"u\"; name = \"velocity\")\n\t\t\tp = Unknown(\"u\"; name = \"pressure\")\n\t\t\tPD = ProblemDescription(\"mixed formulation\")\n\t\t\tassign_unknown!(PD, u)\n\t\t\tassign_unknown!(PD, p)\n\t\t\tassign_operator!(PD, BilinearOperator([id(u)]))\n\t\t\tassign_operator!(PD, BilinearOperator([div(u)], [id(p)]; transposed_copy = 1))\n\t\t\tassign_operator!(PD, LinearOperator(exact_u!, [id(u)]; bonus_quadorder = bonus_quadorder))\n\t\t\tsol = solve(PD, FES)\n\t\tend\n\n\t\t# evalute error\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tL2error[lvl] = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\tif divfree_basis\n\t\t\t@info \"|| u - curl(ϕ_h) || = $(L2error[lvl])\"\n\t\telse\n\t\t\t@info \"|| u - u_h || = $(L2error[lvl])\"\n\t\tend\n\tend\n\n\t# plot\n\tif divfree_basis\n\t\tscalarplot!(plt[1, 1], curl3(1), sol; abs = true)\n\telse\n\t\tscalarplot!(plt[1, 1], id(1), sol; abs = true)\n\tend\n\n\t# print convergence history as table\n\tprint_convergencehistory(NDofs, L2error; X_to_h = X -> X .^ (-1 / 3), ylabels = [\"|| u - u_h ||\"], xlabel = \"ndof\")\n\n\treturn L2error, plt\nend\n\n\n# finds a minimal subset (of dimension #nodes - 1) of edges, such that all nodes are connected\nfunction get_spanning_edge_subset(xgrid)\n\tnnodes = num_nodes(xgrid)\n\tedgenodes = xgrid[EdgeNodes]\n\tbedgenodes = xgrid[BEdgeNodes]\n\tbedgeedges = xgrid[BEdgeEdges]\n\n\t# boolean arrays to memorize which nodes are visited\n\t# and which edges belong to the spanning tree\n\tvisited = zeros(Bool, nnodes)\n\tmarkededges = zeros(Bool, num_edges(xgrid))\n\n\tfunction find_spanning_tree(edgenodes, remap)\n\t\tnodeedges = atranspose(edgenodes)\n\t\tfunction recursive(node)\n\t\t\tvisited[node] = true\n\t\t\tnneighbors = num_targets(nodeedges, node)\n\t\t\tfor e = 1 : nneighbors\n\t\t\t\tedge = nodeedges[e, node]\n\t\t\t\tfor k = 1 : 2\n\t\t\t\t\tnode2 = edgenodes[k, edge]\n\t\t\t\t\tif !visited[node2]\n\t\t\t\t\t\t# mark edge\n\t\t\t\t\t\tmarkededges[remap[edge]] = true\n\t\t\t\t\t\trecursive(node2)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn nothing\n\t\tend\n\t\trecursive(edgenodes[1])\n\tend\n\n\t# find spanning tree for Neumann boundary\n\t# local bedges >> global edge numbers\n\tfind_spanning_tree(bedgenodes, bedgeedges)\n\n\t# find spanning tree for remaining part\n\tother_nodes = setdiff(1:nnodes, unique(view(bedgenodes,:)))\n\tif length(other_nodes) > 0\n\t\tfind_spanning_tree(edgenodes, 1 : num_edges(xgrid))\n\tend\n\n\t# return all marked edges\n\treturn findall(==(true), markededges)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdesolvers_dt/#Time-dependent-Solvers","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"For time-dependent (non-stationary) problems the user currently has these options:","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"fully manual option: add custom time derivatives to the problem (i.e. a mass matrix as a BilinearOperator and necessary LinearOperators for evaluating the previous time step(s), if more than one previous time step needs to be remembered, their memorization must be handled manually, e.g. by registering further unknowns)\nfully automatic option: reframe the ProblemDescription as an ODE problem and evolve it via DifferentialEquations with ExtendableFEMDiffEQExt.jl extension (see below)","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Several time-dependent examples are available where both options are implemented, see e.g. Examples103 (Burger's equation) and Example205 (Heat equation).","category":"page"},{"location":"pdesolvers_dt/#Extension-ExtendableFEMDiffEQExt.jl","page":"Time-dependent Solvers","title":"Extension ExtendableFEMDiffEQExt.jl","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"This extension is automatically loaded when also DifferentialEquations.jl is used. It allows to easily reframe the ProblemDescription for the spacial differential operator of the PDE as the right-hand side of an ODE. Here, the ProblemDescription contains the right-hand side description of the ODE","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"beginaligned\nM u_t(t)  = b(u(t)) - A(u(t)) u(t)\nendaligned","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"where A and b correspond to the assembled (linearized) spacial operator and the right-hand side operators in the ProblemDescription. Note, that A comes with a minus sign. The matrix M is the mass matrix and can be customized somewhat (as long as it stays constant). The operators in the ProblemDescription might depend on time (if their kernels use qpinfo.time) and will be reassembled in each time step. To avoid this single operator reassemblies can be switched off by using the store = true argument. The full matrix reassembly can be skipped if constant_matrix = true is used in the SolverConfiguration.","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Modules = [ExtendableFEM]\nPages = [\"solvers_diffeq.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tPD::ProblemDescription,\n\tFES,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into an ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nAdditional keyword arguments:\n\nverbosity: verbosity level. Default: 0\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"note: Note\nThe solvers of DifferentialEquations should be run with the autodiff=false option as it is currently not possible to differentiate the right-hand side of the generated ODEProblem with respect to time.","category":"page"},{"location":"pdesolvers_dt/#Example-:-2D-Heat-equation","page":"Time-dependent Solvers","title":"Example : 2D Heat equation","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"The following ProblemDescription yields the space discretisation of the heat equation (including homogeneous boundary conditions and equivalent to the Poisson equation).","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"PD = ProblemDescription(\"Heat Equation\")\nu = Unknown(\"u\"; name = \"temperature\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\nassign_operator!(PD, HomogeneousBoundaryData(u))","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Given a finite element space FES and an initial FEVector sol for the unknown, the ODEProblem for some time interval (0,T) can be generated and solved via","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"prob = generate_ODEProblem(PD, FES, (0, T); init = sol)\nDifferentialEquations.solve(prob, Rosenbrock23(autodiff = false), dt = 1e-3, dtmin = 1e-6, adaptive = true)","category":"page"},{"location":"postprocessing/#Other-packages","page":"Other packages","title":"Other packages","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"A lot of functionality is already provided by the bases packages, e.g.:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"ExtendableGrids.jl offers an interface to WriteVTK.jl which can be used, e.g. in combination with nodevalues interpolations or (piecewise constant) item integrator results. There is also the CellFinder that can be used to find the right cell for a certain point of the domain.\nExtendableFEMBase.jl offers a PointEvaluator and a SegmentIntegrator to evaluate solutions at arbitrary points of the domain or integrating along 1D line intersections with the cells of the triangulation. It also provides some basic unicode plots.\nGridVisualize.jl provides grid and scalar piecewise linear function plotting for various plotting backends on simplicial grids in one, two or three space dimensions. The main supported backends are PyPlot, GLMakie and PlutoVista.","category":"page"},{"location":"module_examples/Example301_PoissonProblem/#301-:-Poisson-Problem","page":"Example301_PoissonProblem","title":"301 : Poisson-Problem","text":"","category":"section"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit cube domain Omega on a given grid. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"module Example301_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2] * qpinfo.x[3]\nend\n\nfunction main(; μ = 1.0, nrefs = 3, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitcube(Tetrahedron3D), nrefs)\n\tFES = FESpace{H1P2{1, 3}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplt = plot([id(u)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interpolateboundarydata/#InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"","category":"section"},{"location":"interpolateboundarydata/","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/interpolateboundarydata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"interpolateboundarydata/#ExtendableFEM.InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"ExtendableFEM.InterpolateBoundaryData","text":"function InterpolateBoundaryData(u, data!::Function; kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to match the standard interpolation of the provided data! function. The header of this function needs to be conform to the interface\n\ndata!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x provides the global coordinates of the quadrature/evaluation point.\n\nKeyword arguments:\n\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nregions: subset of regions where operator should be assembly only. Default: Any[]\nname: name for operator used in printouts. Default: ''BoundaryData''\nbonus_quadorder: additional quadrature order added to the quadorder chosen by the interpolator. Default: 0\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\nplot: plot unicode plot of boundary data into terminal when assembled. Default: false\n\n\n\n\n\n","category":"type"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/#211-:-Poisson-L-shape-Local-Equilibrated-Fluxes","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"","category":"section"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This example computes a local equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"where sigma_h discretisates the exact sigma in the dual mixed problem","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"by some local equilibration strategy, see reference below for details.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This examples demonstrates the use of low-level structures to assemble individual problems and a strategy to solve several small problems in parallel by use of non-overlapping node patch groups.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"reference: Reference\n''A posteriori error estimates for efficiency and error control in numerical simulations'' Lecture Notes by M. Vohralik >Link<","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"The resulting mesh and error convergence history for the default parameters looks like:","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"module Example211_LshapeAdaptiveEQPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tr2 = x[1]^2 + x[2]^2\n\tφ = atan(x[2], x[1])\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\tresult[1] = r2^(1 / 3) * sin(2 * φ / 3)\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tφ = atan(x[2], x[1])\n\tr2 = x[1]^2 + x[2]^2\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\t∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n\t∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n\tresult[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n\tresult[2] = sin(φ) * ∂r + cos(φ) * ∂φ\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# kernel for equilibration error estimator\nfunction eqestimator_kernel!(result, input, qpinfo)\n\tσ_h, divσ_h, ∇u_h = view(input, 1:2), input[3], view(input, 4:5)\n\tresult[1] = norm(σ_h .- ∇u_h)^2 + divσ_h^2\n\treturn nothing\nend\n\n# unknowns for primal and dual problem\nu = Unknown(\"u\"; name = \"u\")\nσ = Unknown(\"σ\"; name = \"equilibrated fluxes / dual stress\")\n\n# everything is wrapped in a main function\nfunction main(; maxdofs = 4000, μ = 1, order = 2, nlevels = 16, θ = 0.5, Plotter = nothing, kwargs...)\n\n\t# initial grid\n\txgrid = grid_lshape(Triangle2D)\n\n\t# choose some finite elements for primal and dual problem (= for equilibrated fluxes)\n\tFEType = H1Pk{1,2,order}\n\tFETypeDual = HDIVRTk{2, order}\n\n\t# setup Poisson problem\n\tPD = ProblemDescription(\"Poisson problem\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n\t# define error estimator : || σ_h - ∇u_h ||^2 + || div σ_h ||^2\n\tEQIntegrator = ItemIntegrator(eqestimator_kernel!, [id(σ), div(σ), grad(u)]; resultdim = 1, quadorder = 2 * order)\n\n\t# setup exact error evaluations\n\tErrorIntegrator = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * order, kwargs...)\n\n\t# refinement loop (only uniform for now)\n\tNDofs = zeros(Int, 0)\n\tNDofsDual = zeros(Int, 0)\n\tResultsL2 = zeros(Float64, 0)\n\tResultsH1 = zeros(Float64, 0)\n\tResultsη = zeros(Float64, 0)\n\tsol = nothing\n\tlevel = 0\n\twhile (true)\n\t\tlevel += 1\n\n\t\t# create a solution vector and solve the problem\n\t\tFES = FESpace{FEType}(xgrid)\n\t\tsol = solve(PD, FES)\n\t\tpush!(NDofs, length(view(sol[u])))\n\t\tprintln(\"\\n  SOLVE LEVEL $level\")\n\t\tprintln(\"    ndofs = $(NDofs[end])\")\n\n\t\t# evaluate eqilibration error estimator and append it to sol vector (for plotting etc.)\n\t\tlocal_equilibration_estimator!(sol, FETypeDual)\n\t\tη4cell = evaluate(EQIntegrator, sol)\n\t\tpush!(Resultsη, sqrt(sum(view(η4cell, 1, :))))\n\n\t\t# calculate L2 error, H1 error, estimator, dual L2 error and write to results\n\t\tpush!(NDofsDual, length(view(sol[σ])))\n\t\terror = evaluate(ErrorIntegrator, sol)\n\t\tpush!(ResultsL2, sqrt(sum(view(error, 1, :))))\n\t\tpush!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n\t\tprintln(\"  ESTIMATE\")\n\t\tprintln(\"    ndofsDual = $(NDofsDual[end])\")\n\t\tprintln(\"    estim H1 error = $(Resultsη[end])\")\n\t\tprintln(\"    exact H1 error = $(ResultsH1[end])\")\n\t\tprintln(\"    exact L2 error = $(ResultsL2[end])\")\n\n\t\tif NDofs[end] >= maxdofs\n\t\t\tbreak\n\t\tend\n\n\t\t# mesh refinement\n\t\tif θ >= 1 ## uniform mesh refinement\n\t\t\txgrid = uniform_refine(xgrid)\n\t\telse ## adaptive mesh refinement\n\t\t\tfacemarker = bulk_mark(xgrid, view(η4cell, :), θ; indicator_AT = ON_CELLS)\n\t\t\txgrid = RGB_refine(xgrid, facemarker)\n\t\tend\n\tend\n\n\t# plot\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, resolution = (1000, 1000))\n\tscalarplot!(plt[1, 1], id(u), sol; levels = 11, title = \"u_h\")\n\tplot_convergencehistory!(plt[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\tgridplot!(plt[2, 1], xgrid; linewidth = 1)\n\tgridplot!(plt[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n\t# print/plot convergence history\n\tprint_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\n\treturn sol, plt\nend\n\n# this function computes the local equilibrated fluxes\n# by solving local problems on (disjunct groups of) node patches\nfunction local_equilibration_estimator!(sol, FETypeDual)\n\t# needed grid stuff\n\txgrid = sol[u].FES.xgrid\n\txCellNodes::Array{Int32, 2} = xgrid[CellNodes]\n\txCellVolumes::Array{Float64, 1} = xgrid[CellVolumes]\n\txNodeCells::Adjacency{Int32} = atranspose(xCellNodes)\n\tnnodes::Int = num_sources(xNodeCells)\n\n\t# get node patch groups that can be solved in parallel\n\tgroup4node = xgrid[NodePatchGroups]\n\n\t# init equilibration space (and Lagrange multiplier space)\n\tFESDual = FESpace{FETypeDual}(xgrid)\n\txItemDofs::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = FESDual[CellDofs]\n\txItemDofs_uh::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = sol[u].FES[CellDofs]\n\n\t# append block in solution vector for equilibrated fluxes\n\tappend!(sol, FESDual; tag = σ)\n\n\t# partition of unity and their gradients = P1 basis functions\n\tPOUFES = FESpace{H1P1{1}}(xgrid)\n\tPOUqf = QuadratureRule{Float64, Triangle2D}(0)\n\n\t# quadrature formulas\n\tqf = QuadratureRule{Float64, Triangle2D}(2 * get_polynomialorder(FETypeDual, Triangle2D))\n\tweights::Array{Float64, 1} = qf.w\n\n\t# some constants\n\toffset::Int = sol[u].offset\n\tdiv_penalty::Float64 = 1e5      # divergence constraint is realized by penalisation\n\tbnd_penalty::Float64 = 1e60     # penalty for non-involved dofs of a group\n\tmaxdofs::Int = max_num_targets_per_source(xItemDofs)\n\tmaxdofs_uh::Int = max_num_targets_per_source(xItemDofs_uh)\n\n\t# redistribute groups for more equilibrated thread load (first groups are larger)\n\tmaxgroups = maximum(group4node)\n\tgroups = Array{Int, 1}(1:maxgroups)\n\tfor j::Int ∈ 1:floor(maxgroups / 2)\n\t\ta = groups[j]\n\t\tgroups[j] = groups[2*j]\n\t\tgroups[2*j] = a\n\tend\n\tX = Array{Array{Float64, 1}, 1}(undef, maxgroups)\n\n\tfunction solve_patchgroup!(group)\n\t\t# temporary variables\n\t\tgraduh = zeros(Float64, 2)\n\t\tcoeffs_uh = zeros(Float64, maxdofs_uh)\n\t\tAlocal = zeros(Float64, maxdofs, maxdofs)\n\t\tblocal = zeros(Float64, maxdofs)\n\n\t\t# init system\n\t\tA = ExtendableSparseMatrix{Float64, Int64}(FESDual.ndofs, FESDual.ndofs)\n\t\tb = zeros(Float64, FESDual.ndofs)\n\n\t\t# init FEBasiEvaluators\n\t\tFEE_∇φ = FEEvaluator(POUFES, Gradient, POUqf)\n\t\tFEE_xref = FEEvaluator(POUFES, Identity, qf)\n\t\tFEE_∇u = FEEvaluator(sol[u].FES, Gradient, qf)\n\t\tFEE_div = FEEvaluator(FESDual, Divergence, qf)\n\t\tFEE_id = FEEvaluator(FESDual, Identity, qf)\n\t\tidvals = FEE_id.cvals\n\t\tdivvals = FEE_div.cvals\n\t\txref_vals = FEE_xref.cvals\n\t\t∇φvals = FEE_∇φ.cvals\n\n\t\t# find dofs at boundary of current node patches\n\t\t# and in interior of cells outside of current node patch group\n\t\tis_noninvolveddof = zeros(Bool, FESDual.ndofs)\n\t\toutside_cell::Bool = false\n\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\toutside_cell = true\n\t\t\tfor k ∈ 1:3\n\t\t\t\tif group4node[xCellNodes[k, cell]] == group\n\t\t\t\t\toutside_cell = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tif (outside_cell) # mark interior dofs of outside cell\n\t\t\t\tfor j ∈ 1:maxdofs\n\t\t\t\t\tis_noninvolveddof[xItemDofs[j, cell]] = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tfor node ∈ 1:nnodes\n\t\t\tif group4node[node] == group\n\t\t\t\tfor c ∈ 1:num_targets(xNodeCells, node)\n\t\t\t\t\tcell = xNodeCells[c, node]\n\n\t\t\t\t\t# find local node number of global node z\n\t\t\t\t\t# and evaluate (constant) gradient of nodal basis function phi_z\n\t\t\t\t\tlocalnode = 1\n\t\t\t\t\twhile xCellNodes[localnode, cell] != node\n\t\t\t\t\t\tlocalnode += 1\n\t\t\t\t\tend\n\t\t\t\t\tFEE_∇φ.citem[] = cell\n\t\t\t\t\tupdate_basis!(FEE_∇φ)\n\n\t\t\t\t\t# read coefficients for discrete flux\n\t\t\t\t\tfor j ∈ 1:maxdofs_uh\n\t\t\t\t\t\tcoeffs_uh[j] = sol.entries[offset + xItemDofs_uh[j, cell]]\n\t\t\t\t\tend\n\n\t\t\t\t\t# update other FE evaluators\n\t\t\t\t\tFEE_∇u.citem[] = cell\n\t\t\t\t\tFEE_div.citem[] = cell\n\t\t\t\t\tFEE_id.citem[] = cell\n\t\t\t\t\tupdate_basis!(FEE_∇u)\n\t\t\t\t\tupdate_basis!(FEE_div)\n\t\t\t\t\tupdate_basis!(FEE_id)\n\n\t\t\t\t\t# assembly on this cell\n\t\t\t\t\tfor i in eachindex(weights)\n\t\t\t\t\t\tweight = weights[i] * xCellVolumes[cell]\n\n\t\t\t\t\t\t# evaluate grad(u_h) and nodal basis function at quadrature point\n\t\t\t\t\t\tfill!(graduh, 0)\n\t\t\t\t\t\teval_febe!(graduh, FEE_∇u, coeffs_uh, i)\n\n\t\t\t\t\t\t# compute residual -f*phi_z + grad(u_h) * grad(phi_z) at quadrature point i ( f = 0 in this example !!! )\n\t\t\t\t\t\ttemp2 = div_penalty * sqrt(xCellVolumes[cell]) * weight\n\t\t\t\t\t\ttemp = temp2 * dot(graduh, view(∇φvals,:,localnode,1))\n\t\t\t\t\t\tfor dof_i ∈ 1:maxdofs\n\t\t\t\t\t\t\t# right-hand side for best-approximation (grad(u_h)*phi)\n\t\t\t\t\t\t\tblocal[dof_i] += dot(graduh, view(idvals,:,dof_i, i)) * xref_vals[1, localnode, i] * weight\n\t\t\t\t\t\t\t# mass matrix Hdiv\n\t\t\t\t\t\t\tfor dof_j ∈ dof_i:maxdofs\n\t\t\t\t\t\t\t\tAlocal[dof_i, dof_j] += dot(view(idvals,:,dof_i, i), view(idvals,:,dof_j, i)) * weight\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t# div-div matrix Hdiv * penalty (quick and dirty to avoid Lagrange multiplier)\n\t\t\t\t\t\t\tblocal[dof_i] += temp * divvals[1,dof_i,i]\n\t\t\t\t\t\t\ttemp3 = temp2 * divvals[1,dof_i,i]\n\t\t\t\t\t\t\tfor dof_j ∈ dof_i:maxdofs\n\t\t\t\t\t\t\t\tAlocal[dof_i, dof_j] += temp3 * divvals[1,dof_j,i]\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# write into global A and b\n\t\t\t\t\tfor dof_i ∈ 1:maxdofs\n\t\t\t\t\t\tdofi = xItemDofs[dof_i, cell]\n\t\t\t\t\t\tb[dofi] += blocal[dof_i]\n\t\t\t\t\t\tfor dof_j ∈ 1:maxdofs\n\t\t\t\t\t\t\tdofj = xItemDofs[dof_j, cell]\n\t\t\t\t\t\t\tif dof_j < dof_i # use that Alocal is symmetric\n\t\t\t\t\t\t\t\t_addnz(A, dofi, dofj, Alocal[dof_j, dof_i], 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t_addnz(A, dofi, dofj, Alocal[dof_i, dof_j], 1)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# reset local A and b\n\t\t\t\t\tfill!(Alocal, 0)\n\t\t\t\t\tfill!(blocal, 0)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t# penalize dofs that are not involved\n\t\tfor j ∈ 1:FESDual.ndofs\n\t\t\tif is_noninvolveddof[j]\n\t\t\t\tA[j, j] = bnd_penalty\n\t\t\t\tb[j] = 0\n\t\t\tend\n\t\tend\n\n\t\t# solve local problem\n\t\treturn A \\ b\n\tend\n\n\t# solve equilibration problems on vertex patches (in parallel)\n\tThreads.@threads for group in groups\n\t\tgrouptime = @elapsed begin\n\t\t\t@info \"  Starting equilibrating patch group $group on thread $(Threads.threadid())... \"\n\t\t\tX[group] = solve_patchgroup!(group)\n\t\tend\n\t\t@info \"Finished equilibration patch group $group on thread $(Threads.threadid()) in $(grouptime)s \"\n\tend\n\n\t# write local solutions to global vector (sequentially)\n\tfor group ∈ 1:maxgroups\n\t\tview(sol[σ]) .+= X[group]\n\tend\nend\n\nend","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/#245-:-Flow-around-a-cylinder","page":"Example245_NSEFlowAroundCylinder","title":"245 : Flow around a cylinder","text":"","category":"section"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(source code)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This example solves the DFG Navier-Stokes benchmark problem","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"on a rectangular 2D domain with a circular obstacle, see here for details.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This script demonstrates the employment of external grid generators and the computation of drag and lift coefficients.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"Note: This example needs the additional packages Triangulate and SimplexGridFactory to generate the mesh.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(Image: )","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"module Example245_NSEFlowAroundCylinder\n\nusing ExtendableFEM\nusing Triangulate\nusing SimplexGridFactory\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\n# inlet data for Karman vortex street example\n# as in DFG benchmark 2D-1 (Re = 20, laminar)\nconst umax = 0.3\nconst umean = 2 // 3 * umax\nconst L, W, H = 0.1, 2.2, 0.41\nfunction inflow!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = 4 * umax * x[2] * (H - x[2]) / (H * H)\n\tresult[2] = 0.0\nend\n\n# hand constructed identity matrix for kernel to avoid allocations\nconst II = [1 0; 0 1]\n\n\n# Example of a kernel using tensor_view() function to allow for an operator\n# based style of writing the semilinear form.\n# For comparison we also provide the kernel_nonlinear_flat! function below\n# that uses a component-wise style of writing the semilinear form.\n\n#\n# the scalar product ``(\\nabla v, \\mu \\nabla u - p)`` will be evaluated\n# so in general `a = b` corresponds to ``(a,b)``.\n\n# Note that the order of vector entries between the kernel and the call to\n# NonlinearOperator have to match.\nfunction kernel_nonlinear!(result, u_ops, qpinfo)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"Shape values of vectorial u are starting at index 1 view as 1-tensor(vector) of length dim=2 in 2D","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    u = tensor_view(u_ops, 1, TDVector(2))\n    v = tensor_view(result, 1, TDVector(2))","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"gradients of vectorial u are starting at index 3 view as 2-tensor of size 2x2 in 2D","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    ∇u = tensor_view(u_ops, 3, TDMatrix(2))\n    ∇v = tensor_view(result, 3, TDMatrix(2))","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"values of scalar p are starting at index 7 view as 0-tensor (single value)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    p = tensor_view(u_ops, 7, TDScalar())\n    q = tensor_view(result, 7, TDScalar())","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"get viscosity at current quadrature point","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    μ = qpinfo.params[1]","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"Note that all operators should be element-wise to avoid allocations (v,u⋅∇u) = (v,∇u^T⋅u)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    tmul!(v,∇u,u)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(∇v,μ∇u-p)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    ∇v .= μ .* ∇u .- p[1] .* II","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(q,-∇⋅u)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"    q[1] = -dot(∇u, II)\n    return nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1e-3, maxvol = 1e-3, reconstruct = true, kwargs...)\n\n\t# load grid (see function below)\n\txgrid = make_grid(W, H; n = Int(ceil(sqrt(1 / maxvol))), maxvol = maxvol)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tid_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, inflow!; regions = 4))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 3, 5]))\n\n\t# P2-bubble + reconstruction operator\n\tFETypes = [H1P2B{2, 2}, H1P1{1}]\n\n\t# generate FESpaces and Solution vector\n\tFES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n\n\t# solve\n\tsol = solve(PD, FES; maxiterations = 50, target_residual = 1e-10)\n\n\t# postprocess : compute drag/lift (see function below)\n\tdraglift = get_draglift(sol, μ)\n\tpdiff = get_pressure_difference(sol)\n\tprintln(\"[drag, lift] = $draglift\")\n\tprintln(\"p difference = $pdiff\")\n\n\t# plots via GridVisualize\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (4, 1), clear = true, size = (800, 1200))\n\tgridplot!(plt[1, 1], xgrid, linewidth = 1)\n\tgridplot!(plt[2, 1], xgrid, linewidth = 1, xlimits = [0, 0.3], ylimits = [0.1, 0.3])\n\tscalarplot!(plt[3, 1], xgrid, nodevalues(sol[u]; abs = true)[1, :])\n\tvectorplot!(plt[3, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), spacing = (0.2, 0.05), vscale = 0.5, clear = false)\n\tscalarplot!(plt[4, 1], xgrid, view(nodevalues(sol[p]), 1, :), levels = 11, title = \"p_h\")\n\n\treturn [draglift[1], draglift[2], pdiff[1]], plt\nend\n\nfunction get_pressure_difference(sol::FEVector)\n\txgrid = sol[2].FES.xgrid\n\tPE = PointEvaluator([id(2)], sol)\n\tp_left = zeros(Float64, 1)\n\tx1 = [0.15, 0.2]\n\tp_right = zeros(Float64, 1)\n\tx2 = [0.25, 0.2]\n\tevaluate!(p_left, PE, x1)\n\tevaluate!(p_right, PE, x2)\n\t@show p_left, p_right\n\treturn p_left - p_right\nend\n\nfunction get_draglift(sol::FEVector, μ)\n\n\t# this function is interpolated for drag/lift test function creation\n\tfunction DL_testfunction(component)\n\t\tfunction closure(result, qpinfo)\n\t\t\tx = qpinfo.x\n\t\t\tfill!(result, 0)\n\t\t\tif sqrt((x[1] - 0.2)^2 + (x[2] - 0.2)^2) <= 0.06\n\t\t\t\tresult[component] = 1\n\t\t\tend\n\t\tend\n\tend\n\n\t# drag lift calcuation by testfunctions\n\tfunction draglift_kernel(result, input, qpinfo)\n\t\t# input = [ u, grad(u), p , v , grad(v)]\n\t\t#         [1:2,  3:6,   7 ,8:9,  10:13 ]\n\t\tresult[1] = μ * (input[3] * input[10] + input[4] * input[11] + input[5] * input[12] + input[6] * input[13])\n\t\tresult[1] += (input[1] * input[3] + input[2] * input[4]) * input[8]\n\t\tresult[1] += (input[1] * input[5] + input[2] * input[6]) * input[9]\n\t\tresult[1] -= input[7] * (input[10] + input[13])\n\t\tresult[1] *= -(2 / (umean^2 * L))\n\t\treturn nothing\n\tend\n\tDLIntegrator = ItemIntegrator(draglift_kernel, [id(1), grad(1), id(2), id(3), grad(3)]; quadorder = 4)\n\n\t# test for drag\n\tTestFunction = FEVector(sol[1].FES; name = \"drag/lift testfunction\")\n\tinterpolate!(TestFunction[1], ON_BFACES, DL_testfunction(1))\n\tdrag = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n\t# test for lift\n\tinterpolate!(TestFunction[1], ON_BFACES, DL_testfunction(2))\n\tlift = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n\treturn [drag, lift]\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(W, H; n = 20, maxvol = 0.1)\n\tbuilder = SimplexGridBuilder(Generator = Triangulate)\n\tfunction circlehole!(builder, center, radius; n = 20)\n\t\tpoints = [point!(builder, center[1] + radius * sin(t), center[2] + radius * cos(t)) for t in range(0, 2π, length = n)]\n\t\tfor i ∈ 1:n-1\n\t\t\tfacet!(builder, points[i], points[i+1])\n\t\tend\n\t\tfacet!(builder, points[end], points[1])\n\t\tholepoint!(builder, center)\n\tend\n\tp1 = point!(builder, 0, 0)\n\tp2 = point!(builder, W, 0)\n\tp3 = point!(builder, W, H)\n\tp4 = point!(builder, 0, H)\n\n\t# heuristic refinement around cylinder\n\trefine_radius = 0.25\n\tmaxrefinefactor = 1 // 20\n\tfunction unsuitable(x1, y1, x2, y2, x3, y3, area)\n\t\tif area > maxvol * min(max(4 * maxrefinefactor, abs((x1 + x2 + x3) / 3 - 0.2)), 1 / maxrefinefactor)\n\t\t\treturn true\n\t\tend\n\t\tdist = sqrt(((x1 + x2 + x3) / 3 - 0.2)^2 + ((y1 + y2 + y3) / 3 - 0.2)^2) - 0.05\n\t\tmyarea = dist < refine_radius ? maxvol * max(maxrefinefactor, 1 - (refine_radius - dist) / refine_radius) : maxvol\n\t\tif area > myarea\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\n\tfacetregion!(builder, 1)\n\tfacet!(builder, p1, p2)\n\tfacetregion!(builder, 2)\n\tfacet!(builder, p2, p3)\n\tfacetregion!(builder, 3)\n\tfacet!(builder, p3, p4)\n\tfacetregion!(builder, 4)\n\tfacet!(builder, p4, p1)\n\tfacetregion!(builder, 5)\n\tcirclehole!(builder, (0.2, 0.2), 0.05, n = n)\n\n\tsimplexgrid(builder, maxvolume = 16 * maxvol, unsuitable = unsuitable)\nend\n\nend","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example205_HeatEquation/#205-:-Heat-equation","page":"Example205_HeatEquation","title":"205 : Heat equation","text":"","category":"section"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"This example computes the solution u of the two-dimensional heat equation","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"beginaligned\nu_t - Delta u  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"for homogeneous Dirichlet boundary conditions and some given initial state on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"The initial condition and the final solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"module Example205_HeatEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\n\n# initial state u at time t0\nfunction initial_data!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = exp(-5 * x[1]^2 - 5 * x[2]^2)\nend\n\nfunction main(; nrefs = 4, T = 2.0, τ = 1e-3, order = 2, use_diffeq = true,\n\tsolver = ImplicitEuler(autodiff = false), Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Heat Equation\")\n\tu = Unknown(\"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n\t# prepare solution vector and initial data u0\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], initial_data!; bonus_quadorder = 5)\n\n\t# init plotter and plot u0\n\tplt = plot([id(u)], sol; add = 1, Plotter = Plotter, title_add = \" (t = 0)\")\n\n\tif (use_diffeq)\n\t\t# generate DifferentialEquations.ODEProblem\n\t\tprob = generate_ODEProblem(PD, FES, (0.0, T); init = sol, constant_matrix = true)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-6, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tM = FEMatrix(FES)\n\t\tassemble!(M, BilinearOperator([id(1)]))\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, constant_matrix = true, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor(T / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state\n\tplot!(plt, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/#280-:-Compressible-Stokes","page":"Example280_CompressibleStokes","title":"280 : Compressible Stokes","text":"","category":"section"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"(source code)","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This example solves the two-dimensional compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"Here, eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"There are two testcases. The first testcase solves an analytical toy problem with the prescribed solution","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = exp(-yc) \np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. The second testcase tests an analytical nonzero velocity benchmark problem with the same density.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This example is designed to study the well-balanced property of a discretisation. The gradient-robust discretisation approximates the well-balanced state much better, i.e. has a much smaller L2 velocity error. For larger c (= smaller Mach number) the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. See reference below for more details.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"(Image: )","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"module Example280_CompressibleStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Triangulate\nusing SimplexGridFactory\nusing GridVisualize\nusing Symbolics\nusing LinearAlgebra\n\n# everything is wrapped in a main function\n# testcase = 1 : well-balanced test (stratified no-flow over mountain)\n# testcase = 2 : vortex example (ϱu is div-free p7 vortex)\nfunction main(;\n    testcase = 1,\n    nrefs = 4,\n    M = 1,\n    c = 1,\n    ufac = 100,\n    pressure_stab = 0,\n    laplacian_in_rhs = false, # for data in example 2\n    maxsteps = 5000,\n    target_residual = 1e-11,\n    Plotter = nothing,\n    reconstruct = true,\n    μ = 1,\n    order = 1,\n    kwargs...)\n\n\t# load data for testcase\n    grid_builder, kernel_gravity!, kernel_rhs!, u!, ∇u!, ϱ!, τfac = load_testcase_data(testcase; laplacian_in_rhs = laplacian_in_rhs, M = M, c = c, μ = μ, ufac = ufac)\n    xgrid = grid_builder(nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    ϱ = Unknown(\"ϱ\"; name = \"density\", dim = 1)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n\n    # define reconstruction operator\n    if order == 1\n        FETypes = [H1BR{2}, L2P0{1}, L2P0{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT0{2}, Identity}) : id(u)\n    elseif order == 2\n        FETypes = [H1P2B{2,2}, L2P1{1}, L2P1{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n    end\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n    assign_operator!(PD, LinearOperator([div(u)], [id(ϱ)]; factor = c, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    if kernel_rhs! !== nothing\n        assign_operator!(PD, LinearOperator(kernel_rhs!, [id_u]; factor = 1, store = true, bonus_quadorder = 3*order, kwargs...))\n    end\n    assign_operator!(PD, LinearOperator(kernel_gravity!, [id_u], [id(ϱ)]; factor = 1, bonus_quadorder = 3*order, kwargs...))\n\n    # FVM for continuity equation\n\tτ = μ / (order^2*M*sqrt(τfac)) # time step for pseudo timestepping\n    @info \"timestep = $τ\"\n    PDT = ProblemDescription(\"continuity equation\")\n    assign_unknown!(PDT, ϱ)\n    if order > 1\n       assign_operator!(PDT, BilinearOperator(kernel_continuity!,[grad(ϱ)],[id(ϱ)],[id(u)]; quadorder = 2*order, factor = -1, kwargs...))\n    end\n    if pressure_stab > 0\n        psf = pressure_stab #* xgrid[CellVolumes][1]\n        assign_operator!(PDT, BilinearOperator(stab_kernel!, [jump(id(ϱ))], [jump(id(ϱ))], [id(u)]; entities = ON_IFACES, factor = psf, kwargs...))\n    end\n    assign_operator!(PDT, BilinearOperator([id(ϱ)]; quadorder = 2*(order-1), factor = 1/τ, store = true, kwargs...))\n    assign_operator!(PDT, LinearOperator([id(ϱ)], [id(ϱ)]; quadorder = 2*(order-1), factor = 1/τ, kwargs...))\n    assign_operator!(PDT, BilinearOperatorDG(kernel_upwind!, [jump(id(ϱ))], [this(id(ϱ)), other(id(ϱ))], [id(u)]; quadorder = order+1, entities = ON_IFACES, kwargs...))\n\n    # prepare error calculation\n    EnergyIntegrator = ItemIntegrator(energy_kernel!, [id(u)]; resultdim = 1, quadorder = 2*(order+1), kwargs...)\n    ErrorIntegratorExact = ItemIntegrator(exact_error!(u!, ∇u!, ϱ!), [id(u), grad(u), id(ϱ)]; resultdim = 9, quadorder = 2*(order+1), kwargs...)\n    NDofs = zeros(Int, nrefs)\n    Results = zeros(Float64, nrefs, 5)\n\n    sol = nothing\n    xgrid = nothing\n    op_upwind = 0\n    for lvl = 1 : nrefs\n        xgrid = grid_builder(lvl)\n        @show xgrid\n        FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 3]\n        sol = FEVector(FES; tags = [u,ϱ,p])\n\n        # initial guess\n        fill!(sol[ϱ],M)\n        interpolate!(sol[u], u!)\n        interpolate!(sol[ϱ], ϱ!)\n        NDofs[lvl] = length(sol.entries)\n\n        # solve the two problems iteratively [1] >> [2] >> [1] >> [2] ...\n        SC1 = SolverConfiguration(PD; init = sol, maxiterations = 1, target_residual = target_residual, constant_matrix = true, kwargs...)\n        SC2 = SolverConfiguration(PDT; init = sol, maxiterations = 1, target_residual = target_residual, kwargs...)\n        sol, nits = iterate_until_stationarity([SC1, SC2]; energy_integrator = EnergyIntegrator, maxsteps = maxsteps, init = sol, kwargs...)\n\n        # caculate error\n        error = evaluate(ErrorIntegratorExact, sol)\n        Results[lvl,1] = sqrt(sum(view(error,1,:)) + sum(view(error,2,:)))\n        Results[lvl,2] = sqrt(sum(view(error,3,:)) + sum(view(error,4,:)) + sum(view(error,5,:)) + sum(view(error,6,:)))\n        Results[lvl,3] = sqrt(sum(view(error,7,:)))\n        Results[lvl,4] = sqrt(sum(view(error,8,:)) + sum(view(error,9,:)))\n        Results[lvl,5] = nits\n\n        # print results\n        print_convergencehistory(NDofs[1:lvl], Results[1:lvl,:]; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\",\"#its\"], xlabel = \"ndof\")\n    end\n\n\n    # plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2,2), clear = true, size = (1000,1000))\n    scalarplot!(plt[1,1],xgrid, view(nodevalues(sol[u]; abs = true),1,:), levels = 0, colorbarticks = 7)\n    vectorplot!(plt[1,1],xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), spacing = 0.1, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(plt[2,1],xgrid, view(nodevalues(sol[ϱ]),1,:), levels = 11, title = \"ϱ_h\")\n    plot_convergencehistory!(plt[1,2], NDofs, Results[:,1:4]; add_h_powers = [order,order+1], X_to_h = X -> 0.2*X.^(-1/2), legend = :best, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\",\"#its\"])\n    gridplot!(plt[2,2],xgrid)\n\n    return Results, plt\nend\n\nfunction stab_kernel!(result, p, u, qpinfo)\n    result[1] = p[1] #*abs(u[1] + u[2])\nend\n\n# kernel for (uϱ, ∇λ) ON_CELLS in continuity equation\nfunction kernel_continuity!(result, ϱ, u, qpinfo)\n    result[1]  = ϱ[1] * u[1]\n    result[2]  = ϱ[1] * u[2]\nend\n\n# kernel for (u⋅n ϱ^upw, λ) ON_IFACES in continuity equation\nfunction kernel_upwind!(result, input, u, qpinfo)\n    flux = dot(u, qpinfo.normal) # u * n\n    if flux > 0\n        result[1] = input[1] * flux # rho_left * flux\n    else\n        result[1] = input[2] * flux # rho_righ * flux\n    end\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!,∇u!,ϱ!)\n    function closure(result, u, qpinfo)\n        u!(view(result,1:2), qpinfo)\n        ∇u!(view(result,3:6), qpinfo)\n        ϱ!(view(result,7), qpinfo)\n        result[8] = result[1] * result[7]\n        result[9] = result[2] * result[7]\n        view(result,1:7) .-= u\n        result[8] -= u[1] * u[7]\n        result[9] -= u[2] * u[7]\n        result .= result.^2\n    end\nend\n\n# kernel for gravity term in testcase 1\nfunction standard_gravity!(result, ϱ, qpinfo)\n    result[1] = 0\n    result[2] = -ϱ[1]\nend\n\nfunction energy_kernel!(result, u, qpinfo)\n    result[1] = dot(u,u)/2\nend\n\nfunction load_testcase_data(testcase::Int = 1; laplacian_in_rhs = true, M = 1, c = 1, μ = 1, ufac = 100)\n    if testcase == 1\n        grid_builder = (nref) -> simplexgrid(Triangulate;\n                    points = [0 0; 0.2 0; 0.3 0.2; 0.45 0.05; 0.55 0.35; 0.65 0.2; 0.7 0.3; 0.8 0; 1 0; 1 1 ; 0 1]',\n                    bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 1]',\n                    bfaceregions = ones(Int,11),\n                    regionpoints = [0.5 0.5;]',\n                    regionnumbers = [1],\n                    regionvolumes = [4.0^-(nref)/2])\n        xgrid = grid_builder(3)\n        u1!(result, qpinfo) = (fill!(result, 0);)\n        ∇u1!(result, qpinfo) = (fill!(result, 0);)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[2]/c)/M;), 1; quadorder = 20)\n        area = sum(xgrid[CellVolumes])\n        ϱ1!(result, qpinfo) = (result[1] = exp(-qpinfo.x[2]/c)/(M_exact/area);)\n        return grid_builder, standard_gravity!, nothing, u1!, ∇u1!, ϱ1!, 1\n    elseif testcase == 2\n        grid_builder = (nref) -> simplexgrid(Triangulate;\n                    points = [0 0; 1 0; 1 1 ; 0 1]',\n                    bfaces = [1 2; 2 3; 3 4; 4 1]',\n                    bfaceregions = ones(Int,4),\n                    regionpoints = [0.5 0.5;]',\n                    regionnumbers = [1],\n                    regionvolumes = [4.0^-(nref)])\n\n        xgrid = grid_builder(3)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[1]^3/(3*c));), 1; quadorder = 20)\n        ϱ_eval, g_eval, f_eval, u_eval, ∇u_eval = prepare_data!(; laplacian_in_rhs = laplacian_in_rhs, M = M_exact, c = c, μ = μ, ufac = ufac)\n        ϱ2!(result, qpinfo) = (result[1] = ϱ_eval(qpinfo.x[1], qpinfo.x[2]);)\n\n        M_exact = integrate(xgrid, ON_CELLS, ϱ2!, 1)\n        area = sum(xgrid[CellVolumes])\n\n        function kernel_gravity!(result, input, qpinfo)\n            g_eval(result, qpinfo.x[1], qpinfo.x[2])\n            result .*= input[1]\n        end\n\n        function kernel_rhs!(result, qpinfo)\n            f_eval(result, qpinfo.x[1], qpinfo.x[2])\n        end\n\n        u2!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        ∇u2!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        return grid_builder, kernel_gravity!, f_eval === nothing ? nothing : kernel_rhs!, u2!, ∇u2!, ϱ2!, ufac\n    end\nend\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; M = 1, c = 1, μ = 1, ufac = 100, laplacian_in_rhs = true)\n\n\t@variables x y\n\n\t# density\n\tϱ = exp(-x^3/(3*c))/M\n\n\t# stream function ξ\n\t# sucht that ϱu = curl ξ\n\tξ = x^2*y^2*(x-1)^2*(y-1)^2 * ufac\n\n\t∇ξ = Symbolics.gradient(ξ, [x,y])\n\n\t# velocity u = curl ξ / ϱ\n\tu = [-∇ξ[2], ∇ξ[1]] ./ ϱ\n\n\t# gradient of velocity\n\t∇u = Symbolics.jacobian(u, [x,y])\n\t∇u_reshaped = [∇u[1,1], ∇u[1,2], ∇u[2,1], ∇u[2,2]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1,1], [x]) + Symbolics.gradient(∇u[1,2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2,1], [x]) + Symbolics.gradient(∇u[2,2], [y]))[1]\n\t]\n\n\t# gravity ϱg = - Δu + ϱ∇log(ϱ)\n\n    if laplacian_in_rhs\n        f = - μ*Δu\n        g = c * Symbolics.gradient(log(ϱ), [x,y])\n\telse\n        g = - μ*Δu/ϱ + c * Symbolics.gradient(log(ϱ), [x,y])\n        f = 0\n    end\n\n\t#Δu = Symbolics.derivative(∇u[1,1], [x]) + Symbolics.derivative(∇u[2,2], [y])\n\n\tϱ_eval = build_function(ϱ, x, y, expression = Val{false})\n\tu_eval = build_function(u, x, y, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n\tg_eval = build_function(g, x, y, expression = Val{false})\n\tf_eval = build_function(f, x, y, expression = Val{false})\n\n    return ϱ_eval, g_eval[2], f == 0 ? nothing : f_eval[2], u_eval[2], ∇u_eval[2]\nend\n\nend","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"callbackoperator/#CallbackOperator","page":"CallbackOperator","title":"CallbackOperator","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"A callback operator passes the matrix and rhs to a user-defined function where they can be modified as desired. An example where this is used is Example265.","category":"page"},{"location":"callbackoperator/#Constructors","page":"CallbackOperator","title":"Constructors","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/callback_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"callbackoperator/#ExtendableFEM.CallbackOperator","page":"CallbackOperator","title":"ExtendableFEM.CallbackOperator","text":"function CallbackOperator(\n\tcallback!::Function,\n\tu_args = [];\n\tkwargs...)\n\nGenerates an operator that simply passes the matrix and rhs to a user-specified call back function. The callback function needs to be conform to the interface\n\ncallback!(A, b, args; assemble_matrix = true, assemble_rhs = true, time = 0, kwargs...)\n\nThe u_args argument can be used to specify the arguments of the solution that should be passed as args (a vector of FEVectorBlocks) to the callback.\n\nKeyword arguments:\n\nmodifies_matrix: callback function modifies the matrix?. Default: true\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''CallbackOperator''\nlinearizeddependencies: [uansatz, u_test] when linearized. Default: auto\nmodifies_rhs: callback function modifies the rhs?. Default: true\nverbosity: verbosity level. Default: 0\nstore: store matrix and rhs separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"fixdofs/#FixDofs","page":"FixDofs","title":"FixDofs","text":"","category":"section"},{"location":"fixdofs/","page":"FixDofs","title":"FixDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/fixdofs_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fixdofs/#ExtendableFEM.FixDofs-Tuple{Any}","page":"FixDofs","title":"ExtendableFEM.FixDofs","text":"function FixDofs(u; vals = [], dofs = [], kwargs...)\n\nWhen assembled, all specified dofs of the unknown u will be penalized to the specified values.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''FixDofs''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example290_PoroElasticity/#290-:-Poro-Elasticity","page":"Example290_PoroElasticity","title":"290 : Poro-Elasticity","text":"","category":"section"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"This example concerns the three-field solution (mathbfwmathbfup) of Biot's consolidation model in poroelasticity given by","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"beginaligned\n-(lambda + mu) nabla (mathrmdiv mathbfv) - mu Delta mathbfv + alpha nabla p  = f quad textin  Omega times 0T\npartial_t (c_o + α mathrmdiv(mathbfv)) + mathrmdiv(wmathbfw)  = g quad textin  Omega times 0T\nK^-1 mathbfw + nabla p  = 0 quad textin  Omega times 0T\nendaligned","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"and suitable boundary conditions and given initial state.","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"The discretisation involves an Hdiv-conforming reconstruction operator to avoid Poisson locking which results in a scheme similar to the one suggested in the reference below. As a test problem the first benchmark problem from the same reference is used.","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"reference: Reference\n\"A study of two modes of locking in poroelasticity\",\nS.-Y. Yi,\nSIAM J. Numer. Anal. 55(4) (2017),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"module Example290_PoroElasticity\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\nusing GridVisualize\nusing Symbolics\n\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; μ = 1, λ = 1, K = 1, c0 = 1, α = 1)\n\n\t@variables x y t\n\n\t# displacement and pressure\n\tu = [exp(-t) * (sin(2 * pi * y) * (-1 + cos(2 * pi * x)) + sin(pi * x) * sin(pi * y) / (μ + λ))\n\t\texp(-t) * (sin(2 * pi * x) * (1 - cos(2 * pi * y)) + sin(pi * x) * sin(pi * y) / (μ + λ))]\n\tp = exp(-t) * sin(pi * x) * sin(pi * y)\n\n\t# gradient of displacement\n\t∇u = Symbolics.jacobian(u, [x, y])\n\t∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n\t# gradient of pressure\n\t∇p = [Symbolics.gradient(p, [x])[1], Symbolics.gradient(p, [y])[1]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1, 1], [x])+Symbolics.gradient(∇u[1, 2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2, 1], [x])+Symbolics.gradient(∇u[2, 2], [y]))[1],\n\t]\n\tΔp = Symbolics.gradient(∇p[1], [x]) + Symbolics.gradient(∇p[2], [y])\n\tdivu = ∇u[1, 1] + ∇u[2, 2]\n\t∇divu = [Symbolics.gradient(divu, [x])[1], Symbolics.gradient(divu, [y])[1]]\n\tdivu_dt = Symbolics.gradient(divu, [t])\n\n\tf = -μ * Δu .+ α * ∇p .- (μ + λ) * ∇divu\n\tg = c0 * Symbolics.gradient(p, [t]) - K * Δp + α * divu_dt\n\n\tu_eval = build_function(u, x, y, t, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, t, expression = Val{false})\n\tg_eval = build_function(g, x, y, t, expression = Val{false})\n\tf_eval = build_function(f, x, y, t, expression = Val{false})\n\tp_eval = build_function(p, x, y, t, expression = Val{false})\n\t∇p_eval = build_function(∇p, x, y, t, expression = Val{false})\n\n\treturn f_eval[2], g_eval[2], u_eval[2], ∇u_eval[2], p_eval, ∇p_eval[2]\nend\n\nfunction linear_kernel!(result, input, qpinfo)\n\t∇u, divu, p, w, divw = view(input, 1:4), view(input, 5), view(input, 6), view(input, 7:8), view(input, 9)\n\tμ, λ, α, K = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3], qpinfo.params[4]\n\tresult[1] = μ * ∇u[1] + (λ + μ) * divu[1] - p[1]\n\tresult[2] = μ * ∇u[2]\n\tresult[3] = μ * ∇u[3]\n\tresult[4] = μ * ∇u[4] + (λ + μ) * divu[1] - p[1]\n\tresult[5] = divu[1]\n\tresult[6] = divw[1]\n\tresult[7] = w[1] / K\n\tresult[8] = w[2] / K\n\tresult[9] = -p[1]\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!, ∇u!, p!)\n\tfunction closure(result, u, qpinfo)\n\t\tu!(view(result, 1:2), qpinfo)\n\t\t∇u!(view(result, 3:6), qpinfo)\n\t\tp!(view(result, 7), qpinfo)\n\t\tview(result, 1:7) .-= u\n\t\tresult .= result .^ 2\n\tend\nend\n\nfunction main(; α = 0.93, E = 1e5, ν = 0.4, K = 1e-7, nrefs = 6, T = 0.5, τ = 1e-2, c0 = 1, order = 1, reconstruct = true, Plotter = nothing, kwargs...)\n\n\t# calculate Lame' parameter\n\tμ = E / (2 * (1 + ν))\n\tλ = E * ν / ((1 - 2 * ν) * (1 + ν))\n\n\t# initial and exact state for u and p at time t0\n\tf_eval, g_eval, u_eval, ∇u_eval, p_eval, ∇p_eval = prepare_data!(; μ = μ, λ = λ, K = K, c0 = c0, α = α)\n\tf!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\tg!(result, qpinfo) = (g_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_∇p!(result, qpinfo) = (∇p_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\texact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\n\t# problem description\n\tPD = ProblemDescription(\"Heat Equation\")\n\tu = Unknown(\"u\"; name = \"displacement\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tw = Unknown(\"w\"; name = \"Darcy velocity\")\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_unknown!(PD, w)\n\n\t# prepare reconstruction operator\n\tif reconstruct\n\t\tFES_Reconst = order == 1 ? HDIVBDM1{2} : HDIVBDM2{2}\n\t\tdivu = apply(u, Reconstruct{FES_Reconst, Divergence})\n\t\tidu = apply(u, Reconstruct{FES_Reconst, Identity})\n\telse\n\t\tdivu = div(u)\n\t\tidu = id(u)\n\tend\n\n\t# linear operator\n\tassign_operator!(PD, BilinearOperator(linear_kernel!, [grad(u), divu, id(p), id(w), div(w)]; params = [μ, λ, α, K], store = true, kwargs...))\n\n\t# right-hand side data\n\tassign_operator!(PD, LinearOperator(f!, [idu]; kwargs...))\n\tassign_operator!(PD, LinearOperator(g!, [id(p)]; kwargs...))\n\n\t# boundary conditions\n\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4))\n\tassign_operator!(PD, InterpolateBoundaryData(p, exact_p!; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n\t# prepare solution vector\n\tif order == 1\n\t\tFES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid; broken = true), FESpace{HDIVRT0{2}}(xgrid)]\n\telseif order == 2\n\t\tFES = [FESpace{H1P2B{2, 2}}(xgrid), FESpace{H1P1{1}}(xgrid; broken = true), FESpace{HDIVRT1{2}}(xgrid)]\n\tend\n\tsol = FEVector(FES; tags = PD.unknowns)\n\n\t# initial data\n\tinterpolate!(sol[u], exact_u!; bonus_quadorder = 5, time = 0)\n\tinterpolate!(sol[p], exact_p!; bonus_quadorder = 5, time = 0)\n\n\t# init plotter and plot initial data and grid\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (3, 2), clear = true, size = (800, 1200))\n\tscalarplot!(plt[1, 1], id(u), sol; abs = true, title = \"u_h (t = 0)\")\n\tscalarplot!(plt[2, 1], id(p), sol; title = \"p_h (t = 0)\")\n\tgridplot!(plt[3, 1], xgrid; linewidth = 1)\n\n\t# compute mass matrix\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(2)]; factor = c0))\n\tassemble!(M, BilinearOperator([id(2)], [div(1)]; factor = -α))\n\n\t# add backward Euler time derivative\n\tassign_operator!(PD, BilinearOperator(M, [u, p, w]; factor = 1 / τ, kwargs...))\n\tassign_operator!(PD, LinearOperator(M, [u, p, w], [u, p, w]; factor = 1 / τ, kwargs...))\n\n\t# generate solver configuration\n\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, verbosity = -1, constant_matrix = true, kwargs...)\n\n\t# iterate tspan\n\tt = 0\n\tfor it ∈ 1:Int(floor(T / τ))\n\t\tt += τ\n\t\t@info \"t = $t\"\n\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\tend\n\n\t# error calculation\n\tErrorIntegrator = ItemIntegrator(exact_error!(exact_u!, exact_∇u!, exact_p!), [id(u), grad(u), id(p)]; quadorder = 2 * (order + 1), kwargs...)\n\terror = evaluate(ErrorIntegrator, sol; time = T)\n\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\tH1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n\tL2errorP = sqrt(sum(view(error, 7, :)))\n\t@info \"|| u - u_h || = $L2errorU\n\t|| ∇(u - u_h) || = $H1errorU\n\t|| p - p_h || = $L2errorP\"\n\n\t# plot final state\n\tscalarplot!(plt[1, 2], id(u), sol; abs = true, title = \"u_h (t = $T)\")\n\tscalarplot!(plt[2, 2], id(p), sol; title = \"p_h (t = $T)\")\n\tscalarplot!(plt[3, 2], id(w), sol; abs = true, title = \"|w_h| (t = $T)\")\n\n\treturn L2errorU, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/#207-:-Advection-Upwind-DG","page":"Example207_AdvectionUpwindDG","title":"207 : Advection Upwind-DG","text":"","category":"section"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"(source code)","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"This example computes the solution u of the two-dimensional advection equation","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"beginaligned\nmathrmdiv (beta u)  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"with some given (divergence-free) advection field beta and inhomogeneous Dirichlet boundary conditions at the inflow boundary (where beta cdot n  0 with n being the outer normal vector).","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"In the example below the field beta(xy) = (-y x) and the inflow data","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"   u(xy) =\nbegincases\n    1  textfor  x in 0r  y = 0\n    0  textfor  x in (r1  y = 0\n    0  textfor  x = 1  y in 01\nendcases","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"is employed. The expected solution is a piecewise constant function that assumes the value one in the circle of radius r and zero elsewhere.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"Moreover, the upwind discontinuous Galerkin method for arbitrary polynomial degree is used for the discretization of the problem, but the continuous Galerkin method can be switched on with dg = false for comparison. For piecewise constants the DG method satisfies the maximum principle.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"The grid (which is heavily refined along the interface of the circle) and the computed solution looks like this:","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"(Image: )","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"module Example207_AdvectionUpwindDG\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Symbolics\nusing LinearAlgebra\nusing SimplexGridFactory\nusing Triangulate\n\n# wind = advection field β\nfunction β!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = - x[2]\n    result[2] = x[1]\nend\n\n# exact solution\nfunction exact_u!(result, qpinfo)\n    x = qpinfo.x\n    r = qpinfo.params[1]\n    result[1] = sqrt(x[1]^2 + x[2]^2) <= r ? 1 : 0\nend\n\n# integrand of the advection bilinearform\nfunction advection_kernel!(result, input, qpinfo)\n    β!(result, qpinfo)  # evaluate wind β\n    result .*= input[1] # multiply with u_h\nend\n\nfunction outflow_kernel!(xgrid)\n    beta = zeros(Float64, 2)\n    function closure(result, input, qpinfo)\n        face = qpinfo.item\n        β!(beta, qpinfo)\n        result[1] = dot(beta, qpinfo.normal) * input[1]\n    end\nend\n\nfunction upwind_kernel!(xgrid)\n    beta = zeros(Float64, 2)\n    function closure(result, input, qpinfo)\n        face = qpinfo.item\n        β!(beta, qpinfo)\n        result[1] = dot(beta, qpinfo.normal)\n        if result[1] > 0 ## wind blows this -> other\n            result[1] *= input[1] # upwind value = this\n        else ## wind blows this <- other\n            result[1] *= input[2] # upwind value = other\n        end\n    end\nend\n\n# prepare error calculation\nfunction exact_error!(result, u, qpinfo)\n    exact_u!(result, qpinfo)\n    result[1] = (result[1] - u[1])^2\nend\n\nfunction main(; nref = 4, order = 0, r = 0.5, dg = true, Plotter = nothing, kwargs...)\n\n    # grid\n    xgrid = make_grid(nref, r)\n\n\t# problem description\n\tPD = ProblemDescription(\"advection equation\")\n\tu = Unknown(\"u\"; name = \"species\")\n\tassign_unknown!(PD, u)\n\n\t# advection operator\n\tassign_operator!(PD, BilinearOperator(advection_kernel!, [grad(u)], [id(u)]; factor = -1, bonus_quadorder = 1, kwargs...))\n    if dg\n\t    assign_operator!(PD, BilinearOperatorDG(upwind_kernel!(xgrid), [jump(id(u))], [this(id(u)), other(id(u))]; entities = ON_IFACES, bonus_quadorder = 1, kwargs...))\n    end\n\n    # outflow boundary (regions [3,4]) and inflow boundary (regions [5,6])\n    assign_operator!(PD, BilinearOperator(outflow_kernel!(xgrid), [id(u)]; entities = ON_BFACES, regions = [3,4]))\n\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = [5,6], params = [r], kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1,2], kwargs...))\n\n\t# solve\n\tFES = FESpace{order == 0 ? L2P0{1} : H1Pk{1, 2, order}}(xgrid; broken = dg)\n\tsol = solve(PD, FES; kwargs...)\n\n\t# calculate L2 error and min/max value\n    ErrorIntegrator = ItemIntegrator(exact_error!, [id(u)]; quadorder = 2 * order, params = [r], kwargs...)\n\tL2error = sqrt(sum(view(evaluate(ErrorIntegrator, sol), 1, :)))\n\t@info \"L2 error = $L2error\"\n    @info \"extrema = $(extrema(sol.entries))\"\n\n\t# plot\n\tplt = plot([grid(u), id(u)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(nref = 4, radius = 0.5)\n\tbuilder = SimplexGridBuilder(Generator = Triangulate)\n\n    # define outer boundary nodes and regions\n\tp1 = point!(builder, 0, 0)\n\tp12 = point!(builder, radius, 0)\n\tp2 = point!(builder, 1, 0)\n\tp3 = point!(builder, 1, 1)\n\tp4 = point!(builder, 0, 1)\n\tp41 = point!(builder, 0, radius)\n\n\tfacetregion!(builder, 5)\n\tfacet!(builder, p1, p12)\n\tfacetregion!(builder, 1)\n\tfacet!(builder, p12, p2)\n\tfacetregion!(builder, 2)\n\tfacet!(builder, p2, p3)\n\tfacetregion!(builder, 3)\n\tfacet!(builder, p3, p4)\n\tfacetregion!(builder, 4)\n\tfacet!(builder, p4, p41)\n\tfacetregion!(builder, 6)\n\tfacet!(builder, p41, p1)\n\n    # add interior interface (quarter circle)\n    n = 4^(nref+1)\n    points = [point!(builder, radius * sin(t), radius * cos(t)) for t in range(0, π/2, length = n)]\n\tfacetregion!(builder, 7)\n    for i ∈ 2:n-2\n        facet!(builder, points[i], points[i+1])\n    end\n    facet!(builder, p41, points[1])\n    facet!(builder, points[end], p12)\n\n    # generate\n\tsimplexgrid(builder, maxvolume = 1)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/#270-:-Natural-convection","page":"Example270_NaturalConvectionProblem","title":"270 : Natural convection","text":"","category":"section"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"Seek velocity mathbfu, pressure p and temperature theta such that","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\t- mu Delta u + (mathbfu cdot nabla) mathbfu + nabla p  = Ra  theta  g \n       - Delta theta + mathbfu cdot nabla theta  = 0\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"on a given domain Omega (here a triangle) and boundary conditions","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\tmathbfu  = 0  quad textalong  partial Omega\n \tT  = T_textbottom quad textalong  y = 0\n\tT  = 0 quad textalong  x = 0\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"The weak formulation seeks (mathbfuptheta) in V times Q times X subseteq H^1_0(Omega)^2 times L^2_0(Omega) times H^1_D(Omega) such that","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\t(mu nabla mathbfu nabla mathbfv) + ((mathbfu cdot nabla) mathbfu mathbfv) - (mathrmdiv mathbfv p)  = (mathbfv Ra g  theta)  quad textfor all  mathbfv in V\n(mathrmdiv mathbfu q)  = 0  quad textfor all  q in Q\n       (nabla theta nabla varphi) + (u cdot nabla theta varphi)  = 0\n  quad textfor all  varphi in X\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"To render the discrete method pressure-robust, a reconstruction operator is applied to all identity evaluations of mathbfu and mathbfv (when the switch reconstruct is set to true). Further explanations and discussion on this example can be found in the reference below.","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"reference: Reference\n\"On the divergence constraint in mixed finite element methods for incompressible flows\",\nV. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\nSIAM Review 59(3) (2017),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"module Example270_NaturalConvectionProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, ∇u, p, ∇T, T = view(u_ops, 1:2), view(u_ops,3:6), view(u_ops, 7), view(u_ops, 8:9), view(u_ops, 10)\n    Ra, μ, ϵ = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3]\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4)) - Ra*T[1]\n    result[3] = μ*∇u[1] - p[1]\n    result[4] = μ*∇u[2]\n    result[5] = μ*∇u[3]\n    result[6] = μ*∇u[4] - p[1]\n    result[7] = -(∇u[1] + ∇u[4])\n    result[8] = ϵ*∇T[1]\n    result[9] = ϵ*∇T[2]\n    result[10] = dot(u, ∇T)\n    return nothing\nend\n\nfunction T_bottom!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 2*(1-cos(2*π*x[1]))\nend\n\nfunction main(;\n    nrefs = 5,\n    μ = 1.0,\n    ϵ = 1.0,\n    Ra_final = 1.0e6,\n    reconstruct = true,\n    Plotter = nothing,\n    kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    T = Unknown(\"T\"; name = \"temperature\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, T)\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u,grad(u),id(p),grad(T),id(T)]; kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:3))\n    assign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n    assign_operator!(PD, HomogeneousBoundaryData(T; regions = 3))\n    assign_operator!(PD, InterpolateBoundaryData(T, T_bottom!; regions = 1))\n\n    # grid\n    xgrid = uniform_refine(reference_domain(Triangle2D), nrefs)\n\n    # FESpaces\n    FES = Dict(u => FESpace{H1BR{2}}(xgrid),\n               p => FESpace{L2P0{1}}(xgrid),\n               T => FESpace{H1P1{1}}(xgrid))\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1,3), clear = true, size = (1200,400))\n\n    # solve by Ra embedding\n\tparams = Array{Float64,1}([min(Ra_final, 4000), μ, ϵ])\n    sol = nothing\n    SC = nothing\n\tstep = 0\n\twhile (true)\n        # solve (params are given to all operators)\n        sol, SC = ExtendableFEM.solve(PD, FES, SC; init = sol, return_config = true, target_residual = 1e-6, params = params, kwargs...)\n\n        # plot\n        scalarplot!(plt[1,1], id(u), sol; levels = 0, colorbarticks = 7, abs = true)\n        vectorplot!(plt[1,1], id(u), sol; clear = false, title = \"|u| + quiver (Ra = $(params[1]))\")\n        scalarplot!(plt[1,2], id(T), sol; title = \"T (Ra = $(params[1]))\")\n        scalarplot!(plt[1,3], id(p), sol; title = \"p (Ra = $(params[1]))\")\n\n        # stop if Ra_final is reached\n\t\tif params[1] >= Ra_final\n\t\t\tbreak\n\t\tend\n\n        # increase Ra\n\t\tparams[1] = min(Ra_final, params[1]*3)\n\t\tstep += 1\n\t\t@info \"Step $step : solving for Ra=$(params[1])\"\n\tend\n\n    # compute Nusselt number along bottom (= boundary region 1)\n    ∇T_faces = FaceInterpolator([jump(grad(T))]; order = 0, kwargs...)\n\tNuIntegrator = ItemIntegrator((result, input, qpinfo) -> (result[1] = -input[2]), [id(1)]; entities = ON_FACES, regions = [1])\n    Nu = sum(evaluate(NuIntegrator, evaluate!(∇T_faces, sol)))\n\t@info \"Nu = $Nu\"\n\n    return Nu, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nonlinearoperator/#NonlinearOperator","page":"NonlinearOperator","title":"NonlinearOperator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"A nonlinear operator automatically assembles all necessary terms for the Newton method. Other linearisations of a nonlinear operator can be constructed with special constructors for BilinearOperator or LinearOperator.","category":"page"},{"location":"nonlinearoperator/#Constructor","page":"NonlinearOperator","title":"Constructor","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To describe a NonlinearOperator we have to specify a kernel function.  These functions are 'flat' in the sense that the input and output vector  contain the components of the test-function values and derivatives as specified by oa_test and oa_args respectively. The assembly of the local matrix will be done internally  by multiplying the subvectors of result with its test-function counterparts. For a more detailed explanation of this see the following","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/nonlinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"nonlinearoperator/#ExtendableFEM.NonlinearOperator","page":"NonlinearOperator","title":"ExtendableFEM.NonlinearOperator","text":"function NonlinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tjacobian = nothing,\n\tkwargs...)\n\nGenerates a nonlinear form for the specified kernel function, test function operators, and argument operators evaluations. Operator evaluations are tuples that pair an unknown identifier or integer with a FunctionOperator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, input, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nDuring assembly the Newton update is computed via local jacobians of the kernel which are calculated by automatic differentiation or by the user-provided jacobian function with interface\n\njacobian!(jac, input_args, params)\n\nKeyword arguments:\n\nextra_inputsize: additional entries in input vector (e.g. for type-stable storage for intermediate resutls). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nregions: subset of regions where operator should be assembly only. Default: Any[]\nsparse_jacobians: use sparse jacobians. Default: true\nname: name for operator used in printouts. Default: ''NonlinearOperator''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nsparsejacobianspattern: user provided sparsity pattern for the sparse jacobians (in case automatic detection fails). Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"nonlinearoperator/#Example-NSE-convection-operator","page":"NonlinearOperator","title":"Example - NSE convection operator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"For the Navier–Stokes equations, we need a kernel function for the nonlinear convection term","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n(vucdotnabla u) = (vnabla u^T u)\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"In 2D the input (as specified below) will contain the two components of u=(u_1u_2) and the four components of the gradient  nabla u = beginpmatrix u_11  u_12  u_21  u_22endpmatrix in order, i.e. (u_1u_2u_11u_12u_21u_22). As the convection term is tested with v,  the ouptut vector o only has to contain what should be tested with each component of v, i.e.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n    A_textlocal = (v_1v_2)^T(o_1o_2) = \n        beginpmatrix\n            v_1o_1  v_1o_2\n            v_2o_1  v_2o_2\n        endpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To construct the kernel there are two options,  component-wise and based on tensor_view. For the first we have to write the convection term as individual components","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\no = \n    beginpmatrix\n        u_1cdot u_11+u_2cdot u_12\n        u_1cdot u_21+u_2cdot u_22\n    endpmatrix\n= \nbeginpmatrix\n    ucdot (u_11u_12)^T\n    ucdot (u_21u_22)^T\nendpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To make our lives a bit easier we will extract the subcompontents of  input as views, such that ∇u[3] actually accesses input[5], which corresponds to the third entry u_21 of nabla u. ","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input,3:6)\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4))\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To improve readability of the kernels and to make them easier to understand, we provide the function tensor_view which constructs a view and reshapes  it into an object matching the given TensorDescription. See the table  to see which tensor size is needed for which derivative of a scalar, vector  or matrix-valued variable.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(2))\n    v = tensor_view(result,1,TDVector(2))\n    ∇u = tensor_view(input,3,TDMatrix(2))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The coressponding NonlinearOperator constructor call is the same in both cases  and reads","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\nNonlinearOperator(kernel!, [id(u)], [id(u),grad(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The second argument triggers that the evaluation of the Identity and Gradient operator of the current velocity iterate at each quadrature point go (in that order) into the input vector (of length 6) of the kernel, while the third argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the velocity test function.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"remark: Remark\nAlso note, that the same kernel could be used for a fully explicit linearisation of the convection term as a LinearOperator viau = Unknown(\"u\"; name = \"velocity\")\nLinearOperator(kernel!, [id(u)], [id(u),grad(u)])For a Picard iteration of the convection term, a BilinearOperator can be used with a slightly modified kernel that separates the operator evaluations of the ansatz function and the current solution, i.e.,function kernel_picard!(result, input_ansatz, input_args, qpinfo)\n    a, ∇u = view(input_args, 1:2), view(input_ansatz,1:4)\n    result[1] = dot(a, view(∇u,1:2))\n    result[2] = dot(a, view(∇u,3:4))\nend\nu = Unknown(\"u\"; name = \"velocity\")\nBilinearOperator(kernel_picard!, [id(u)], [grad(u)], [id(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Note\nKernels are allowed to depend on region numbers, space and time coordinates via the qpinfo argument.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Dimension independent kernels\nIf done correctly, the operator-based approach allows us to write a kernel  that is 'independent' of the spatial dimension,  i.e. one instead of up to three kernels. Assuming dim is a known variable we can re-write the kernel from above asfunction kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(dim))\n    v = tensor_view(result,1,TDVector(dim))\n    ∇u = tensor_view(input,1+dim,TDMatrix(dim))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/#Newton-by-local-jacobians-of-kernel","page":"NonlinearOperator","title":"Newton by local jacobians of kernel","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To demonstrate the general approach consider a model problem with a nonlinear operator that has the weak formulation that seeks some function u(x) in X in some finite-dimensional space X with N = mathrmdim X, i.e., some coefficient vector x in mathbbR^N, such that","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) = int_Omega A(L_1u(x)(y)) cdot L_2v(y) textitdy  = 0 quad textfor all  v in X\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"for some given nonlinear kernel function A  mathbbR^m rightarrow mathbbR^n where m is the dimension of the input L_1 u(x)(y) in mathbbR^m and n is the dimension of the result L_2 v(y) in mathbbR^n. Here, L_1 and L_2 are linear operators, e.g. primitive differential operator evaluations of u or v.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Let us consider the Newton scheme to find a root of the residual function F  mathbbR^N rightarrow mathbbR^N, which iterates","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nx_n+1 = x_n - D_xF(x_n)^-1 F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"or, equivalently, solves","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x_n) left(x_n+1 - x_nright) = -F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To compute the jacobian of F, observe that its discretisation on a mesh mathcalT and some quadrature rule (x_qp w_qp) leads to","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp A(L_1u_h(x)(x_qp)) cdot L_2v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Now, by linearity of everything involved other than A, we can evaluate the jacobian by","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp DA(L_1 u_h(x)(x_qp)) cdot L_2 v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Hence, assembly only requires to evaluate the low-dimensional jacobians DA in mathbbR^m times n of A at L_1 u_h(x)(x_qp). These jacobians are computed by automatic differentiation via ForwardDiff.jl (or via the user-given jacobian function). If m and n are a little larger, e.g. when more operator evaluations L_1 and L_2 or more unknowns are involved, there is the option to use sparse_jacobians (using the sparsity detection of Symbolics.jl).","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/#252-:-Navier–Stokes-Planar-Lattice-Flow","page":"Example252_NSEPlanarLatticeFlow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"","category":"section"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"(source code)","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"This example computes an approximation to the planar lattice flow test problem of the Navier-Stokes equations","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"beginaligned\n- nu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"with an exterior force mathbff and some viscosity parameter nu and Dirichlet boundary data for mathbfu.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"Here the exact data for the planar lattice flow","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"beginaligned\nmathbfu(xyt)  = exp(-8 pi^2 nu t) beginpmatrix sin(2 pi x) sin(2 pi y)  cos(2 pi x) cos(2 pi y) endpmatrix\np(xyt)  = exp(-8 pi^2 nu t) ( cos(4 pi x) - cos(4 pi y))  4\nendaligned","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"is prescribed at fixed time t = 0 with mathbff = - nu Delta mathbfu.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"In this example the Navier-Stokes equations are solved with a pressure-robust variant of the Bernardi–Raugel finite element method and the nonlinear convection term (that involves reconstruction operators) is automatically differentiated for a Newton iteration.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"(Image: )","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"module Example252_NSEPlanarLatticeFlow\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact velocity (and Dirichlet data)\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n\tresult[2] = cos(2 * pi * x[1]) * cos(2 * pi * x[2])\nend\n\n# right-hand side f := -μ Δu + (u⋅∇)u + ∇p\nfunction f!(μ)\n\tα = [0, 0]\n\tfunction closure(result, qpinfo)\n\t\tx = qpinfo.x\n\t\tresult[1] = (μ * 8 * pi^2 + α[1]) * sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n\t\tresult[2] = (μ * 8 * pi^2 + α[2]) * cos(2 * pi * x[1]) * cos(2 * pi * x[2])\n\tend\nend\n\n# exact pressure\nfunction p!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = (cos(4 * pi * x[1]) - cos(4 * pi * x[2])) / 4\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n\tu, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n\tμ = qpinfo.params[1]\n\tresult[1] = dot(u, view(∇u, 1:2))\n\tresult[2] = dot(u, view(∇u, 3:4))\n\tresult[3] = μ * ∇u[1] - p[1]\n\tresult[4] = μ * ∇u[2]\n\tresult[5] = μ * ∇u[3]\n\tresult[6] = μ * ∇u[4] - p[1]\n\tresult[7] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\tp!(view(result, 3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\nfunction main(; μ = 0.001, nrefs = 5, reconstruct = true, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tid_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!(μ), [id_u]; kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4))\n\n\t# grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# prepare FESpace\n\tFES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# move integral mean of pressure\n\tpintegrate = ItemIntegrator([id(p)])\n\tpmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n\tview(sol[p]) .-= pmean\n\n\t# error calculation\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), id(p)]; quadorder = 4, params = [μ], kwargs...)\n\terror = evaluate(ErrorIntegratorExact, sol)\n\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\tL2errorP = sqrt(sum(view(error, 3, :)))\n\t@info \"L2error(u) = $L2errorU\"\n\t@info \"L2error(p) = $L2errorP\"\n\n\t# plot\n\tplt = plot([id(u), id(p)], sol; Plotter = Plotter)\n\n\treturn L2errorU, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/#203-:-Poisson-Problem-DG","page":"Example203_PoissonProblemDG","title":"203 : Poisson-Problem DG","text":"","category":"section"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"(source code)","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"with right-hand side f and inhomogeneous Dirichlet boundary conditions chosen such that u(xy) = x^3 - 3xy^2. This time the problem is solved on a given grid via the discontinuous Galerkin method.","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"The computed solution looks like this:","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"(Image: )","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"module Example203_PoissonProblemDG\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\nusing Symbolics\n\n# exact data for problem by Symbolics\nfunction prepare_data(; μ = 1)\n\n\t@variables x y\n\n\t# exact solution\n\tu = x^3 - 3 * x * y^2\n\t∇u = Symbolics.gradient(u, [x, y])\n\n\t# right-hand side\n\tΔu = Symbolics.gradient(∇u[1], [x]) + Symbolics.gradient(∇u[2], [y])\n\tf = -μ * Δu[1]\n\n\t# build functions\n\tu_eval = build_function(u, x, y, expression = Val{false})\n\t∇u_eval = build_function(∇u, x, y, expression = Val{false})\n\tf_eval = build_function(f, x, y, expression = Val{false})\n\treturn f_eval, u_eval, ∇u_eval[2]\nend\n\nfunction main(; dg = true, μ = 1.0, τ = 10.0, nrefs = 4, order = 2, bonus_quadorder = 2, Plotter = nothing, kwargs...)\n\n\t# prepare problem data\n\tf_eval, u_eval, ∇u_eval = prepare_data(; μ = μ)\n\trhs!(result, qpinfo) = (result[1] = f_eval(qpinfo.x[1], qpinfo.x[2]))\n\texact_u!(result, qpinfo) = (result[1] = u_eval(qpinfo.x[1], qpinfo.x[2]))\n\texact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\n\t# problem description\n\tPD = ProblemDescription(\"Poisson problem\")\n\tu = Unknown(\"u\"; name = \"potential\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, LinearOperator(rhs!, [id(u)]; bonus_quadorder = bonus_quadorder, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; bonus_quadorder = bonus_quadorder, regions = 1:4))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\tFES = FESpace{order == 0 ? L2P0{1} : H1Pk{1, 2, order}}(xgrid; broken = dg)\n\n\t# add DG terms\n\tassign_operator!(PD, BilinearOperatorDG(dg_kernel, [jump(id(u))], [average(grad(u))]; entities = ON_FACES, factor = -μ, transposed_copy = 1, kwargs...))\n\tassign_operator!(PD, LinearOperatorDG(dg_kernel_bnd(exact_u!), [average(grad(u))]; entities = ON_BFACES, factor = -μ, bonus_quadorder = bonus_quadorder, kwargs...))\n\tassign_operator!(PD, BilinearOperatorDG(dg_kernel2, [jump(id(u))]; entities = ON_FACES, factor = μ*τ, kwargs...))\n\tassign_operator!(PD, LinearOperatorDG(dg_kernel2_bnd(exact_u!), [id(u)]; entities = ON_BFACES, regions = 1:4, factor = μ*τ, bonus_quadorder = bonus_quadorder, kwargs...))\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# prepare error calculation\n\tfunction exact_error!(result, u, qpinfo)\n\t\texact_u!(result, qpinfo)\n\t\texact_∇u!(view(result, 2:3), qpinfo)\n\t\tresult .-= u\n\t\tresult .= result .^ 2\n\tend\n\tfunction dgjumps!(result, u, qpinfo)\n\t\tresult .= u[1]^2/qpinfo.volume\n\tend\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * (order+1), params = [μ], kwargs...)\n\tDGJumpsIntegrator = ItemIntegratorDG(dgjumps!, [jump(id(u))]; entities = ON_IFACES, kwargs...)\n\n\t# calculate error\n\terror = evaluate(ErrorIntegratorExact, sol)\n\tdgjumps = sqrt(sum(evaluate(DGJumpsIntegrator, sol)))\n\tL2error = sqrt(sum(view(error, 1, :)))\n\tH1error = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\t@info \"L2 error = $L2error\"\n\t@info \"H1 error = $H1error\"\n\t@info \"dgjumps = $dgjumps\"\n\n\t# plot\n\tplt = plot([id(u), grad(u)], sol; Plotter = Plotter)\n\n\treturn L2error, plt\nend\n\nfunction dg_kernel(result, input, qpinfo)\n\tresult[1] = dot(input, qpinfo.normal)\nend\nfunction dg_kernel_bnd(uDb! = nothing)\n\tfunction closure(result, qpinfo)\n\t\tuDb!(result, qpinfo)\n\t\tresult[1:2] = result[1] .* qpinfo.normal\n\tend\nend\nfunction dg_kernel2(result, input, qpinfo)\n\tresult .= input / qpinfo.volume\nend\nfunction dg_kernel2_bnd(uDb! = nothing)\n\tfunction closure(result, qpinfo)\n\t\tuDb!(result, qpinfo)\n\t\tresult /= qpinfo.volume\n\tend\nend\n\nend # module","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/#202-:-Poisson-Problem-(Mixed)","page":"Example202_MixedPoissonProblem","title":"202 : Poisson-Problem (Mixed)","text":"","category":"section"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"This example computes the solution u and its stress mathbfsigma = - mu nabla u of the two-dimensional Poisson problem in the mixed form","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"beginaligned\nmathbfsigma + mu nabla u = 0\nmathrmdiv mathbfsigma  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"The computed solution looks like this:","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"module Example202_MixedPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define unknowns\nσ = Unknown(\"σ\"; name = \"pseudostress\")\nu = Unknown(\"u\"; name = \"potential\")\n\n# bilinearform kernel for mixed Poisson problem\nfunction blf!(result, u_ops, qpinfo)\n\tσ, divσ, u = view(u_ops, 1:2), view(u_ops, 3), view(u_ops, 4)\n\tμ = qpinfo.params[1]\n\tresult[1] = σ[1] / μ\n\tresult[2] = σ[2] / μ\n\tresult[3] = -u[1]\n\tresult[4] = divσ[1]\n\treturn nothing\nend\n# right-hand side data\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2]\n\treturn nothing\nend\n# boundary data\nfunction boundarydata!(result, qpinfo)\n\tresult[1] = 0\n\treturn nothing\nend\n\nfunction main(; nrefs = 5, μ = 0.25, order = 0, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, σ)\n\tassign_operator!(PD, BilinearOperator(blf!, [id(σ), div(σ), id(u)]; params = [μ], kwargs...))\n\tassign_operator!(PD, LinearOperator(boundarydata!, [normalflux(σ)]; entities = ON_BFACES, regions = 1:4, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, FixDofs(u; dofs = [1], vals = [0]))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\tFES = Dict(u => FESpace{order == 0 ? L2P0{1} : H1Pk{1,2,order}}(xgrid; broken = true),\n\t\tσ => FESpace{HDIVRTk{2, order}}(xgrid))\n\n\t# solve\n\tsol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n\t# plot\n\tplt = plot([id(u), id(σ)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEM.jl","page":"Home","title":"ExtendableFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers a toolkit to easily setup (mostly low-order, standard and non-standard) finite element methods for multiphysics problems in Julia and to run fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl (for meshing and administration) and ExtendableFEMBase.jl (for quadrature and FEM basis functions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that this package is part of the meta-package PDELIB.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nExtendableFEMBase.jl\nGridVisualize.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\n","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"#1.-Geometry-description-/-meshing","page":"Home","title":"1. Geometry description / meshing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The geometry description and meshing is not really separated. For meshes of rectangular domains, there are simple constructors available in ExtendableGrids.jl, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExtendableGrids\n## unit square criss-cross into Triangles\nxgrid1 = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n## uniform rectangular grid\nxgrid2 = simplexgrid(0:0.1:1, 0:0.2:2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that these grids generate boundary regions from 1 to 4 (bottom, left, top, right) that can be used to assign boundary conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More complex grids can be created via the mesh generators in SimplexGridFactory.jl, see e.g. Examples 245 or 265, or by loading a Gmsh grid file via the corresponding ExtendableGrids.jl extension.","category":"page"},{"location":"#2.-Problem-description","page":"Home","title":"2. Problem description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Before discretizing the user has the option to pose his problems in form of a Problem Description. Note, that usually no grid has to be defined at this point, but region numbers correspond to regions defined in the grid. Here is a short example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# a simple Poisson problem with right-hand side f(x,y) = x*y and u = 0 along boundary\nPD = ProblemDescription()\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\nf! = (result, qpinfo) -> (result[1] = qpinfo.x[1] * qpinfo.x[2])\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))","category":"page"},{"location":"#3.-Discretization","page":"Home","title":"3. Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this step, the user chooses suitable finite element types for the unknowns of the problem, and generates finite element spaces on the grid (and probably already a solution vector to preoccupy it with an initial solution).","category":"page"},{"location":"","page":"Home","title":"Home","text":"# cubic H1 element in 2D with one component\nFES = FESpace{H1Pk{1,2,3}}(xgrid) \n# alternatively: create solution vector and tag blocks with problem unknowns\nsol = FEVector(FES; tags = PD.unknowns) \n# fill block corresponding to unknown u with initial values\nfill(sol[u], 1)\n# interpolate some given function u!(result, qpinfo)\ninterpolate!(sol[u], u!)","category":"page"},{"location":"#4.-Solve","page":"Home","title":"4. Solve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here, we solve the problem. If the problem is nonlinear, several additional arguments allow to steer the fixed-point iteration, see Stationary Solvers. In the simplest case, the user only needs to call:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# solve problem with finite element space(s)\n# (in case of more than one unknown, provide a vector of FESpaces)\nsol = solve(PD, FES; init = sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For time-dependent problem, the user can add the necessary operators for the time derivative manually. Alternatively, the problem description in space can be turned into an ODE and solve via DifferentialEquations.jl, see Time-dependent Solvers for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that the use can bypass the problem description and control the algebraic level manually via assembling the operators directly into an FEMatrix, see e.g. Example310. It is also possible to take control over the low-level assembly of the operators, see ExtendableFEMBase.jl for details.","category":"page"},{"location":"#5.-Plot-and-postprocess","page":"Home","title":"5. Plot and postprocess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After solving, the user can postprocess the solution, calculate quantities of interest or plot components.","category":"page"},{"location":"#Gradient-robustness","page":"Home","title":"Gradient-robustness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers some ingredients to build gradient-robust schemes via reconstruction operators or divergence-free elements. Gradient-robustness is a feature of discretisations that exactly balance gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to contruct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfunctions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/#282-:-Incompressible-MHD","page":"Example282_IncompressibleMHD","title":"282 : Incompressible MHD","text":"","category":"section"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"(source code)","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"This example yields a prototype for te stationary incompressible viscious MHD equations that seek a velocity field mathbfu, a pressure field p and a divergence-free magnetic field mathbfB such that","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"beginaligned\n- mu Delta mathbfu + nabla cdot (mathbfu otimes mathbfu - mathbfB otimes mathbfB) + nabla (p + frac12 mathbfB cdot mathbfB)\n = 0\nmathrmdiv(mathbfu)  = 0\n- eta Delta mathbfB + nabla cdot (mathbfu otimes mathbfB - mathbfB otimes mathbfu)  = 0\nmathrmdiv(mathbfB)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"on a rectangular 2D domain. Here, mu and eta are the viscosity and resistivity of the fluid and the magnetic field, respectively.","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"(Image: )","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"module Example282_IncompressibleMHD\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\nfunction f!(result, qpinfo)\n\tresult .= 0\nend\n\nfunction g!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = sin(2*pi*x[2])*cos(pi*x[1])\n\tresult[2] = 0\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, B, ∇u, ∇B, p, q = view(u_ops, 1:2), view(u_ops, 3:4), view(u_ops, 5:8), view(u_ops, 9:12), view(u_ops, 13), view(u_ops, 14)\n\tμ = qpinfo.params[1]\n    η = qpinfo.params[2]\n\n\t# viscous terms and pressures\n    result[5] = μ * ∇u[1] - p[1]\n\tresult[6] = μ * ∇u[2]\n\tresult[7] = μ * ∇u[3]\n\tresult[8] = μ * ∇u[4] - p[1]\n\tresult[9] = η * ∇B[1] - q[1]\n\tresult[10] = η * ∇B[2]\n\tresult[11] = η * ∇B[3]\n\tresult[12] = η * ∇B[4] - q[1]\n\n    # Lorentz force\n    result[1] = - dot(B, view(∇B,1:2))\n    result[2] = - dot(B, view(∇B,3:4))\n    BdotB = (B[1]*B[1] + B[2]*B[2])/2\n    result[5] -= BdotB\n    result[8] -= BdotB\n\n    # convection term for u and B\n\tresult[1] += dot(u, view(∇u,1:2))\n\tresult[2] += dot(u, view(∇u,3:4))\n\tresult[3] = dot(u, view(∇B,1:2)) - dot(B, view(∇u,1:2))\n\tresult[4] = dot(u, view(∇B,3:4)) - dot(B, view(∇u,3:4))\n\n    # divergence constraint\n\tresult[13] = -(∇u[1] + ∇u[4])\n\tresult[14] = -(∇B[1] + ∇B[4])\n\treturn nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1e-3, η = 1e-1, nrefs = 5, kwargs...)\n\n\t# load grid (see function below)\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tB = Unknown(\"B\"; name = \"magnetic field\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tq = Unknown(\"q\"; name = \"magnetic pressure\")\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, B)\n\tassign_unknown!(PD, p)\n\tassign_unknown!(PD, q)\n\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id(u), id(B), grad(u), grad(B), id(p), id(q)]; bonus_quadorder = 2, params = [μ,η], kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]))\n    assign_operator!(PD, LinearOperator(g!, [id(B)]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n    assign_operator!(PD, HomogeneousBoundaryData(B; regions = [1]))\n    assign_operator!(PD, FixDofs(p; dofs = [1]))\n    assign_operator!(PD, FixDofs(q; dofs = [1]))\n\n\t# P2-bubble finite element method\n\tFETypes = [H1P2{2, 2}, H1P2{2, 2}, H1P1{1}, H1P1{1}]\n\n\t# generate FESpaces and Solution vector\n\tFES = [FESpace{FETypes[j]}(xgrid) for j = 1:4]\n\n\t# solve\n    sol = ExtendableFEM.solve(PD, FES; target_residual = 1e-8, time = 0, kwargs...)\n\n    # plot\n\tplt = plot([id(u), id(B), id(p), id(q)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"This page was generated using Literate.jl.","category":"page"},{"location":"homogeneousdata/#HomogeneousData","page":"HomogeneousData","title":"HomogeneousData","text":"","category":"section"},{"location":"homogeneousdata/","page":"HomogeneousData","title":"HomogeneousData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/homogeneousdata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousData","text":"function HomogeneousData(u; entities = ON_CELLS, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the specifies entities and entity regions (via kwargs).\n\nKeyword arguments:\n\nvalue: constant value of the data. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousBoundaryData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousBoundaryData","text":"function HomogeneousBoundaryData(u; entities = ON_BFACES, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the boundary faces and boundary regions (via kwargs).\n\nKeyword arguments:\n\nvalue: constant value of the data. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder   = [:function, :type]","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/#240-:-Stokes-RT-enrichment","page":"Example240_SVRTEnrichment","title":"240 : Stokes RT enrichment","text":"","category":"section"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"(source code)","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"with exterior force mathbff and some parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"The problem will be solved by a (P_k oplus RTenrichment) times P_k-1 scheme, which can be seen as an inf-sup stabilized Scott-Vogelius variant that works with general meshes, see references below. Therein, the velocity space employs continuous P_k functions plus certain (only H(div)-conforming) Raviart-Thomas functions and a discontinuous P_k-1 pressure space leading to an exactly divergence-free discrete velocity. In a reduction step (that can be triggered with the reduce switch) all higher order pressure dofs and the enrichment dofs can be eliminated from the system.","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"reference: Reference\n\"A low-order divergence-free H(div)-conforming finite element method for Stokes flows\",\nX. Li, H. Rui,\nIMA Journal of Numerical Analysis (2021),\n>Journal-Link< >Preprint-Link<\"Inf-sup stabilized Scott–Vogelius pairs on general simplicial grids by Raviart–Thomas enrichment\",\nV. John, X. Li, C. Merdon, H. Rui,\n>Preprint-Link<","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"(Image: )","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"module Example240_SVRTEnrichment\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing Triangulate\nusing SimplexGridFactory\nusing Symbolics\n\n# exact data for problem generated by Symbolics\nfunction prepare_data(; μ = 1)\n\n\t@variables x y\n\n\t# stream function ξ\n\tξ = -sin(2 * pi * x) * cos(2 * pi * y)\n\n\t# velocity u = curl ξ\n\t∇ξ = Symbolics.gradient(ξ, [x, y])\n\tu = [-∇ξ[2], ∇ξ[1]]\n\n\t# pressure\n\tp = (cos(4 * pi * x) - cos(4 * pi * y)) / 4\n\n\t# gradient of velocity\n\t∇u = Symbolics.jacobian(u, [x, y])\n\t∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n\t# Laplacian\n\tΔu = [\n\t\t(Symbolics.gradient(∇u[1, 1], [x])+Symbolics.gradient(∇u[1, 2], [y]))[1],\n\t\t(Symbolics.gradient(∇u[2, 1], [x])+Symbolics.gradient(∇u[2, 2], [y]))[1],\n\t]\n\n\t# right-hand side\n\tf = -μ * Δu + Symbolics.gradient(p, [x, y])\n\n\t# build functions\n\tp_eval = build_function(p, x, y, expression = Val{false})\n\tu_eval = build_function(u, x, y, expression = Val{false})\n\t∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n\tf_eval = build_function(f, x, y, expression = Val{false})\n\n\treturn f_eval[2], u_eval[2], ∇u_eval[2], p_eval\nend\n\n# grid generator function\nfunction get_grid2D(nref; uniform = false, barycentric = false)\n\tif uniform || barycentric\n\t\tgen_ref = 0\n\telse\n\t\tgen_ref = nref\n\tend\n\tgrid = simplexgrid(Triangulate;\n\t\tpoints = [0 0; 0 1; 1 1; 1 0]',\n\t\tbfaces = [1 2; 2 3; 3 4; 4 1]',\n\t\tbfaceregions = [1, 2, 3, 4],\n\t\tregionpoints = [0.5 0.5;]',\n\t\tregionnumbers = [1],\n\t\tregionvolumes = [4.0^(-gen_ref - 1)])\n\tif uniform\n\t\tgrid = uniform_refine(grid, nref)\n\tend\n\tif barycentric\n\t\tgrid = barycentric_refine(grid)\n\tend\n\treturn grid\nend\n\n# kernel for Stokes operator\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n\t∇u, p = view(u_ops, 1:4), view(u_ops, 5)\n\tμ = qpinfo.params[1]\n\tresult[1] = μ * ∇u[1] - p[1]\n\tresult[2] = μ * ∇u[2]\n\tresult[3] = μ * ∇u[3]\n\tresult[4] = μ * ∇u[4] - p[1]\n\tresult[5] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction main(; nrefs = 5, μ = 1, α = 1, order = 2, Plotter = nothing, enrich = true, reduce = true, time = 0.5, bonus_quadorder = 5, kwargs...)\n\n\t# prepare problem data\n\tf_eval, u_eval, ∇u_eval, p_eval = prepare_data(; μ = μ)\n\trhs!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\texact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2]))\n\texact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\texact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\n\t# prepare unknowns\n\tu = Unknown(\"u\"; name = \"velocity\", dim = 2)\n\tpfull = Unknown(\"p\"; name = \"pressure (full)\", dim = 1)\n\tpE = Unknown(\"p⟂\"; name = \"pressure (enriched)\", dim = 1)\n\tp0 = Unknown(\"p0\"; name = \"pressure (reduced)\", dim = 1) # only used if enrich && reduced\n\tuR = Unknown(\"uR\"; name = \"velocity enrichment\", dim = 2) # only used if enrich == true\n\n\t# prepare plots\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\n\t# prepare error calculations\n\tfunction exact_error!(result, u, qpinfo)\n\t\texact_u!(view(result, 1:2), qpinfo)\n\t\texact_∇u!(view(result, 3:6), qpinfo)\n\t\tresult .-= u\n\t\tresult .= result .^ 2\n\tend\n\tfunction exact_error_p!(result, p, qpinfo)\n\t\texact_p!(view(result, 1), qpinfo)\n\t\tresult .-= p\n\t\tresult .= result .^ 2\n\tend\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * (order + 1), kwargs...)\n\tErrorIntegratorPressure = ItemIntegrator(exact_error_p!, [order == 1 ? id(p0) : id(pfull)]; quadorder = 2 * (order + 1), kwargs...)\n\tL2NormIntegratorE = L2NormIntegrator([id(uR)]; quadorder = 2 * order)\n\tfunction kernel_div!(result, u, qpinfo)\n\t\tresult .= sum(u) .^ 2\n\tend\n\tDivNormIntegrator = ItemIntegrator(kernel_div!, enrich ? [div(u), div(uR)] : [div(u)]; quadorder = 2 * order)\n\tNDofs = zeros(Int, nrefs)\n\tResults = zeros(Float64, nrefs, 5)\n\n\tfor lvl ∈ 1:nrefs\n\n\t\t# grid\n\t\txgrid = get_grid2D(lvl)\n\n\t\t# define and assign unknowns\n\t\tPD = ProblemDescription(\"Stokes problem\")\n\t\tassign_unknown!(PD, u)\n\t\tp = reduce * enrich ? p0 : pfull\n\t\tassign_unknown!(PD, p)\n\n\t\t################\n\t\t### FESPACES ###\n\t\t################\n\t\tif order == 1\n\t\t\tFES_enrich = FESpace{HDIVRT0{2}}(xgrid)\n\t\telse\n\t\t\tFES_enrich = FESpace{HDIVRTkENRICH{2, order - 1, reduce}}(xgrid)\n\t\tend\n\t\tFES = Dict(u => FESpace{H1Pk{2, 2, order}}(xgrid),\n\t\t\tpfull => FESpace{order == 1 ? L2P0{1} : H1Pk{1, 2, order - 1}}(xgrid; broken = true),\n\t\t\tp0 => FESpace{L2P0{1}}(xgrid; broken = true),\n\t\t\tuR => enrich ? FES_enrich : nothing)\n\n\t\t######################\n\t\t### STANDARD TERMS ###\n\t\t######################\n\t\tassign_operator!(PD, LinearOperator(rhs!, [id(u)]; bonus_quadorder = bonus_quadorder, kwargs...))\n\t\tassign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n\t\tassign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4, bonus_quadorder = bonus_quadorder))\n\t\tassign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n\n\t\t##################\n\t\t### ENRICHMENT ###\n\t\t##################\n\t\tif enrich\n\t\t\tif reduce\n\t\t\t\tif order == 1\n\t\t\t\t\t@info \"... preparing condensation of RT0 dofs\"\n\t\t\t\t\tAR = FEMatrix(FES_enrich)\n\t\t\t\t\tBR = FEMatrix(FES[p], FES_enrich)\n\t\t\t\t\tbR = FEVector(FES_enrich)\n\t\t\t\t\tassemble!(AR, BilinearOperator([div(1)]; lump = true, factor = α*μ, kwargs...))\n\t\t\t\t\tfor bface in xgrid[BFaceFaces]\n\t\t\t\t\t\tAR.entries[bface, bface] = 1e60\n\t\t\t\t\tend\n\t\t\t\t\tassemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n\t\t\t\t\tassemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n\t\t\t\t\t# invert AR (diagonal matrix)\n\t\t\t\t\tAR.entries.cscmatrix.nzval .= 1 ./ AR.entries.cscmatrix.nzval\n\t\t\t\t\tC = -BR.entries.cscmatrix * AR.entries.cscmatrix * BR.entries.cscmatrix'\n\t\t\t\t\tc = -BR.entries.cscmatrix * AR.entries.cscmatrix * bR.entries\n\t\t\t\t\tassign_operator!(PD, BilinearOperator(C, [p], [p]; kwargs...))\n\t\t\t\t\tassign_operator!(PD, LinearOperator(c, [p]; kwargs...))\n\t\t\t\telse\n\t\t\t\t\t@info \"... preparing removal of enrichment dofs\"\n\t\t\t\t\tBR = FEMatrix(FES[p], FES_enrich)\n\t\t\t\t\tA1R = FEMatrix(FES_enrich, FES[u])\n\t\t\t\t\tbR = FEVector(FES_enrich)\n\t\t\t\t\tassemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n\t\t\t\t\tassemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n\t\t\t\t\tassemble!(A1R, BilinearOperator([id(1)], [Δ(1)]; factor = -μ, kwargs...))\n\t\t\t\t\tF, DD_RR = div_projector(FES[u], FES_enrich)\n\t\t\t\t\tC = F.entries.cscmatrix * A1R.entries.cscmatrix\n\t\t\t\t\tassign_operator!(PD, BilinearOperator(C, [u], [u]; factor = 1, transposed_copy = -1, kwargs...))\n\t\t\t\t\tassign_operator!(PD, LinearOperator(F.entries.cscmatrix * bR.entries, [u]; kwargs...))\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tassign_unknown!(PD, uR)\n\t\t\t\tassign_operator!(PD, LinearOperator(rhs!, [id(uR)]; bonus_quadorder = 5, kwargs...))\n\t\t\t\tassign_operator!(PD, BilinearOperator([id(p)], [div(uR)]; transposed_copy = 1, factor = -1, kwargs...))\n\t\t\t\tif order == 1\n\t\t\t\t\tassign_operator!(PD, BilinearOperator([div(uR)]; lump = true, factor = μ, kwargs...))\n\t\t\t\t\tassign_operator!(PD, HomogeneousBoundaryData(uR; regions = 1:4))\n\t\t\t\telse\n\t\t\t\t\tassign_operator!(PD, BilinearOperator([Δ(u)], [id(uR)]; factor = μ, transposed_copy = -1, kwargs...))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\t#############\n\t\t### SOLVE ###\n\t\t#############\n\t\tsol = solve(PD, FES; time = time, kwargs...)\n\t\tNDofs[lvl] = length(sol.entries)\n\n\t\t# move integral mean of pressure\n\t\tpintegrate = ItemIntegrator([id(p)])\n\t\tpmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n\t\tview(sol[p]) .-= pmean\n\n\t\t######################\n\t\t### POSTPROCESSING ###\n\t\t######################\n\t\tif enrich && reduce\n\t\t\tappend!(sol, FES_enrich; tag = uR)\n\t\t\tif order == 1\n\t\t\t\t# compute enrichment part of velocity\n\t\t\t\tview(sol[uR]) .= AR.entries.cscmatrix * (bR.entries - BR.entries.cscmatrix' * view(sol[p]))\n\t\t\telse\n\t\t\t\t# compute enrichment part of velocity\n\t\t\t\tview(sol[uR]) .= F.entries.cscmatrix' * view(sol[u])\n\t\t\tend\n\n\t\t\t# compute higher order pressure dofs\n\t\t\tif reduce && order > 1\n\t\t\t\t# add blocks for higher order pressures to sol vector\n\t\t\t\tVR = FES_enrich\n\t\t\t\tappend!(sol, VR; tag = pE)\n\t\t\t\tappend!(sol, FES[pfull]; tag = pfull)\n\t\t\t\tsol_pE = view(sol[pE])\n\t\t\t\tsol_pfull = view(sol[pfull])\n\t\t\t\tsol_p0 = view(sol[p0])\n\n\t\t\t\tres = FEVector(VR)\n\t\t\t\taddblock_matmul!(res[1], A1R[1, 1], sol[u])\n\t\t\t\tcelldofs_VR::VariableTargetAdjacency{Int32} = VR[CellDofs]\n\t\t\t\tndofs_VR = max_num_targets_per_source(celldofs_VR)\n\t\t\t\tAp = zeros(Float64, ndofs_VR, ndofs_VR)\n\t\t\t\tbp = zeros(Float64, ndofs_VR)\n\t\t\t\txp = zeros(Float64, ndofs_VR)\n\t\t\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\t\t\t# solve local pressure reconstruction\n\t\t\t\t\t# (p_h, div VR) = - (f,VR) + a_h(u_h,VR)\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\tbp[dof_j] = -bR.entries[dof] + res.entries[dof]\n\t\t\t\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\t\t\t\tAp[dof_j, dof_k] = DD_RR.entries[dof, dof2]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# solve for coefficients of div(RT1bubbles)\n\t\t\t\t\txp = Ap \\ bp\n\n\t\t\t\t\t# save in block id_pk\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\tsol_pE[dof] = xp[dof_j]\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t# interpolate into Pk basis (= same pressure basis as in full scheme)\n\t\t\t\tPF = FES[pfull]\n\t\t\t\tappend!(sol, PF; tag = pfull)\n\t\t\t\tcelldofs_PF::SerialVariableTargetAdjacency{Int32} = PF[CellDofs]\n\t\t\t\tndofs_PF::Int = max_num_targets_per_source(celldofs_PF)\n\n\t\t\t\t# compute local mass matrix of full pressure space\n\t\t\t\tMAMA = FEMatrix(PF)\n\t\t\t\tassemble!(MAMA, BilinearOperator([id(1)]))\n\t\t\t\tMAMAE::ExtendableSparseMatrix{Float64, Int64} = MAMA.entries\n\n\t\t\t\t# full div-pressure matrix\n\t\t\t\tPFxVR = FEMatrix(PF, VR)\n\t\t\t\tassemble!(PFxVR, BilinearOperator([id(1)], [div(1)]))\n\t\t\t\tPFxVRE::ExtendableSparseMatrix{Float64, Int64} = PFxVR.entries\n\t\t\t\tbp = zeros(Float64, ndofs_PF)\n\t\t\t\txp = zeros(Float64, ndofs_PF)\n\t\t\t\tlocMAMA = zeros(Float64, ndofs_PF, ndofs_PF)\n\t\t\t\tfor cell ∈ 1:num_cells(xgrid)\n\t\t\t\t\t# solve local pressure reconstruction\n\t\t\t\t\tfill!(bp, 0)\n\t\t\t\t\tfor dof_k ∈ 1:ndofs_PF\n\t\t\t\t\t\tdof2 = celldofs_PF[dof_k, cell]\n\t\t\t\t\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\t\t\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\t\t\t\t\tbp[dof_k] += PFxVRE[dof2, dof] * sol_pE[dof]\n\t\t\t\t\t\tend\n\t\t\t\t\t\tfor dof_j ∈ 1:ndofs_PF\n\t\t\t\t\t\t\tdof = celldofs_PF[dof_j, cell]\n\t\t\t\t\t\t\tlocMAMA[dof_k, dof_j] = MAMAE[dof2, dof]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t# solve for coefficients of div(RT1bubbles)\n\t\t\t\t\txp = locMAMA \\ bp\n\t\t\t\t\tfor dof_j ∈ 1:ndofs_PF\n\t\t\t\t\t\tdof = celldofs_PF[dof_j, cell]\n\t\t\t\t\t\tsol_pfull[dof] = sol_p0[cell] + xp[dof_j]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telseif reduce && order == 1\n\t\t\t\tpfull = p0\n\t\t\tend\n\t\tend\n\n\t\t########################\n\t\t### ERROR EVALUATION ###\n\t\t########################\n\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\tL2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\tH1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n\t\t@info \"L2error(u) = $L2errorU\"\n\t\t@info \"L2error(∇u) = $H1errorU\"\n\t\tevaluate!(error, ErrorIntegratorPressure, sol)\n\t\tL2errorP = sqrt(sum(view(error, 1, :)))\n\t\t@info \"L2error(p) = $L2errorP\"\n\t\tResults[lvl, 4] = L2errorP\n\t\tif enrich\n\t\t\tfill!(error, 0)\n\t\t\tevaluate!(error, L2NormIntegratorE, sol)\n\t\t\tL2normUR = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n\t\t\t@info \"L2norm(uR) = $L2normUR\"\n\t\tend\n\t\tfill!(error, 0)\n\t\tevaluate!(error, DivNormIntegrator, sol)\n\t\tL2normDiv = sqrt(sum(view(error, 1, :)))\n\t\t@info \"L2norm(div(u+uR)) = $L2normDiv\"\n\n\t\tResults[lvl, 1] = L2errorU\n\t\tResults[lvl, 2] = H1errorU\n\t\tResults[lvl, 3] = L2normUR\n\t\tResults[lvl, 5] = L2normDiv\n\n\t\t#############\n\t\t### PLOTS ###\n\t\t#############\n\t\tscalarplot!(plt[1, 1], id(u), sol; abs = true)\n\t\tscalarplot!(plt[1, 2], id(pfull), sol)\n\t\tif order == 1 && enrich\n\t\t\tscalarplot!(plt[2, 2], id(uR), sol)\n\t\tend\n\tend\n\tplot_convergencehistory!(\n\t\tplt[2, 1],\n\t\tNDofs,\n\t\tResults[:,1:4];\n\t\tadd_h_powers = [order, order + 1],\n\t\tX_to_h = X -> 8 * X .^ (-1 / 2),\n\t\tlegend = :best,\n\t\tylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"],\n\t)\n\n\tprint_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"], xlabel = \"ndof\")\n\n\treturn Results, plt\nend\n\nfunction div_projector(V1, VR)\n\n\t# setup interpolation matrix\n\tcelldofs_V1 = V1[CellDofs]\n\tcelldofs_VR = VR[CellDofs]\n\tndofs_V1 = max_num_targets_per_source(celldofs_V1)\n\tndofs_VR = max_num_targets_per_source(celldofs_VR)\n\n\tDD_RR = FEMatrix(VR)\n\tassemble!(DD_RR, BilinearOperator([div(1)]))\n\tDD_RRE = DD_RR.entries\n\tDD_1R = FEMatrix(V1, VR)\n\tassemble!(DD_1R, BilinearOperator([div(1)]))\n\tDD_1RE = DD_1R.entries\n\tAp = zeros(Float64, ndofs_VR, ndofs_VR)\n\tbp = zeros(Float64, ndofs_VR)\n\txp = zeros(Float64, ndofs_VR)\n\tncells = num_sources(celldofs_V1)\n\tF = FEMatrix(V1, VR)\n\tFE = F.entries\n\tfor cell ∈ 1:ncells\n\n\t\t# solve local pressure reconstruction for RTk part\n\t\tfor dof_j ∈ 1:ndofs_VR\n\t\t\tdof = celldofs_VR[dof_j, cell]\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tAp[dof_j, dof_k] = DD_RRE[dof, dof2]\n\t\t\tend\n\t\tend\n\n\t\tfor dof_j ∈ 1:ndofs_V1\n\t\t\tdof = celldofs_V1[dof_j, cell]\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tbp[dof_k] = -DD_1RE[dof, dof2]\n\t\t\tend\n\n\t\t\txp = Ap \\ bp\n\n\t\t\tfor dof_k ∈ 1:ndofs_VR\n\t\t\t\tdof2 = celldofs_VR[dof_k, cell]\n\t\t\t\tFE[dof, dof2] = xp[dof_k]\n\t\t\tend\n\t\tend\n\tend\n\tflush!(FE)\n\treturn F, DD_RR\nend\n\nend # module","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/#235-:-Stokes-iterated-penalty-method","page":"Example235_StokesIteratedPenalty","title":"235 : Stokes iterated penalty method","text":"","category":"section"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"(source code)","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbf0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"with some μ parameter mu.","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain with the iterated penalty method suggested in the reference below adapted to the Bernardi–Raugel finite element method. Given intermediate solutions mathbfu_h and p_h the next approximations are computed by the two equations","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"beginaligned\n(nabla mathbfu_h^next nabla mathbfv_h) + lambda (mathrmdiv_h(mathbfu^next_h) mathrmdiv_h(mathbfv_h))  = (mathbffmathbfv_h) + (p_hmathrmdiv(mathbfv_h))\n textfor all  mathbfv_h in mathbfV_h\n(p^next_hq_h)  = (p_hq_h) - lambda (mathrmdiv(mathbfu_h^next)q_h)  textfor all  q_h in Q_h\nendaligned","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This is done consecutively until the residual of both equations is small enough. The discrete divergence is computed via a RT0 reconstruction operator that preserves the disrete divergence. (another way would be to compute B M^-1 B^T where M is the mass matrix of the pressure and B is the matrix for the div-pressure block).","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"reference: Reference\n\"An iterative penalty method for the finite element solution of the stationary Navier-Stokes equations\",\nR. Codina,\nComputer Methods in Applied Mechanics and Engineering Volume 110, Issues 3–4 (1993),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"(Image: )","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"module Example235_StokesIteratedPenalty\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# data for Hagen-Poiseuille flow\nfunction p!(result, qpinfo)\n\tx = qpinfo.x\n\tμ = qpinfo.params[1]\n\tresult[1] = μ * (-2 * x[1] + 1.0)\nend\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tresult[1] = x[2] * (1.0 - x[2])\n\tresult[2] = 0.0\nend\n# kernel for div projection\nfunction div_projection!(result, input, qpinfo)\n\tresult[1] = input[1] - qpinfo.params[1] * input[2]\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, λ = 1e4, μ = 1.0, nrefs = 5, kwargs...)\n\n\t# initial grid\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n\t# Bernardi--Raugel element with reconstruction operator\n\tFETypes = (H1BR{2}, L2P0{1})\n\tPenaltyDivergence = Reconstruct{HDIVRT0{2}, Divergence}\n\n\t# generate two problems\n\t# one for velocity, one for pressure\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\tPDu = ProblemDescription(\"Stokes IPM - velocity update\")\n\tassign_unknown!(PDu, u)\n\tassign_operator!(PDu, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n\tassign_operator!(PDu, BilinearOperator([apply(u, PenaltyDivergence)]; store = true, factor = λ, kwargs...))\n\tassign_operator!(PDu, LinearOperator([div(u)], [id(p)]; factor = 1, kwargs...))\n\tassign_operator!(PDu, InterpolateBoundaryData(u, u!; regions = 1:4, params = [μ], bonus_quadorder = 4, kwargs...))\n\n\tPDp = ProblemDescription(\"Stokes IPM - pressure update\")\n\tassign_unknown!(PDp, p)\n\tassign_operator!(PDp, BilinearOperator([id(p)]; store = true, kwargs...))\n\tassign_operator!(PDp, LinearOperator(div_projection!, [id(p)], [id(p), div(u)]; params = [λ], factor = 1, kwargs...))\n\n\t# show and solve problem\n\tFES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n\tsol = FEVector([FES[1], FES[2]]; tags = [u, p])\n\tSC1 = SolverConfiguration(PDu; init = sol, maxiterations = 1, target_residual = 1e-8, constant_matrix = true, kwargs...)\n\tSC2 = SolverConfiguration(PDp; init = sol, maxiterations = 1, target_residual = 1e-8, constant_matrix = true, kwargs...)\n\tsol, nits = iterate_until_stationarity([SC1, SC2]; init = sol, kwargs...)\n\t@info \"converged after $nits iterations\"\n\n\t# plot\n\tplt = plot([id(u), id(p)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example226_Thermoforming/#226-:-Thermoforming","page":"Example226_Thermoforming","title":"226 : Thermoforming","text":"","category":"section"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"(source code)","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"This implements the thermoforming example taken from https://arxiv.org/abs/1802.03564 Section 6.4. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"(Image: )","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"module Example226_Thermoforming\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SparseArrays\nusing LinearAlgebra\n\nfunction w(r)\n\tif 0.1 ≤ r ≤ 0.3\n\t\treturn 5.0 * r - 0.5\n\telseif 0.3 < r < 0.7\n\t\treturn 1.0\n\telseif 0.7 <= r <= 0.9\n\t\treturn 4.5 - 5.0 * r\n\telse\n\t\treturn 0.0\n\tend\nend\n\n# initial mould\nfunction Φ0(x)\n\treturn w(x[1]) * w(x[2])\nend\n\n\nfunction g(r,κ,s)\n\tif r <= 0.0\n\t\treturn κ\n\telseif r <= 0.25 * s\n\t\treturn κ - 8.0 * κ * r^2 / (3.0 * s^2)\n\telseif r <= 0.75 * s\n\t\treturn 7.0 / 6.0 * κ - 4.0 / 3.0 * κ * r / s\n\telseif r <= s\n\t\treturn 8.0 / 3.0 * (s - r)^2 / s^2\n\telse\n\t\treturn 0.0\n\tend\nend\n\n\n# The smooth bump function in [0,1]\nbump(x) = (0.0 <= x <= 1.0) ? exp(-0.25 / (x - x^2)) : 0.0\n\n# Bump in [0,1]^2\nbumpInUnitSquare(x) = begin\n\tr = sqrt((x[1] - 0.5)^2 + (x[2] - 0.5)^2)\n\treturn bump(0.5 + r)\nend\n\n\n# nonlinear kernel\nfunction nonlinear_kernel!(result, input, qpinfo )\n\t# results and input contain 7 variables (u,∇u,T,∇T,y)\n\tu  = view(input, 1)\n\t∇u = view(input, 2:3)\n\tT  = view(input, 4)\n\t∇T = view(input, 5:6)\n\ty  = view(input, 7)\n\n\tα = qpinfo.params[1]\n\tk = qpinfo.params[2]\n\tf = qpinfo.params[3]\n\tβ = qpinfo.params[4]\n\tκ = qpinfo.params[5]\n\ts = qpinfo.params[6]\n\n\tresult[1]   = α * max(0, u[1] - y[1]) - f                                             # pattern: 1 7\n\tresult[2:3] = ∇u                                                                      # pattern: 2 / 3\n\tresult[4]   = k*T[1] - g(y[1]-u[1],κ,s)                                               # pattern: 1 4 7\n\tresult[5:6] = ∇T                                                                      # pattern: 5 / 6\n\tresult[7]   = y[1] - Φ0(qpinfo.x) - β * bumpInUnitSquare( qpinfo.x ) * T[1]           # pattern: 4 7\nend\n\n# custom sparsity pattern for the jacobians of the nonlinear_kernel (Symbolcs cannot handle conditional jumps)\n# note: jacobians are defined row-wise\nrows = [1, 1, 2, 3, 4, 4, 4, 5, 6, 7, 7]\ncols = [1 ,7, 2, 3, 1, 4, 7, 5, 6, 4, 7]\nvals = ones(Bool, length(cols))\nsparsity_pattern = sparse(rows,cols,vals)\n\nfunction main(;\n\tκ = 10,\n\ts = 1,\n\tα = 1e8,\n\tk = 1,\n\tβ = 5.25e-3,\n\tf = 100,\n\tN = 32,\n\torder = 1,\n\tPlotter = nothing,\n\tkwargs...)\n\n\t# choose mesh,\n\th = 1/(N+1)\n\txgrid = simplexgrid(0:h:1,0:h:1)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"membrane position\")\n\ty = Unknown(\"y\"; name = \"mould\")\n\tT = Unknown(\"T\"; name = \"temperature\")\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, y)\n\tassign_unknown!(PD, T)\n\tassign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u), id(T), grad(T), id(y)]; bonus_quadorder=2, params=[α,k,f,β,κ,s], sparse_jacobians_pattern=sparsity_pattern, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(y; regions = 1:4, kwargs...))\n\n\t# create finite element space\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tFESs = [FES, FES, FES]\n\tsol = FEVector(FESs; tags = [u,y,T])\n\n\t# initial guess for Newton\n\tinterpolate!(sol[u], (result,qpinfo) -> ( result[1] = 0.9*Φ0(qpinfo.x) ) )\n\tinterpolate!(sol[T], (result,qpinfo) -> ( result[1] = 0.2 ) )\n\tinterpolate!(sol[y], (result,qpinfo) -> ( result[1] = 10.0 ) )\n\n\t# solve\n\tsol = solve(PD, FESs; init = sol, maxiterations=420, target_residual=1e-8, kwargs...)\n\n\t# plot\n\tplt = plot([id(u),id(T),id(y)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/#260-:-Axisymmetric-Stokes","page":"Example260_AxisymmetricNavierStokesProblem","title":"260 : Axisymmetric Stokes","text":"","category":"section"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This example solves the 3D stagnation point flow via the 2.5D axisymmetric formulation of the Navier–Stokes problem that seeks a velocity mathbfu = (u_z u_r) and pressure p such that","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z - r^-2 right) u_r\n+ (u_r partial_r + u_z partial_z) u_r + partial_r p  = mathbff_r\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z right) u_z\n+ (u_r partial_r + u_z partial_z) u_z + partial_z p  = mathbff_z\n(partial_r + r^-1)u_r + partial_z u_z  = 0\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"with exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"The axisymmetric formulation assumes that the velocity in some 3D-domain, that is obtained by rotation of a 2D domain Omega, only depends on the distance r to the rotation axis and the z-coordinate tangential to the x-axis, but not on the angular coordinate of the cylindric coordinates. The implementation employs r-dependent bilinear forms and a Cartesian grid for the 2D (zr) domain that is assumed to be rotated around the r=0-axis.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This leads to the weak formulation","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\na(uv) + b(pv)  = (fv) \n         b(qu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"with the bilinear forms","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\na(uv) = int_Omega left( nabla u  nabla v + r^-2 u_r v_r right) r dr dz\nb(qv) = int_Omega q left( mathrmdiv(v) + r^-1 u_r right) r dr dz\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"where the usual Cartesian differential operators can be used. The factor 2pi from the integral over the rotation angle drops out on both sides.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"module Example260_AxisymmetricNavierStokesProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n\nfunction kernel_convection!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input, 3:6)\n    r = qpinfo.x[1]\n    result[1] = r*(∇u[1]*u[1] + ∇u[2]*u[2])\n    result[2] = r*(∇u[3]*u[1] + ∇u[4]*u[2])\n    return nothing\nend\n\nfunction kernel_stokes_axisymmetric!(result, u_ops, qpinfo)\n    u, ∇u, p = view(u_ops,1:2), view(u_ops,3:6), view(u_ops, 7)\n    r = qpinfo.x[1]\n    μ = qpinfo.params[1]\n    # add Laplacian\n    result[1] = μ/r * u[1] - p[1]\n    result[2] = 0\n    result[3] = μ*r * ∇u[1] - r*p[1]\n    result[4] = μ*r * ∇u[2]\n    result[5] = μ*r * ∇u[3]\n    result[6] = μ*r * ∇u[4] - r*p[1]\n    result[7] = -(r*(∇u[1]+∇u[4]) + u[1])\n    return nothing\nend\n\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[1]\n    result[2] = -2*x[2]\nend\n\nfunction kernel_l2div(result, u_ops, qpinfo)\n    u, divu = view(u_ops,1:2), view(u_ops,3)\n    result[1] = (qpinfo.x[1]*divu[1] + u[1])^2\nend\n\n\nfunction main(; μ = 0.1, nrefs = 4, nonlinear = false, uniform = false, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_axisymmetric!, [id(u),grad(u),id(p)]; params = [μ], kwargs...))#; jacobian = kernel_jacobian!))\n    if nonlinear\n        assign_operator!(PD, NonlinearOperator(kernel_convection!, [id(u)], [id(u),grad(u)]; bonus_quadorder = 1, kwargs...))#; jacobian = kernel_jacobian!))\n    end\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = [3]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [4], mask = (1,0,1)))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = (0,1,1)))\n\n    # grid\n    if uniform\n        xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    else\n        xgrid = simplexgrid(Triangulate;\n        points=[0 0 ; 5 0 ; 5 1 ; 0 1]',\n        bfaces=[1 2 ; 2 3 ; 3 4 ; 4 1 ]',\n        bfaceregions=[1, 2, 3, 4],\n        regionpoints=[0.5 0.5;]',\n        regionnumbers=[1],\n        regionvolumes=[4.0^(-nrefs-1)])\n    end\n\n    # solve\n    FES = [FESpace{H1P2B{2,2}}(xgrid), FESpace{L2P1{1}}(xgrid)]\n    sol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n    # compute divergence in cylindrical coordinates by volume integrals\n    DivIntegrator = ItemIntegrator(kernel_l2div, [id(u), div(u)]; quadorder = 4, resultdim = 1)\n    div_error = sqrt(sum(evaluate(DivIntegrator, sol)))\n    @info \"||div(u_h)|| = $div_error\"\n\n    # compute L2error\n    function kernel_l2error(result, u_ops, qpinfo)\n        u!(result, qpinfo)\n        result .= (result - u_ops).^2\n    end\n    ErrorIntegratorExact = ItemIntegrator(kernel_l2error, [id(1)]; entities = ON_BFACES, regions = [3], quadorder = 4, kwargs...)\n    error = evaluate(ErrorIntegratorExact, sol)\n    L2error = sqrt(sum(view(error,1,:)) + sum(view(error,2,:)))\n    @info \"||u - u_h|| = $L2error\"\n\n    # plot\n    plt = plot([id(u)], sol; Plotter = Plotter)\n\n    return [div_error, L2error], plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example285_CahnHilliard/#285-:-Cahn-Hilliard-Equations","page":"Example285_CahnHilliard","title":"285 : Cahn-Hilliard Equations","text":"","category":"section"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"(source code)","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"This example studies the mixed form of the Cahn-Hilliard equations that seeks (cmu) such that","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"beginaligned\nc_t - mathbfdiv (M nabla mu)  = 0\nmu - partial f  partial c + lambda nabla^2c  = 0\nendaligned","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"with f(c) = 100c^2(1-c)^2, constant parameters M and lambda and (random) initial concentration as defined in the code below.","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"The computed solution at different timesteps for the default parameters and a randomized initial state look like this:","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"(Image: )","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"module Example285_CahnHilliard\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing ForwardDiff\nusing Random\nRandom.seed!(135791113)\n\n# parameters and initial condition\nconst f = (c) -> 100 * c^2 * (1 - c)^2\nconst dfdc = (c) -> ForwardDiff.derivative(f, c)\n\nfunction c0!(result, qpinfo)\n\tresult[1] = 0.63 + 0.02 * (0.5 - rand())\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\torder = 2,                              # finite element order for c and μ\n\tnref = 4,                               # refinement level\n\tM = 1.0,\n\tλ = 1e-2,\n\titerations_until_next_plot = 20,\n\tτ = 5 / 1000000,                        # time step (for main evolution phase)\n\tτ_increase = 1.1,                      # increase factor for τ after each plot\n\tPlotter = nothing,                      # Plotter (e.g. PyPlot)\n\tkwargs...,\n)\n\n\t# initial grid and final time\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nref)\n\n\t# define unknowns\n\tc = Unknown(\"c\"; name = \"concentration\", dim = 1)\n\tμ = Unknown(\"μ\"; name = \"chemical potential\", dim = 1)\n\n\t# define main level set problem\n\tPD = ProblemDescription(\"Cahn-Hilliard equation\")\n\tassign_unknown!(PD, c)\n\tassign_unknown!(PD, μ)\n\tassign_operator!(PD, BilinearOperator([grad(c)], [grad(μ)]; factor = M, store = true))\n\tassign_operator!(PD, BilinearOperator([id(μ)]; store = true))\n\tassign_operator!(PD, BilinearOperator([grad(μ)], [grad(c)]; factor = -λ, store = true))\n\n\t# add nonlinear reaction part (= -df/dc times test function)\n\tfunction kernel_dfdc!(result, input, qpinfo)\n\t\tresult[1] = -dfdc(input[1])\n\tend\n\tassign_operator!(PD, NonlinearOperator(kernel_dfdc!, [id(μ)], [id(c)]; bonus_quadorder = 1))\n\n\t# generate FESpace and solution vector and interpolate initial state\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tsol = FEVector([FES, FES]; tags = PD.unknowns)\n\tinterpolate!(sol[c], c0!)\n\n\t# init plot (if order > 1, solution is upscaled to finer grid for plotting)\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (4, 3), clear = true, resolution = (900, 1200))\n\tif order > 1\n\t\txgrid_upscale = uniform_refine(xgrid, order - 1)\n\t\tSolutionUpscaled = FEVector(FESpace{H1P1{1}}(xgrid_upscale))\n\t\tlazy_interpolate!(SolutionUpscaled[1], sol)\n\telse\n\t\txgrid_upscale = xgrid\n\t\tSolutionUpscaled = sol\n\tend\n\tnodevals = nodevalues_view(SolutionUpscaled[1])\n\tscalarplot!(plt[1, 1], xgrid_upscale, nodevals[1]; limits = (0.61, 0.65), xlabel = \"\", ylabel = \"\", levels = 1, title = \"c (t = 0)\")\n\n\t# prepare backward Euler time derivative\n\tM = FEMatrix(FES)\n\tb = FEVector(FES)\n\tassemble!(M, BilinearOperator([id(1)]; factor = 1.0 / τ))\n\tassign_operator!(PD, BilinearOperator(M, [c]; kwargs...))\n\tassign_operator!(PD, LinearOperator(b, [c]; kwargs...))\n\n\t# generate solver configuration\n\tSC = SolverConfiguration(PD, [FES, FES]; init = sol, maxiterations = 50, target_residual = 1e-6, kwargs...)\n\n\t# advance in time, plot from time to time\n\tt = 0\n\tfor j ∈ 1:11\n\t\t# do some timesteps until next plot\n\t\tfor it ∈ 1:iterations_until_next_plot\n\t\t\tt += τ\n\t\t\t# update time derivative\n\t\t\tb.entries .= M.entries * view(sol[c])\n\t\t\tExtendableFEM.solve(PD, [FES, FES], SC; time = t)\n\t\tend\n\n\t\t# enlarge time step a little bit\n\t\tτ *= τ_increase\n\t\tM.entries.cscmatrix.nzval ./= τ_increase\n\n\t\t# plot at current time\n\t\tif order > 1\n\t\t\tlazy_interpolate!(SolutionUpscaled[1], sol)\n\t\tend\n\t\tscalarplot!(plt[1+Int(floor((j) / 3)), 1+(j)%3], xgrid_upscale, nodevals[1]; xlabel = \"\", ylabel = \"\", limits = (-0.1, 1.1), levels = 1, title = \"c (t = $(Float32(t)))\")\n\tend\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example330_HyperElasticity/#330-:-Hyperelasticity","page":"Example330_HyperElasticity","title":"330 : Hyperelasticity","text":"","category":"section"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"This examples computes the solution of a nonlinear elasticity problem for hyperelastic media via minimisation of the (neo-Hookian) energy functional","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"beginaligned\n\tW(u F(mathbfu)) = int_Omega fracmu2 (FF - 3 - 2log(mathrmdet(F))) + fraclambda2 log(mathrmdet(F))^2 - B cdot mathbfu textitdx - int_partial Omega T cdot mathbfu textitds\nendaligned","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"where F(mathbfu) = I + nabla u is the deformation gradient and mu and lambda are the Lame parameters. The energy is differentiated twice by automatic differentiation to setup a Newton scheme for a Lagrangian finite element approximation of mathbfu, once in the code below to define the kernel for the NonlinearOperator and this kernel is differentiated again in the assembly of the Newton scheme for the nonlinear operator.","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"The deformed unit cube and the displacement for the default parameters and inhomogeneous boundary conditions as defined in the code looks like this:","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"module Example330_HyperElasticity\n\nusing ExtendableFEM\nusing LinearAlgebra\nusing DiffResults\nusing ForwardDiff\nusing SimplexGridFactory\nusing TetGen\n\n# inhomogeneous boundary conditions for bregion 1\nfunction bnd_1!(result, qpinfo)\n    x, y, z = qpinfo.x[1], qpinfo.x[2], qpinfo.x[3]\n    angle = pi/3\n    result[1] = 0.0\n    result[2] = (0.5+(y-0.5)*cos(angle) - (z-0.5)*sin(angle)-y)/2.0\n    result[3] = (0.5+(y-0.5)*sin(angle) + (z-0.5)*cos(angle)-x)/2.0\nend\n\n# kernel for body and traction forces\nfunction apply_force!(result, qpinfo)\n    result .= qpinfo.params[1]\nend\n\n# energy functional (only nonlinear part, without exterior forces)\nfunction W!(result, F, qpinfo)\n    F[1] += 1\n    F[5] += 1\n    F[9] += 1\n    μ, λ = qpinfo.params[1], qpinfo.params[2]\n    detF = -(F[3]*(F[5]*F[7] - F[4]*F[8]) + F[2]*((-F[6])*F[7] + F[4]*F[9]) + F[1]*(F[6]*F[8] - F[5]*F[9]))\n    result[1] = μ/2 * (dot(F,F) - 3 - 2*log(detF)) + λ/2 * (log(detF))^2\nend\n\n# derivative of energy functional (by ForwardDiff)\nfunction nonlinkernel_DW!()\n\tDresult = nothing\n\tcfg = nothing\n\tresult_dummy = nothing\n\tW(qpinfo) = (a,b) -> W!(a,b,qpinfo)\n\n\tfunction closure(result, input, qpinfo)\n\t\tif Dresult === nothing\n\t\t\t# first initialization of DResult when type of input = F is known\n\t\t\tresult_dummy = zeros(eltype(input), 1)\n\t\t\tDresult = DiffResults.JacobianResult(result_dummy, input)\n\t\t\tcfg = ForwardDiff.JacobianConfig(W(qpinfo), result_dummy, input, ForwardDiff.Chunk{length(input)}())\n\t\tend\n\t\tDresult = ForwardDiff.vector_mode_jacobian!(Dresult, W(qpinfo), result_dummy, input, cfg)\n\t\tcopyto!(result, DiffResults.jacobian(Dresult))\n        return nothing\n\tend\nend\n\n\nfunction main(;\n\tmaxvolume = 0.001,  # parameter for grid generator\n\tE = 10,             # Young modulus\n    ν = 0.3,            # Poisson ratio\n\torder = 3, \t\t\t# finite element order\n    B = [0,-0.5,0],     # body force\n    T = [0.1,0,0],      # traction force\n\tPlotter = nothing,\n\tkwargs...)\n\n    # compute Lame parameters\n\tμ = E / (2 * (1 + ν))\n\tλ = E * ν / ((1+ν)*(1 - 2 * ν))\n\n\t# define unknowns\n\tu = Unknown(\"u\"; name = \"displacement\")\n\n    # define problem\n    PD = ProblemDescription(\"Hyperelasticity problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(nonlinkernel_DW!(), [grad(u)]; sparse_jacobians = false, params = [μ, λ]))\n    assign_operator!(PD, LinearOperator(apply_force!, [id(u)]; params = [B]))\n    assign_operator!(PD, LinearOperator(apply_force!, [id(u)]; entities = ON_BFACES, store = true, regions = 1:6, params = [T]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [2]))\n    assign_operator!(PD, InterpolateBoundaryData(u, bnd_1!; regions = [1], quadorder = 10))\n\n    # grid\n    xgrid = tetrahedralization_of_cube(maxvolume = maxvolume)\n\n    # solve\n    FES = FESpace{H1P1{3}}(xgrid)\n    sol = solve(PD, FES; maxiterations = 20)\n\n    # displace mesh and plot final result\n    displace_mesh!(xgrid, sol[u])\n\tplt = plot([grid(u), id(u)], sol; Plotter = Plotter, do_vector_plots = false)\n\n\treturn sol, plt\nend\n\n\nfunction tetrahedralization_of_cube(; maxvolume = 0.1)\n    builder = SimplexGridBuilder(; Generator = TetGen)\n\n    p1 = point!(builder, 0, 0, 0)\n    p2 = point!(builder, 1, 0, 0)\n    p3 = point!(builder, 1, 1, 0)\n    p4 = point!(builder, 0, 1, 0)\n    p5 = point!(builder, 0, 0, 1)\n    p6 = point!(builder, 1, 0, 1)\n    p7 = point!(builder, 1, 1, 1)\n    p8 = point!(builder, 0, 1, 1)\n\n    facetregion!(builder, 1)\n    facet!(builder, p1, p2, p3, p4)\n    facetregion!(builder, 2)\n    facet!(builder, p5, p6, p7, p8)\n    facetregion!(builder, 3)\n    facet!(builder, p1, p2, p6, p5)\n    facetregion!(builder, 4)\n    facet!(builder, p2, p3, p7, p6)\n    facetregion!(builder, 5)\n    facet!(builder, p3, p4, p8, p7)\n    facetregion!(builder, 6)\n    facet!(builder, p4, p1, p5, p8)\n\n    simplexgrid(builder; maxvolume = maxvolume)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"itemintegrators/#Item-Integrators","page":"Item Integrators","title":"Item Integrators","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Item integrators compute certain quantities of the Solution, like a posteriori errors estimators, norms, drag/lift coefficients or other statistics.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegrator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegrator","text":"function ItemIntegrator(\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs). If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegrator{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegrator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ItemIntegratorDG","page":"Item Integrators","title":"ItemIntegratorDG","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"ItemIntegratorDG is intended for quantities that involve jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions or jumps of broken FESpaces. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegratorDG-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegratorDG","text":"function ItemIntegratorDG(\n\tkernel::Function,\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified (discontinuous) operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs) along cell boundaries. If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nfactor: factor that should be multiplied during assembly. Default: 1\nresultdim: dimension of result field (default = length of arguments). Default: 0\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nname: name for operator used in printouts. Default: ''ItemIntegratorDG''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONFACES\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegratorDG{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegratorDG,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/#210-:-Poisson-L-shape-Adaptive-Mesh-Refinement","page":"Example210_LshapeAdaptivePoissonProblem","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"section"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This example computes the standard-residual error estimator for the H^1 error e = u - u_h of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"eta^2(u_h) = sum_T in mathcalT lvert T rvert  f + Delta u_h ^2_L^2(T)\n+ sum_F in mathcalF lvert F rvert  nabla u_h cdot mathbfn ^2_L^2(F)","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This example script showcases the evaluation of 2nd order derivatives like the Laplacian and adaptive mesh refinement.","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"The resulting mesh and error convergence history for the default parameters looks like:","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"module Example210_LshapeAdaptivePoissonProblem\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n\tx = qpinfo.x\n\tr2 = x[1]^2 + x[2]^2\n\tφ = atan(x[2], x[1])\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\tresult[1] = r2^(1 / 3) * sin(2 * φ / 3)\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n\tx = qpinfo.x\n\tφ = atan(x[2], x[1])\n\tr2 = x[1]^2 + x[2]^2\n\tif φ < 0\n\t\tφ += 2 * pi\n\tend\n\t∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n\t∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n\tresult[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n\tresult[2] = sin(φ) * ∂r + cos(φ) * ∂φ\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n\tu!(result, qpinfo)\n\t∇u!(view(result, 2:3), qpinfo)\n\tresult .-= u\n\tresult .= result .^ 2\nend\n\n# kernel for face interpolation of normal jumps of gradient\nfunction gradnormalflux!(result, ∇u, qpinfo)\n\tresult[1] = dot(∇u, qpinfo.normal)\nend\n\n# kernel for face refinement indicator\nfunction η_face!(result, gradjump, qpinfo)\n\tresult .= qpinfo.volume * gradjump .^ 2\nend\n\n# kernel for cell refinement indicator\nfunction η_cell!(result, Δu, qpinfo)\n\tresult .= qpinfo.volume * Δu .^ 2\nend\n\nfunction main(; maxdofs = 4000, θ = 0.5, μ = 1.0, nrefs = 1, order = 2, Plotter = nothing, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Poisson problem\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n\t# discretize\n\txgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n\n\t# define interpolators and item integrators for error estimation and calculation\n\tNormalJumpProjector = FaceInterpolator(gradnormalflux!, [jump(grad(u))]; resultdim = 1, order = order, only_interior = true, kwargs...)\n\tErrorIntegratorFace = ItemIntegrator(η_face!, [id(1)]; quadorder = 2 * order, entities = ON_FACES, kwargs...)\n\tErrorIntegratorCell = ItemIntegrator(η_cell!, [Δ(1)]; quadorder = 2 * (order - 2), entities = ON_CELLS, kwargs...)\n\tErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n\n\tNDofs = zeros(Int, 0)\n\tResultsL2 = zeros(Float64, 0)\n\tResultsH1 = zeros(Float64, 0)\n\tResultsη = zeros(Float64, 0)\n\tsol = nothing\n\tndofs = 0\n\tlevel = 0\n\twhile ndofs < maxdofs\n\t\tlevel += 1\n\n\t\t# SOLVE : create a solution vector and solve the problem\n\t\tprintln(\"------- LEVEL $level\")\n\t\tif ndofs < 1000\n\t\t\tprintln(stdout, unicode_gridplot(xgrid))\n\t\tend\n\t\t@time begin\n\t\t\t# solve\n\t\t\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\t\t\tsol = ExtendableFEM.solve(PD, FES; u = [u], kwargs...)\n\t\t\tndofs = length(sol[1])\n\t\t\tpush!(NDofs, ndofs)\n\t\t\tprintln(\"\\t ndof =  $ndofs\")\n\t\t\tprint(\"@time  solver =\")\n\t\tend\n\n\t\t# ESTIMATE : calculate local error estimator contributions\n\t\t@time begin\n\t\t\t# calculate error estimator\n\t\t\tJumps4Faces = evaluate!(NormalJumpProjector, sol)\n\t\t\tη_F = evaluate(ErrorIntegratorFace, Jumps4Faces)\n\n\t\t\tη_T = evaluate(ErrorIntegratorCell, sol)\n\t\t\tfacecells = xgrid[FaceCells]\n\t\t\tfor face ∈ 1:size(facecells, 2)\n\t\t\t\tη_F[face] += η_T[facecells[1, face]]\n\t\t\t\tif facecells[2, face] > 0\n\t\t\t\t\tη_F[face] += η_T[facecells[2, face]]\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t# calculate total estimator\n\t\t\tpush!(Resultsη, sqrt(sum(η_F)))\n\t\t\tprint(\"@time  η eval =\")\n\t\tend\n\n\t\t# calculate exact L2 error, H1 error\n\t\t@time begin\n\t\t\terror = evaluate(ErrorIntegratorExact, sol)\n\t\t\tpush!(ResultsL2, sqrt(sum(view(error, 1, :))))\n\t\t\tpush!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n\t\t\tprint(\"@time  e eval =\")\n\t\tend\n\n\t\tif ndofs >= maxdofs\n\t\t\tbreak\n\t\tend\n\n\t\t# MARK+REFINE : mesh refinement\n\t\t@time begin\n\t\t\tif θ >= 1 ## uniform mesh refinement\n\t\t\t\txgrid = uniform_refine(xgrid)\n\t\t\telse ## adaptive mesh refinement\n\t\t\t\t# refine by red-green-blue refinement (incl. closuring)\n\t\t\t\tfacemarker = bulk_mark(xgrid, view(η_F, :), θ; indicator_AT = ON_FACES)\n\t\t\t\txgrid = RGB_refine(xgrid, facemarker)\n\t\t\tend\n\t\t\tprint(\"@time  refine =\")\n\t\tend\n\t\tprintln(\"\\t    η =  $(Resultsη[level])\\n\\t    e =  $(ResultsH1[level])\")\n\tend\n\n\t# plot\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\tscalarplot!(plt[1, 1], id(u), sol; levels = 7, title = \"u_h\")\n\tplot_convergencehistory!(plt[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\tgridplot!(plt[2, 1], xgrid; linewidth = 1)\n\tgridplot!(plt[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n\t# print convergence history\n\tprint_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bilinearoperator/#BilinearOperator","page":"BilinearOperator","title":"BilinearOperator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluat more than the degrees of freedom on the face) there is the possibility to use BilinearOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.","category":"page"},{"location":"bilinearoperator/#Constructors","page":"BilinearOperator","title":"Constructors","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-2","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tA::AbstractMatrix,\n\tu_test,\n\tu_ansatz = u_test;\n\tkwargs...)\n\nGenerates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments utest and uansatz specify where to put the (blocks of the) matrix in the system.\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#BilinearOperatorDG","page":"BilinearOperator","title":"BilinearOperatorDG","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.\n\nKeyword arguments:\n\nlump: lump the operator (= only assemble the diagonal). Default: false\nfactor: factor that should be multiplied during assembly. Default: 1\ncallback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperatorDG''\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nverbosity: verbosity level. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nverbosity: verbosity level. Default: 0\ntime_dependent: operator is time-dependent ?. Default: false\nname: name for operator used in printouts. Default: ''BilinearOperator''\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nquadorder: quadrature order. Default: ''auto''\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nregions: subset of regions where operator should be assembly only. Default: Any[]\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nusesparsitypattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#Examples","page":"BilinearOperator","title":"Examples","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Below two examples illustrate some use cases.","category":"page"},{"location":"bilinearoperator/#Example-Stokes-operator","page":"BilinearOperator","title":"Example - Stokes operator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"For the linear operator of a Stokes problem a kernel could look like","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"μ = 0.1 # viscosity parameter\nfunction kernel!(result, input, qpinfo)\n    ∇u, p = view(input,1:4), view(input, 5)\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the coressponding BilinearOperator constructor call reads","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\np = Unknown(\"p\"; name = \"pressure\")\nBilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since input[5] does not couple with result[5].","category":"page"},{"location":"bilinearoperator/#Example-interior-penalty-stabilization","page":"BilinearOperator","title":"Example - interior penalty stabilization","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"function stab_kernel!(result, input, qpinfo)\n    result .= input .* qpinfo.volume^2\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the BilinearOperatorDG constructor call","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\")\nassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))","category":"page"},{"location":"combinedofs/#CombineDofs","page":"CombineDofs","title":"CombineDofs","text":"","category":"section"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/combinedofs.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"combinedofs/#ExtendableFEM.CombineDofs","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, dofsX, dofsY, factors; kwargs...)\n\nWhen assembled, the dofsX of the unknown uX will be coupled with the dofsY of uY, e.g., for periodic boundary conditions.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\n\n\n\n\n\n","category":"type"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"The following function might be useful to find out the dofs the need to be coupled for periodic boundary conditions:","category":"page"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"get_periodic_coupling_info","category":"page"},{"location":"combinedofs/#ExtendableFEM.get_periodic_coupling_info","page":"CombineDofs","title":"ExtendableFEM.get_periodic_coupling_info","text":"function get_periodic_coupling_info(FES, xgrid, b1, b2, is_opposite::Function; factor_vectordofs = \"auto\")\n\ncomputes the dofs that have to be coupled for periodic boundary conditions on the given xgrid for boundary regions b1, b2. The isopposite function evaluates if two provided face midpoints are on opposite sides to each other (the mesh xgrid should be appropriate). For vector-valued FETypes the user can provide factorvectordofs to incorporate a sign change if needed. This is automatically done for all Hdiv-conforming elements and (for the normal-weighted face bubbles of) the Bernardi-Raugel element H1BR. \n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example201_PoissonProblem/#201-:-Poisson-Problem","page":"Example201_PoissonProblem","title":"201 : Poisson-Problem","text":"","category":"section"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"module Example201_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define variables\nu = Unknown(\"u\"; name = \"potential\")\n\n# define data functions\nfunction f!(fval, qpinfo)\n\tfval[1] = qpinfo.x[1] * qpinfo.x[2]\nend\n\nfunction main(; μ = 1.0, nrefs = 4, order = 2, Plotter = nothing, kwargs...)\n\t# problem description\n\tPD = ProblemDescription()\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n\t# discretize\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot\n\tplt = plot([id(u), grad(u)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example103_BurgersEquation/#103-:-Burger's-Equation","page":"Example103_BurgersEquation","title":"103 : Burger's Equation","text":"","category":"section"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"This example solves the Burger's equation","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"beginaligned\nu_t - mu Delta u + mathrmdiv f(u)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"with periodic boundary conditions. This script demonstrates how a time-dependent PDE can be solved with DifferentialEquations or by a manual implicit Euler scheme.","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"The initial condition and the final solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"module Example103_BurgersEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\n\n# nonlinear kernel, i.e. f(u)\nfunction f!(result, input, qpinfo)\n\tresult[1] = input[1]^2 / 2\nend\n\n# initial condition\nfunction uinit!(result, qpinfo)\n\tresult[1] = abs(qpinfo.x[1]) < 0.5 ? 1 : 0\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\tν = 0.01,\n\th = 0.005,\n\tT = 2,\n\torder = 2,\n\tτ = 0.01,\n\tPlotter = nothing,\n\tuse_diffeq = true,\n\tsolver = Rosenbrock23(autodiff = false),\n\tkwargs...)\n\n\t# load mesh and exact solution\n\txgrid = simplexgrid(-2:h:2)\n\n\t# generate empty PDEDescription for three unknowns (h, u)\n\tPD = ProblemDescription(\"Burger's Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(f!, [grad(u)], [id(u)]; bonus_quadorder = 2))\n\tassign_operator!(PD, BilinearOperator([grad(u)]; store = true, factor = ν))\n\tassign_operator!(PD, CombineDofs(u, u, [1], [num_nodes(xgrid)], [1.0]; kwargs...))\n\n\t# prepare solution vector and initial data\n\tFES = FESpace{H1Pk{1, 1, order}}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], uinit!)\n\n\t# init plotter and plot u0\n\tplt = plot([id(u), id(u)], sol; Plotter = Plotter, title_add = \" (t = 0)\")\n\n\t# generate mass matrix\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(1)]; lump = 2))\n\n\tif (use_diffeq)\n\t\t# generate DifferentialEquations.ODEProblem\n\t\tprob = ExtendableFEM.generate_ODEProblem(PD, FES, (0.0, T); init = sol, mass_matrix = M)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-6, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# extract final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor(T / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state\n\tplot!(plt, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/#250-:-Navier–Stokes-Lid-driven-cavity","page":"Example250_NSELidDrivenCavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"","category":"section"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"(source code)","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"beginaligned\n- mu Delta mathbfu + left(mathbfu cdot nablaright) mathbfu+ nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"in a lid driven cavity example over a cone and plots the solution and the formed eddies.","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"(Image: )","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"module Example250_NSELidDrivenCavity\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n\tu, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n\tμ = qpinfo.params[1]\n\tresult[1] = dot(u, view(∇u, 1:2))\n\tresult[2] = dot(u, view(∇u, 3:4))\n\tresult[3] = μ * ∇u[1] - p[1]\n\tresult[4] = μ * ∇u[2]\n\tresult[5] = μ * ∇u[3]\n\tresult[6] = μ * ∇u[4] - p[1]\n\tresult[7] = -(∇u[1] + ∇u[4])\n\treturn nothing\nend\n\nfunction boundarydata!(result, qpinfo)\n\tresult[1] = 1\n\tresult[2] = 0\nend\n\nfunction initialgrid_cone()\n\txgrid = ExtendableGrid{Float64, Int32}()\n\txgrid[Coordinates] = Array{Float64, 2}([-1 0; 0 -2; 1 0]')\n\txgrid[CellNodes] = Array{Int32, 2}([1 2 3]')\n\txgrid[CellGeometries] = VectorOfConstants{ElementGeometries, Int}(Triangle2D, 1)\n\txgrid[CellRegions] = ones(Int32, 1)\n\txgrid[BFaceRegions] = Array{Int32, 1}([1, 2, 3])\n\txgrid[BFaceNodes] = Array{Int32, 2}([1 2; 2 3; 3 1]')\n\txgrid[BFaceGeometries] = VectorOfConstants{ElementGeometries, Int}(Edge1D, 3)\n\txgrid[CoordinateSystem] = Cartesian2D\n\treturn xgrid\nend\n\nfunction main(; μ_final = 0.0005, order = 2, nrefs = 5, Plotter = nothing, kwargs...)\n\n\t# prepare parameter field\n\textra_params = Array{Float64, 1}([max(μ_final, 0.05)])\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"velocity\")\n\tp = Unknown(\"p\"; name = \"pressure\")\n\n\tassign_unknown!(PD, u)\n\tassign_unknown!(PD, p)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id(u), grad(u), id(p)]; params = extra_params, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, boundarydata!; regions = 3))\n\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 2]))\n\tassign_operator!(PD, FixDofs(p; dofs = [1]))\n\n\n\t# grid\n\txgrid = uniform_refine(initialgrid_cone(), nrefs)\n\n\t# prepare FESpace\n\tFES = [FESpace{H1Pk{2,2,order}}(xgrid), FESpace{H1Pk{1,2,order-1}}(xgrid)]\n\n\t# prepare plots\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, size = (1600, 800))\n\n\t# solve by μ embedding\n\tstep = 0\n\tsol = nothing\n\tSC = nothing\n\tPE = PointEvaluator([id(1)])\n\twhile (true)\n\t\tstep += 1\n\t\t@info \"Step $step : solving for μ=$(extra_params[1])\"\n\t\tsol, SC = ExtendableFEM.solve(PD, FES, SC; return_config = true, target_residual = 1e-10, maxiterations = 20, kwargs...)\n\t\tif step == 1\n\t\t\tinitialize!(PE, sol)\n\t\tend\n\t\tscalarplot!(plt[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n\t\tvectorplot!(plt[1, 1], xgrid, eval_func_bary(PE), spacing = 0.05, clear = false)\n\t\tstreamplot!(plt[1, 2], xgrid, eval_func_bary(PE), spacing = 0.01, density = 2, title = \"streamlines\")\n\n\t\tif extra_params[1] <= μ_final\n\t\t\tbreak\n\t\telse\n\t\t\textra_params[1] = max(μ_final, extra_params[1] / 2)\n\t\tend\n\tend\n\n\tscalarplot!(plt[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n\tvectorplot!(plt[1, 1], xgrid, eval_func_bary(PE), spacing = 0.05, clear = false)\n\tstreamplot!(plt[1, 2], xgrid, eval_func_bary(PE), spacing = 0.01, density = 2, title = \"streamlines\")\n\n\treturn sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/#105-:-Nonlinear-Poisson-Equation","page":"Example105_NonlinearPoissonEquation","title":"105 : Nonlinear Poisson Equation","text":"","category":"section"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"This examples solves the nonlinear Poisson problem","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"beginaligned\n- epsilon partial^2 u  partial x^2 + e^u - e^-u  = f  textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"where","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"f(x) = begincases\n1  x geq 05\n-1  x  05\nendcases","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"on the domain Omega = (01) with Dirichlet boundary conditions u(0) = 0 and u(1) = 1.","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"module Example105_NonlinearPoissonEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# rigt-hand side data\nfunction f!(result, qpinfo)\n\tresult[1] = qpinfo.x[1] < 0.5 ? -1 : 1\nend\n# boundary data\nfunction boundary_data!(result, qpinfo)\n\tresult[1] = qpinfo.x[1]\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion oeprator\nfunction nonlinear_kernel!(result, input, qpinfo)\n\tu, ∇u, ϵ = input[1], input[2], qpinfo.params[1]\n\tresult[1] = exp(u) - exp(-u)\n\tresult[2] = ϵ * ∇u\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 1e-2, ϵ = 1e-3, order = 2, kwargs...)\n\n\t# problem description\n\tPD = ProblemDescription(\"Nonlinear Poisson Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; params = [ϵ], kwargs...))\n\tassign_operator!(PD, LinearOperator(f!, [id(u)]; store = true, kwargs...))\n\tassign_operator!(PD, InterpolateBoundaryData(u, boundary_data!; kwargs...))\n\n\t# discretize: grid + FE space\n\txgrid = simplexgrid(0:h:1)\n\tFES = FESpace{H1Pk{1, 1, order}}(xgrid)\n\n\t# generate a solution vector and solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# plot discrete and exact solution (on finer grid)\n\tplt = plot([id(u)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"problemdescription/#Problem-Description","page":"Problem Description","title":"Problem Description","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Central object is the ProblemDescription which is given as a weak form of your problem and usually does not need any information on the discretisation at this point (but of course can depend on region numbers).","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"ProblemDescription","category":"page"},{"location":"problemdescription/#ExtendableFEM.ProblemDescription","page":"Problem Description","title":"ExtendableFEM.ProblemDescription","text":"struct ProblemDescription\n\nStructure holding data for a problem description with the following fields:\n\nname::String: The name of the problem used for printout messages. Default: \"My Problem\"\n\nunknowns::Vector{Unknown}: A vector of Unknowns that are involved in the problem.\n\noperators::Vector{AbstractOperator}: A vector of operators that are involved in the problem.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#Constructors-and-assign-functions","page":"Problem Description","title":"Constructors and assign functions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"problemdescription.jl\"]\nOrder   = [:function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.assign_operator!-Tuple{ProblemDescription, AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.assign_operator!","text":"assign_operator!(PD::ProblemDescription, o::AbstractOperator)\n\nAssigns the AbstractOperator o to the ProblemDescription PD and returns its position in the operators array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.assign_unknown!-Tuple{ProblemDescription, Unknown}","page":"Problem Description","title":"ExtendableFEM.assign_unknown!","text":"assign_unknown!(PD::ProblemDescription, u::Unknown)\n\nAssigns the Unknown u to the ProblemDescription PD and returns its position in the unknowns array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.replace_operator!-Tuple{ProblemDescription, Any, AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.replace_operator!","text":"replace_operator!(PD::ProblemDescription, j::Int, o::AbstractOperator)\n\nReplaces the j-th operator of the ProblemDescription PD by the new operator o. Here, j is the position in operator array returned by the assign_operator! function. Nothing is returned (as the new operator gets position j).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Unknowns","page":"Problem Description","title":"Unknowns","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"An Unknown is an identifies that encodes a physical quantity in the ProblemDescription.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"unknowns.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Unknown","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"struct Unknown\n\nStructure holding information for an unknwon with the following fields:\n\nname::String: The name of the unknown used for printout messages.\n\nidentifier::Any: The identifier of the unknown used for assignments to operators.\n\nparameters::Dict{Symbol, Any}: Further properties of the unknown can be stored in a Dict, see constructor.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Unknown-Tuple{String}","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"function Unknown(\n\tu::String;\n\tidentifier = Symbol(u),\n\tname = u,\n\tkwargs...)\n\nGenerates and returns an Unknown with the specified name, identifier and other traits.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nalgebraic_constraint: is this unknown an algebraic constraint?. Default: nothing\nsymbol_ansatz: symbol for ansatz functions of this unknown in printouts. Default: nothing\nsymbol_test: symbol for test functions of this unknown in printouts. Default: nothing\ndimension: dimension of the unknown. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Operators","page":"Problem Description","title":"Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Operator is a quite general concept and is everything that makes modifications to the system matrix, hence classical represenations of weak discretisations of differential operators, penalisations for boundary conditions or global constraints, or stabilisation terms.","category":"page"},{"location":"problemdescription/#Types-of-operators","page":"Problem Description","title":"Types of operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The three most important operator classes are:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"NonlinearOperator (e.g. the convection term in a Navier-Stokes problem)\nBilinearOperator (e.g. the Laplacian in a Poisson problem)\nLinearOperator (e.g. the right-hand side in a Poisson or Navier-Stokes problem)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"To assing boundary conditions or global constraints there are three possibilities:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"InterpolateBoundaryData\nHomogeneousData\nFixDofs\nCombineDofs","category":"page"},{"location":"problemdescription/#Entities-and-Regions","page":"Problem Description","title":"Entities and Regions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Each operator assembles on certain entities of the mesh, the default is a cell-wise assembly. Most operators have the entities kwarg to changes that. Restrictions to subsets of the entities can be made via the regions kwarg.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Entities Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate on the cells of the mesh\nON_FACES assemble/interpolate on all faces of the mesh\nON_IFACES assemble/interpolate on the interior faces of the mesh\nON_BFACES assemble/interpolate on the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate on all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate on the boundary edges of the mesh (in 3D)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/#106-:-Nonlinear-Diffusion","page":"Example106_NonlinearDiffusion","title":"106 : Nonlinear Diffusion","text":"","category":"section"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"(source code)","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"This example solves the nonlinear diffusion equation","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"beginaligned\nu_t - Delta u^m  = 0\nendaligned","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"in Omega = (-11) with homogeneous Neumann boundary conditions.","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"(Image: )","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"module Example106_NonlinearDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing DifferentialEquations\nusing GridVisualize\n\n# Barenblatt solution\n# (see Barenblatt, G. I. \"On nonsteady motions of gas and fluid in porous medium.\" Appl. Math. and Mech.(PMM) 16.1 (1952): 67-78.)\nfunction u_exact!(result, qpinfo)\n\tt = qpinfo.time\n\tx = qpinfo.x[1]\n\tm = qpinfo.params[1]\n\ttx = t^(-1.0 / (m + 1.0))\n\txx = x * tx\n\txx = xx * xx\n\txx = 1 - xx * (m - 1) / (2.0 * m * (m + 1))\n\tif xx < 0.0\n\t\txx = 0.0\n\tend\n\tresult[1] = tx * xx^(1.0 / (m - 1.0))\nend\n\nfunction kernel_nonlinear!(result, input, qpinfo)\n\tu, ∇u = input[1], input[2]\n\tm = qpinfo.params[1]\n\tresult[1] = m * u^(m - 1) * ∇u\nend\n\n# everything is wrapped in a main function\nfunction main(;\n\tm = 2,\n\th = 0.05,\n\tt0 = 0.001,\n\tT = 0.01,\n\torder = 1,\n\tτ = 0.0001,\n\tPlotter = nothing,\n\tuse_diffeq = true,\n\tuse_masslumping = true,\n\tsolver = ImplicitEuler(autodiff = false),\n\tkwargs...)\n\n\t# load mesh and exact solution\n\txgrid = simplexgrid(-1:h:1)\n\n\t# set finite element types [surface height, velocity]\n\tFEType = H1Pk{1, 1, order}\n\n\t# generate empty PDEDescription for three unknowns (h, u)\n\tPD = ProblemDescription(\"Nonlinear Diffusion Equation\")\n\tu = Unknown(\"u\"; name = \"u\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [grad(u)], [id(u), grad(u)]; params = [m], bonus_quadorder = 2))\n\n\t# prepare solution vector and initial data\n\tFES = FESpace{FEType}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[u], u_exact!; time = t0, params = [m])\n\n\t# init plotter and plot u0\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), size = (800,400))\n\tscalarplot!(plt[1, 1], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1, title = \"t = $t0\")\n\n\t# generate mass matrix (with mass lumping)\n\tM = FEMatrix(FES)\n\tassemble!(M, BilinearOperator([id(1)]; lump = 2 * use_masslumping))\n\n\tif (use_diffeq)\n\t\t# generate ODE problem\n\t\tprob = ExtendableFEM.generate_ODEProblem(PD, FES, (t0, T); init = sol, mass_matrix = M.entries.cscmatrix)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-3, dt = τ, dtmin = 1e-8, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tassign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor((T - t0) / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state and exact solution for comparison\n\tscalarplot!(plt[1, 2], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1)\n\tinterpolate!(sol[1], u_exact!; time = T, params = [m])\n\tscalarplot!(plt[1, 2], id(u), sol; clear = false, color = :green, label = \"u\", title = \"t = $T\", legend = :best)\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/#275-:-Optimal-Control-Stokes","page":"Example275_OptimalControlStokes","title":"275 : Optimal Control Stokes","text":"","category":"section"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"(source code)","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This example studies the optimal control problem for the Stokes operator with divergence-free velocity space mathbfV_0 subset mathbfH^1_0, i.e., for given data mathbfu^d minimize the functional","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"beginaligned\nmin_(mathbfumathbfq) in mathbfV_0 times mathbfL^2  mathbfu - mathbfu^d ^2 + fracalpha2  mathbfq ^2\nquad textst  (mu nabla mathbfu nabla mathbfv) = (mathbfq mathbfv) quad textfor all  mathbfv in mathbfV_0\nendaligned","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This results in the set of variational equations that seeks (mathbfu mathbfz p  lambda) such that","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"beginaligned\n(mu nabla mathbfu nabla mathbfv) + (p mathrmdiv mathbfv)  = - alpha^-12 (mathbfz mathbfv)\n                                             (q mathrmdiv mathbfu)  = 0\n(mu nabla mathbfz nabla mathbfw) + (λ mathrmdiv mathbfw)  = alpha^-12 (mathbfu - mathbfu^d mathbfw)\n                                             (φ mathrmdiv mathbfz)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"for all test functions (mathbfv mathbfw q  varphi).","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"Here, we study pressure-robustness with the given data","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"mathbfu^d = mathrmcurl left(x^4y^4(x-1)^4(y-1)^4right) + epsilon nabla(cos(x)sin(y))","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"with a gradient field distortion that can be steered by ϵ geq 0 which was an example in the reference below.","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"reference: Reference\n\"Pressure-robustness in the context of optimal control\",\nC. Merdon and W. Wollner,\nSIAM Journal on Control and Optimization 61:1, 342-360 (2023),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"(Image: )","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"module Example275_OptimalControlStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Symbolics\n\nfunction prepare_data!(; ϵ = 0)\n\t@variables x y\n\n\t# stream function ξ\n\tξ = x^4*y^4*(x-1)^4*(y-1)^4\n\t∇ξ = Symbolics.gradient(ξ, [x,y])\n\n    # irrotational perturbation (to study pressure-robustness)\n    ϕ = cos(x)*sin(y)\n\t∇ϕ = Symbolics.gradient(ϕ, [x,y])\n\n    # final data = curl ξ + ϵ ∇ϕ\n\td = [-∇ξ[2], ∇ξ[1]] + ϵ * ∇ϕ\n\td_eval = build_function(d, x, y, expression = Val{false})\n\n    return d_eval[2]\nend\n\n# standard Stokes kernel\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops,1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ*∇u[1] + p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] + p[1]\n    result[5] = (∇u[1] + ∇u[4])\nend\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, μ = 1, α = 1e-6, ϵ = 0, kwargs...)\n\n    # prepare target data\n    d_eval = prepare_data!(; ϵ = ϵ)\n    data!(result, qpinfo) = (d_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n\n    # load mesh and refine\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    z = Unknown(\"z\"; name = \"control\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    λ = Unknown(\"λ\"; name = \"control pressure\", dim = 1)\n\n    # prepare reconstruction operator (if reconstruct = true)\n    idR(u) = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define optimal control problem\n    PD = ProblemDescription(\"Stokes optimal control problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, z)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, λ)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(z), id(λ)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator([idR(z)], [idR(u)]; factor = -1/sqrt(α), transposed_copy = -1, kwargs...))\n    assign_operator!(PD, LinearOperator(data!, [idR(z)]; factor = -1/sqrt(α), bonus_quadorder = 5, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(z; regions = 1:4, kwargs...))\n\n    # solve with Bernardi--Raugel method\n    FETypes = [H1BR{2}, L2P0{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 2]\n    sol = solve(PD, [FES[1],FES[1],FES[2],FES[2]]; kwargs...)\n\n    # plot solution\n    plt = plot([id(u), id(p), id(z), id(λ)], sol; add = 1, Plotter = Plotter)\n\n    # plot target data\n    I = FEVector(FES[1]; name = \"u^d\")\n    interpolate!(I[1], data!)\n    plot!(plt, [id(1)], I; keep = 1:4)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times, the printouts in the documentation are taken from a second run after compilations are done","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/#230-:-Nonlinear-Elasticity","page":"Example230_NonlinearElasticity","title":"230 : Nonlinear Elasticity","text":"","category":"section"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This example computes the displacement field u of the nonlinear elasticity problem","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"beginaligned\n-mathrmdiv(mathbbC (epsilon(u)-epsilon_T))  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"where an isotropic stress tensor mathbbC is applied to the nonlinear strain epsilon(u) = frac12(nabla u + (nabla u)^T + (nabla u)^T nabla u) and a misfit strain  epsilon_T = Delta T alpha due to thermal load caused by temperature(s) Delta T and thermal expansion coefficients alpha (that may be different) in the two regions of the bimetal.","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This example demonstrates how to setup a (parameter- and region-dependent) nonlinear expression and how to assign it to the problem description.","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"module Example230_NonlinearElasticity\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\n\n# parameter-dependent nonlinear operator uses a callable struct to reduce allocations\nmutable struct nonlinear_operator{T}\n\tλ::Vector{T}\n\tμ::Vector{T}\n\tϵT::Vector{T}\nend\n\nfunction strain!(result, input)\n\tresult[1] = input[1]\n\tresult[2] = input[4]\n\tresult[3] = input[2] + input[3]\n\n\t# add nonlinear part of the strain 1/2 * (grad(u)'*grad(u))\n\tresult[1] += 1 // 2 * (input[1]^2 + input[3]^2)\n\tresult[2] += 1 // 2 * (input[2]^2 + input[4]^2)\n\tresult[3] += input[1] * input[2] + input[3] * input[4]\n\treturn nothing\nend\n\n# kernel for nonlinear operator\n(op::nonlinear_operator)(result, input, qpinfo) = (\n\t# input = grad(u) written as a vector\n\t# compute strain and subtract thermal strain (all in Voigt notation)\n\tregion = qpinfo.region;\n\tstrain!(result, input);\n\tresult[1] -= op.ϵT[region];\n\tresult[2] -= op.ϵT[region];\n\n\t# multiply with isotropic stress tensor\n\t# (stored in input[5:7] using Voigt notation)\n\ta = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[1];\n\tb = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[2];\n\tc = 2 * op.μ[region] * result[3];\n\n\t# write strain into result\n\tresult[1] = a;\n\tresult[2] = c;\n\tresult[3] = c;\n\tresult[4] = b;\n\treturn nothing\n)\n\nconst op = nonlinear_operator([0.0, 0.0], [0.0, 0.0], [0.0, 0.0])\n\n# everything is wrapped in a main function\nfunction main(;\n\tν = [0.3, 0.3],          # Poisson number for each region/material\n\tE = [2.1, 1.1],          # Elasticity modulus for each region/material\n\tΔT = [580, 580],         # temperature for each region/material\n\tα = [1.3e-5, 2.4e-4],    # thermal expansion coefficients\n\tscale = [20, 500],       # scale of the bimetal, i.e. [thickness, width]\n\tnrefs = 0,              # refinement levels\n\torder = 2,              # finite element order\n\tperiodic = false,       # use periodic boundary conditions?\n\tPlotter = nothing,\n\tkwargs...)\n\n\t# compute Lame' coefficients μ and λ from ν and E\n\t# and thermal misfit strain and assign to operator operator\n\top.μ .= E ./ (2 .* (1 .+ ν .^ (-1)))\n\top.λ .= E .* ν ./ ((1 .- 2 * ν) .* (1 .+ ν))\n\top.ϵT .= ΔT .* α\n\n\t# generate bimetal mesh\n\txgrid = bimetal_strip2D(; scale = scale, n = 2 * (nrefs + 1))\n\tprintln(stdout, unicode_gridplot(xgrid))\n\n\t# create finite element space and solution vector\n\tFES = FESpace{H1Pk{2, 2, order}}(xgrid)\n\n\t# problem description\n\tPD = ProblemDescription()\n\tu = Unknown(\"u\"; name = \"displacement\")\n\tassign_unknown!(PD, u)\n\tassign_operator!(PD, NonlinearOperator(op, [grad(u)]; kwargs...))\n\tif periodic\n\t\t# periodic boundary conditions\n\t\t# 1) couple dofs left (bregion 1) and right (bregion 3) in y-direction\n\t\tdofsX, dofsY, factors = get_periodic_coupling_info(FES, xgrid, 1, 3, (f1, f2) -> abs(f1[2] - f2[2]) < 1e-14; factor_components = [0, 1])\n\t\tassign_operator!(PD, CombineDofs(u, u, dofsX, dofsY, factors; kwargs...))\n\t\t# 2) find and fix point at [0, scale[1]]\n\t\txCoordinates = xgrid[Coordinates]\n\t\tclosest::Int = 0\n\t\tmindist::Float64 = 1e30\n\t\tfor j ∈ 1:num_nodes(xgrid)\n\t\t\tdist = xCoordinates[1, j]^2 + (xCoordinates[2, j] - scale[1])^2\n\t\t\tif dist < mindist\n\t\t\t\tmindist = dist\n\t\t\t\tclosest = j\n\t\t\tend\n\t\tend\n\t\tassign_operator!(PD, FixDofs(u; dofs = [closest], vals = [0]))\n\telse\n\t\tassign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = [1, 0], kwargs...))\n\tend\n\n\t# solve\n\tsol = solve(PD, FES; kwargs...)\n\n\t# displace mesh and plot\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (3, 1), clear = true, size = (1000, 1500))\n\tgrad_nodevals = nodevalues(grad(u), sol)\n\tstrain_nodevals = zeros(Float64, 3, num_nodes(xgrid))\n\tfor j in 1:num_nodes(xgrid)\n\t\tstrain!(view(strain_nodevals, :, j), view(grad_nodevals, :, j))\n\tend\n\tscalarplot!(plt[1, 1], xgrid, view(strain_nodevals, 1, :), levels = 3, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_xx + displacement\")\n\tscalarplot!(plt[2, 1], xgrid, view(strain_nodevals, 2, :), levels = 1, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_yy + displacement\")\n\tvectorplot!(plt[1, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), spacing = [50, 25], clear = false)\n\tvectorplot!(plt[2, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), spacing = [50, 25], clear = false)\n\tdisplace_mesh!(xgrid, sol[u])\n\tgridplot!(plt[3, 1], xgrid, linewidth = 1, title = \"displaced mesh\")\n\tprintln(stdout, unicode_gridplot(xgrid))\n\n\treturn strain_nodevals, plt\nend\n\n# grid\nfunction bimetal_strip2D(; scale = [1, 1], n = 2, anisotropy_factor::Int = Int(ceil(scale[2] / (2 * scale[1]))))\n\tX = linspace(-scale[2] / 2, 0, (n + 1) * anisotropy_factor)\n\tX2 = linspace(0, scale[2] / 2, (n + 1) * anisotropy_factor)\n\tappend!(X, X2[2:end])\n\tY = linspace(0, scale[1], 2 * n + 1)\n\txgrid = simplexgrid(X, Y)\n\tcellmask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, scale[1] / 2], 1)\n\tcellmask!(xgrid, [-scale[2] / 2, scale[1] / 2], [scale[2] / 2, scale[1]], 2)\n\tbfacemask!(xgrid, [-scale[2] / 2, 0.0], [-scale[2] / 2, scale[1] / 2], 1)\n\tbfacemask!(xgrid, [-scale[2] / 2, scale[1] / 2], [-scale[2] / 2, scale[1]], 1)\n\tbfacemask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, 0.0], 2)\n\tbfacemask!(xgrid, [-scale[2] / 2, scale[1]], [scale[2] / 2, scale[1]], 2)\n\tbfacemask!(xgrid, [scale[2] / 2, 0.0], [scale[2] / 2, scale[1]], 3)\n\treturn xgrid\nend\n\nend","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/#284-:-Level-Set-Method","page":"Example284_LevelSetMethod","title":"284 : Level Set Method","text":"","category":"section"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"(source code)","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"This example studies the level-set method of some level function mathbfphi convected in time via the equation","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"beginaligned\nphi_t + mathbfu cdot nabla phi  = 0\nendaligned","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"Here this is tested with the (conservative) initial level set function phi(x) = 05 tanh((lvert x - (025025) rvert - 01)(2ϵ) + 1) such that the level phi equiv 05 forms a circle which is then convected by the velocity mathbfu = (051)^T. No reinitialisation step is performed.","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"The initial condition and the final solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"(Image: )","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"module Example284_LevelSetMethod\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing DifferentialEquations\n\nfunction ϕ_init!(result, qpinfo)\n\tx = qpinfo.x\n\tϵ = qpinfo.params[1]\n\tresult[1] = 1 / 2 * (tanh((sqrt((x[1] - 0.25)^2 + (x[2] - 0.25)^2) - 0.1) / (2 * ϵ)) + 1)\nend\n\nfunction kernel_convection!(result, input, qpinfo)\n\tresult[1] = 0.5 * input[1] + input[2]\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, ϵ = 0.05, τ = 1e-3, T = 0.4, order = 2, nref = 5, use_diffeq = true,\n\tsolver = ImplicitEuler(autodiff = false), kwargs...)\n\n\t# initial grid and final time\n\txgrid = uniform_refine(grid_unitsquare(Triangle2D), nref)\n\n\t# define main level set problem\n\tPD = ProblemDescription(\"level set problem\")\n\tϕ = Unknown(\"ϕ\"; name = \"level set function\")\n\tassign_unknown!(PD, ϕ)\n\tassign_operator!(PD, BilinearOperator(kernel_convection!, [id(ϕ)], [grad(ϕ)]; kwargs...))\n\tassign_operator!(PD, HomogeneousBoundaryData(ϕ; value = 1, regions = 1:4, kwargs...))\n\n\t# generate FESpace and solution vector and interpolate initial state\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\tsol = FEVector(FES; tags = PD.unknowns)\n\tinterpolate!(sol[ϕ], ϕ_init!; params = [ϵ])\n\n\t# prepare plot and plot init solution\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, resolution = (800, 400))\n\tscalarplot!(plt[1, 1], id(ϕ), sol; levels = [0.5], flimits = [-0.05, 1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = 0)\")\n\n\tif (use_diffeq)\n\t\t# generate DifferentialEquations.ODEProblem\n\t\tprob = generate_ODEProblem(PD, FES, (0.0, T); init = sol, constant_matrix = true)\n\n\t\t# solve ODE problem\n\t\tde_sol = DifferentialEquations.solve(prob, solver, abstol = 1e-6, reltol = 1e-4, dt = τ, dtmin = 1e-8, adaptive = true)\n\t\t@info \"#tsteps = $(length(de_sol))\"\n\n\t\t# get final solution\n\t\tsol.entries .= de_sol[end]\n\telse\n\t\t# add backward Euler time derivative\n\t\tM = FEMatrix(FES)\n\t\tassemble!(M, BilinearOperator([id(1)]))\n\t\tassign_operator!(PD, BilinearOperator(M, [ϕ]; factor = 1 / τ, kwargs...))\n\t\tassign_operator!(PD, LinearOperator(M, [ϕ], [ϕ]; factor = 1 / τ, kwargs...))\n\n\t\t# generate solver configuration\n\t\tSC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, constant_matrix = true, kwargs...)\n\n\t\t# iterate tspan\n\t\tt = 0\n\t\tfor it ∈ 1:Int(floor(T / τ))\n\t\t\tt += τ\n\t\t\tExtendableFEM.solve(PD, FES, SC; time = t)\n\t\tend\n\tend\n\n\t# plot final state\n\tscalarplot!(plt[1, 2], id(ϕ), sol; levels = [0.5], flimits = [-0.05, 1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = $T)\")\n\n\treturn sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdesolvers/#Stationary-Solvers","page":"Stationary Solvers","title":"Stationary Solvers","text":"","category":"section"},{"location":"pdesolvers/#Meshes-and-FESpaces","page":"Stationary Solvers","title":"Meshes and FESpaces","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Meshes are expected in the form of an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl. There is also an extension to read meshes from gmsh files.","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"FESpace{FEType}(grid::ExtendableGrid)","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Here, FEType denotes the type of finite element. A list of available FETypes can be found in the Documentation of ExtendableFEMBase.jl.","category":"page"},{"location":"pdesolvers/#Solve-(monolithic)","page":"Stationary Solvers","title":"Solve (monolithic)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. ","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"solve","category":"page"},{"location":"pdesolvers/#CommonSolve.solve","page":"Stationary Solvers","title":"CommonSolve.solve","text":"function solve(\n\tPD::ProblemDescription,\n\t[FES::Union{<:FESpace,Vector{<:FESpace}}],\n\tSC = nothing;\n\tunknowns = PD.unknowns,\n\tkwargs...)\n\nReturns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nThis function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\ntime: current time to be used in all time-dependent operators. Default: 0.0\nspy: show unicode spy plot of system matrix during solve. Default: false\nshow_config: show configuration at the beginning of solve. Default: false\npreconlinear: function that computes preconditioner for methodlinear incase an iterative solver is chosen. Default: nothing\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_matrix: show system matrix after assembly. Default: false\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\nDepending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"note: Note\nThe type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat costumized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.","category":"page"},{"location":"pdesolvers/#Solve-(iterating-subproblems)","page":"Stationary Solvers","title":"Solve (iterating subproblems)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"SolverConfiguration","category":"page"},{"location":"pdesolvers/#ExtendableFEM.SolverConfiguration","page":"Stationary Solvers","title":"ExtendableFEM.SolverConfiguration","text":"function iterate_until_stationarity(\n\tSolverConfiguration(Problem::ProblemDescription\n\t[FES::Union{<:FESpace, Vector{<:FESpace}}];\n\tinit = nothing,\n\tunknowns = Problem.unknowns,\n\tkwargs...)\n\nReturns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nKeyword arguments:\n\nverbosity: verbosity level. Default: 0\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\ntime: current time to be used in all time-dependent operators. Default: 0.0\nspy: show unicode spy plot of system matrix during solve. Default: false\nshow_config: show configuration at the beginning of solve. Default: false\npreconlinear: function that computes preconditioner for methodlinear incase an iterative solver is chosen. Default: nothing\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_matrix: show system matrix after assembly. Default: false\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"iterate_until_stationarity","category":"page"},{"location":"pdesolvers/#ExtendableFEM.iterate_until_stationarity","page":"Stationary Solvers","title":"ExtendableFEM.iterate_until_stationarity","text":"function iterate_until_stationarity(\n\tSCs::Array{<:SolverConfiguration, 1},\n\tFES = nothing;\n\tmaxsteps = 1000,\n\tinit = nothing,\n\tunknowns = [SC.PD.unknowns for SC in SCs],\n\tkwargs...)\n\nIterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corressponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.\n\nUsing the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by\n\nSolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)\n\nwith the usual keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example206_CoupledSubGridProblems/#206-:-CoupledSubGridProblems","page":"Example206_CoupledSubGridProblems","title":"206 : CoupledSubGridProblems","text":"","category":"section"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"(source code)","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"This example demonstrates how to solve a coupled problem where two variables only live on a sub-domain and are coupled through an interface condition. Consider the unit square domain cut in half through on of its diagonals. On each subdomain a solutiong u_j of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"with inhomogeneous boundary conditions on the former boundaries of the full square is searched. Along the common boundary between the two subdomains a new interface region is assigned (appended to BFaceNodes) and an interface condition is assembled that couples the two solutions u_1 and u_2 to each other. In this toy example, this interface conditions penalizes the jump between the two solutions on each side of the diagonal. Oberserve, that if the penalization factor tau is large, the two solutions are almost equal along the interface.","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"The computed solution(s) looks like this:","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"(Image: )","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"Each column of the plot shows the solution, the subgrid it lives on. The last row shows the full grid.","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"module Example206_CoupledSubGridProblems\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Test #\n\n\nfunction boundary_conditions!(result, qpinfo)\n    result[1] = 1 - qpinfo.x[1] - qpinfo.x[2] # used for both subsolutions\nend\n\nfunction interface_condition!(result, u, qpinfo)\n    result[1] = u[1] - u[2]\n    result[2] = -result[1]\nend\n\nfunction interface_condition_LM!(result, u, qpinfo)\n    result[1] = (u[1] - u[2])\nend\n\n\nfunction main(; μ = [1.0,1.0], f = [10,-10], τ = 1, use_LM = true, nref = 4, order = 2, Plotter = nothing, kwargs...)\n\n\t# Finite element type\n\tFEType = H1Pk{1, 2, order}\n    FETypeLM = H1Pk{1, 1, order}\n\n\t# generate mesh\n\txgrid = grid_unitsquare(Triangle2D)\n\n    # define regions\n    xgrid[CellRegions] = Int32[1,2,2,1]\n\n    # add an interface between region 1 and 2\n    # (one can use the BFace storages for that)\n    xgrid[BFaceNodes] = Int32[xgrid[BFaceNodes] [2 5; 5 4]]\n    append!(xgrid[BFaceRegions], [5,5])\n    xgrid[FaceRegions][xgrid[BFaceFaces][end-1:end]] .= 5\n    xgrid[BFaceGeometries] = VectorOfConstants{ElementGeometries, Int}(Edge1D, 6)\n\n    # refine\n    xgrid = uniform_refine(xgrid, nref)\n\n    # define an FESpace just on region 1 and one just on region 2\n    FES1 = FESpace{FEType}(xgrid; regions = [1])\n    FES2 = FESpace{FEType}(xgrid; regions = [2])\n    if use_LM\n        FES3 = FESpace{FETypeLM, ON_FACES}(xgrid; regions = [5])\n        @show FES3.xgrid FES3.dofgrid\n    end\n\n    # define variables\n    u1 = Unknown(\"u1\"; name = \"potential in region 1\")\n    u2 = Unknown(\"u2\"; name = \"potential in region 2\")\n    p = Unknown(\"p\"; name = \"LM for interface condition\")\n\n    # problem description\n\tPD = ProblemDescription()\n\tassign_unknown!(PD, u1)\n\tassign_unknown!(PD, u2)\n\tassign_operator!(PD, BilinearOperator([grad(u1)]; regions = [1], factor = μ[1], kwargs...))\n\tassign_operator!(PD, BilinearOperator([grad(u2)]; regions = [2], factor = μ[2], kwargs...))\n    assign_operator!(PD, LinearOperator([id(u1)]; regions = [1], factor = f[1]))\n    assign_operator!(PD, LinearOperator([id(u2)]; regions = [2], factor = f[2]))\n    if use_LM\n        assign_unknown!(PD, p)\n        assign_operator!(PD, BilinearOperator(interface_condition_LM!, [id(p)], [id(u1), id(u2)]; regions = [5], transposed_copy = 1, entities = ON_FACES, kwargs...))\n    else\n\t    assign_operator!(PD, BilinearOperator(interface_condition!, [id(u1), id(u2)]; regions = [5], factor = τ, entities = ON_FACES, kwargs...))\n    end\n\tassign_operator!(PD, InterpolateBoundaryData(u1, boundary_conditions!; regions = 1:4))\n\tassign_operator!(PD, InterpolateBoundaryData(u2, boundary_conditions!; regions = 1:4))\n\n    sol = solve(PD, use_LM ? [FES1, FES2, FES3] : [FES1, FES2])\n\n    plt = plot([id(u1), id(u2), dofgrid(u1), dofgrid(u2), grid(u1)], sol; Plotter = Plotter)\n\n\treturn sol, plt\nend\n\n\nend #module","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tensordescription/#Tensor-Description","page":"Tensor Description","title":"Tensor Description","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"To be able to construct reshaped views  of the test functions and their derivates, we can describe the  shape of the view through a TensorDescription{R,D}  where R is the rank of the tensor and D is the dimension  or extent of the tensor in each of the R directions.  That means a real valued R-tensor is an element of  underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.  Specifically, we can identify the following mathematical objects with  tensors of different ranks:","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"math. object R-Tensor\nscalar inmathbbR 0-Tensor\nvector inmathbbR^D 1-Tensor\nmatrix inmathbbR^DtimesmathbbR^D 2-Tensor","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For finite elements, D usually matches the spatial dimension of  the problem we want to solve, i.e. D=2 for 2D and D=3 for 3D.","category":"page"},{"location":"tensordescription/#Tensor-Types","page":"Tensor Description","title":"Tensor Types","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"ExtendableFEM.TensorDescription\nExtendableFEM.TDScalar\nExtendableFEM.TDVector\nExtendableFEM.TDMatrix\nExtendableFEM.TDRank3\nExtendableFEM.TDRank4","category":"page"},{"location":"tensordescription/#ExtendableFEM.TensorDescription","page":"Tensor Description","title":"ExtendableFEM.TensorDescription","text":"TensorDescription{R,D}\n\nGeneral type for an R-tensor of dimension/extent D. Mathematically, this describes the shape of an element  in underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.\n\nSee also:  TDScalar{D}, TDVector{D}, TDMatrix{D}, TDRank3{D}, TDRank4{D}\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDScalar","page":"Tensor Description","title":"ExtendableFEM.TDScalar","text":"TDScalar{D}\n\nSpecification for a 0-tensor or scalar, i.e. TensorDescription{0,D}, to improve readability.\n\nNote that in this case D has no greater effect  and is only provided to have a matching interface  between all the specifications.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDVector","page":"Tensor Description","title":"ExtendableFEM.TDVector","text":"TDVector{D}\n\nSpecification for a 1-tensor or vector, i.e. TensorDescription{1,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDMatrix","page":"Tensor Description","title":"ExtendableFEM.TDMatrix","text":"TDMatrix{D}\n\nSpecification for a 2-tensor or matrix, i.e. TensorDescription{2,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank3","page":"Tensor Description","title":"ExtendableFEM.TDRank3","text":"TDRank3{D}\n\nSpecification for a 3-tensor, i.e. TensorDescription{3,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank4","page":"Tensor Description","title":"ExtendableFEM.TDRank4","text":"TDRank4{D}\n\nSpecification for a 4-tensor, i.e. TensorDescription{4,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#Reshaped-views","page":"Tensor Description","title":"Reshaped views","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"Modules = [ExtendableFEM]\nPages = [\"tensors.jl\"]\nOrder   = [:function]","category":"page"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDMatrix{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{2,dim})\n\nReturns a view of input[i:i+dim^2-1] reshaped as a (dim,dim) matrix.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank3{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{3,dim})\n\nReturns a view of input[i:i+dim^3-1] reshaped as a (dim,dim,dim) 3-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank4{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{4,dim})\n\nReturns a view of input[i:i+dim^4-1] reshaped as (dim,dim,dim,dim) 4-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDScalar{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{0,dim})\n\nReturns a view of input[i] reshaped as a vector of length 1.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDVector{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{1,dim})\n\nReturns a view of input[i:i+dim-1] reshaped as a vector of length dim.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{rank}, Tuple{Any, Int64, TensorDescription{rank, dim}}} where {rank, dim}","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{rank,dim})\n\nReturns a view of input[i] and subsequent entries,  reshaped as a rank-tensor of dimension dim.\n\nNote that this general implementation is a fallback for rank>4 that will likely produce allocations and slow assembly  times if used in a kernel function.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#Which-tensor-for-which-unknown?","page":"Tensor Description","title":"Which tensor for which unknown?","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For an unknown variable u of tensor rank r  a derivative of order n has rank r+n, i.e. the hessian (n=2) of a scalar unknown (rank 0) and the gradient (n=1) of a vector valued (rank 1)  variable are both matrices (rank 2).","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For a more comprehensive list see the following table","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"derivative order scalar-valued vector-valued matrix-valued\n0 (value/id) TDScalar(D) TDVector(D) TDMatrix(D)\n1 (grad) TDVector(D) TDMatrix(D) TDRank3(D)\n2 (hessian) TDMatrix(D) TDRank3(D) TDRank4(D)\n3 TDRank3(D) TDRank4(D) TensorDescription(5,D)\n4 TDRank4(D) TensorDescription(5,D) TensorDescription(6,D)\nvdots vdots vdots vdots","category":"page"},{"location":"tensordescription/#Helpers","page":"Tensor Description","title":"Helpers","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"tmul!","category":"page"},{"location":"tensordescription/#ExtendableFEM.tmul!","page":"Tensor Description","title":"ExtendableFEM.tmul!","text":"function tmul!(y,A,x,α=1.0,β=0.0)\n\nCombined inplace  matrix-vector multiply-add A^T x α + y β. The result is stored in y by overwriting it.  Note that y must not be aliased with either A or x.\n\n\n\n\n\nfunction tmul!(y::AbstractVector{T}, A::AbstractMatrix{T}, x::AbstractVector{T}, α=1.0, β=0.0) where {T<:AbstractFloat}\n\nOverload of the generic function for types supported by  LinearAlgebra.BLAS.gemv! to avoid slow run times for large inputs.\n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example265_FlowTransport/#265-:-Flow-Transport","page":"Example265_FlowTransport","title":"265 : Flow + Transport","text":"","category":"section"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"(source code)","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"This example solve the Stokes problem in an Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a stationary species concentration mathbfc such that","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nmathbfc_t - kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"with some viscosity parameter and diffusion parameter kappa.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation three possibilities can be chosen:","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Classical Bernardi–Raugel stationary finite element discretisations mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = false]\nAs in 1. but with divergence-free reconstruction operator in convection term Pi_textreconst mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = true]\nTime-dependent upwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces [set FVtransport = true]","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Observe that the divergence-free postprocessing helps a lot for mass conservation, but is still not perfect. The finite volume upwind discretisation ensures mass conservation.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"(Image: )","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"module Example265_FlowTransport\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n# boundary data\nfunction u_inlet!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 4*x[2]*(1-x[2])\n    result[2] = 0\nend\nfunction c_inlet!(result, qpinfo)\n    result[1] = (1-qpinfo.x[2])*qpinfo.x[2]\nend\n\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops,1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\nend\n\nfunction kernel_convection!(result, ∇T, u, qpinfo)\n    result[1] = ∇T[1]*u[1] + ∇T[2]*u[2]\nend\n\nfunction kernel_inlet!(result, input, qpinfo)\n    c_inlet!(result, qpinfo)\n    result[1] *= -input[1]\nend\n\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, FVtransport = true, μ = 1, kwargs...)\n\n    # load mesh and refine\n    xgrid = uniform_refine(simplexgrid(Triangulate;\n    points = [0 0; 3 0; 3 -3; 7 -3; 7 0; 10 0; 10 1; 6 1; 6 -2; 4 -2; 4 1; 0 1]',\n    bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 12; 12 1]',\n    bfaceregions = [1; 1; 1; 1; 1; 2; 3; 3; 3; 3; 3; 4],\n    regionpoints = [0.5 0.5;]',\n    regionnumbers = [1],\n    regionvolumes = [1.0]), nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    T = Unknown(\"T\"; name = \"temperature\", dim = 1)\n\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u_inlet!; regions = 4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1,3], kwargs...))\n\n    # add transport equation of species\n    PDT = ProblemDescription(\"transport problem\")\n    assign_unknown!(PDT, T)\n    if FVtransport ## FVM discretisation of transport equation (pure upwind convection)\n        τ = 1e3\n        assign_operator!(PDT, CallbackOperator(assemble_fv_operator!(), [u]; kwargs...))\n        assign_operator!(PDT, BilinearOperator([id(T)]; store = true, factor = 1/τ, kwargs...))\n        assign_operator!(PDT, LinearOperator([id(T)], [id(T)]; factor = 1/τ, kwargs...))\n    else ## FEM discretisation of transport equation (with small diffusion term)\n        assign_operator!(PDT, BilinearOperator([grad(T)]; factor = 1e-6, kwargs...))\n        assign_operator!(PDT, BilinearOperator(kernel_convection!, [id(T)], [grad(T)], [id_u]; kwargs...))\n        assign_operator!(PDT, InterpolateBoundaryData(T, c_inlet!; regions = [4], kwargs...))\n    end\n\n    # generate FESpaces and a solution vector for all 3 unknowns\n    FETypes = [H1BR{2}, L2P0{1}, FVtransport ? L2P0{1} : H1P1{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j = 1 : 3]\n    sol = FEVector(FES; tags = [u,p,T])\n\n    # solve the two problems separately\n    sol = solve(PD; init = sol, kwargs...)\n    sol = solve(PDT; init = sol, maxiterations = 20, target_residual = 1e-12, constant_matrix = true, kwargs...)\n\n    # print minimal and maximal concentration to check max principle (shoule be in [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(view(sol[T]))),$(maximum(view(sol[T])))]\")\n\n    # plot\n    plt = plot([id(u), id(T)], sol; Plotter = Plotter, ncols = 1, spacing = 0.25, width = 800, height = 800)\n\n    return sol, plt\nend\n\n# pure convection finite volume operator for transport\nfunction assemble_fv_operator!()\n\n    BndFluxIntegrator = ItemIntegrator(kernel_inflow!, [normalflux(1)]; entities = ON_BFACES)\n    FluxIntegrator = ItemIntegrator([normalflux(1)]; entities = ON_FACES)\n    fluxes::Matrix{Float64} = zeros(Float64,1,0)\n\n    function closure(A, b, args; assemble_matrix = true, assemble_rhs = true, kwargs...)\n\n    # prepare grid and stash\n    xgrid = args[1].FES.xgrid\n    nfaces = size(xgrid[FaceCells],2)\n    if size(fluxes,2) < nfaces\n        fluxes = zeros(Float64, 1, nfaces)\n    end\n\n    # right-hand side = boundary inflow fluxes if velocity points inward\n    if assemble_rhs\n        fill!(fluxes, 0)\n        evaluate!(fluxes, BndFluxIntegrator, [args[1]])\n        facecells = xgrid[FaceCells]\n        bface2face = xgrid[BFaceFaces]\n        for bface in 1 : lastindex(bface2face)\n            b[facecells[1, bface2face[bface]]] -= fluxes[bface]\n        end\n    end\n\n    # assemble upwind finite volume fluxes over cell faces into matrix\n    if assemble_matrix\n        # integrate normalfux of velocity\n        fill!(fluxes, 0)\n        evaluate!(fluxes, FluxIntegrator, [args[1]])\n\n        cellfaces = xgrid[CellFaces]\n        cellfacesigns = xgrid[CellFaceSigns]\n        for cell = 1 : num_cells(xgrid)\n            nfaces4cell = num_targets(cellfaces, cell)\n            for cf = 1 : nfaces4cell\n                face = cellfaces[cf,cell]\n                other_cell = facecells[1,face]\n                if other_cell == cell\n                    other_cell = facecells[2,face]\n                end\n                flux = fluxes[face] * cellfacesigns[cf,cell]\n                if (other_cell > 0)\n                    flux *= 1 // 2 # because it will be accumulated on two cells\n                end\n                if flux > 0 # flow from cell to other_cell or out of domain\n                    _addnz(A,cell,cell,flux,1)\n                    if other_cell > 0\n                        _addnz(A,other_cell,cell,-flux,1)\n                        # otherwise flow goes out of domain\n                    end\n                else # flow from other_cell into cell or into domain\n                    _addnz(A,cell,cell,1e-16,1) # add zero to keep pattern for LU\n                    if other_cell > 0 # flow comes from neighbour cell\n                        _addnz(A,other_cell,other_cell,-flux,1)\n                        _addnz(A,cell,other_cell,flux,1)\n                    end\n                    # otherwise flow comes from outside into domain, handled in rhs side loop above\n                end\n            end\n        end\n    end\n    return nothing\n    end\nend\n\n\nfunction kernel_inflow!(result, input, qpinfo)\n    if input[1] < 0 # if velocity points into domain\n        c_inlet!(result, qpinfo)\n        result[1] *= input[1]\n    else\n        result[1] = 0\n    end\nend\n\nend # module","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/#204-:-Eigenvalue-problem-for-the-Laplacian","page":"Example204_LaplaceEVProblem","title":"204 : Eigenvalue problem for the Laplacian","text":"","category":"section"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"This example computes the pairs of eigenvalues and eigenvectors (lambdau) in mathbbR times H^1_0(Omega) of the Laplacian, i.e,","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"beginaligned\n-Delta u  = lambda u quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"on a two-dimensional L-shaped domain with homogeneous boundary conditions with the help of an iterative solver from KrylovKit.jl. The first twelve computed eigenvectors look like this:","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"module Example204_LaplaceEVProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing GridVisualize\nusing KrylovKit\n\nfunction main(; which = 1:12, ncols = 3, nrefs = 4, order = 1, Plotter = nothing, kwargs...)\n\n\t# discretize\n\txgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n\tFES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n\t# assemble operators\n\tA = FEMatrix(FES)\n\tB = FEMatrix(FES)\n\tu = FEVector(FES; name = \"u\")\n\tassemble!(A, BilinearOperator([grad(1)]; kwargs...))\n\tassemble!(A, BilinearOperator([id(1)]; entities = ON_BFACES, factor = 1e4, kwargs...))\n\tassemble!(B, BilinearOperator([id(1)]; kwargs...))\n\n\t# solver generalized eigenvalue problem iteratively with KrylovKit\n\tλs, x, info = geneigsolve((A.entries, B.entries), maximum(which), :SR; maxiter = 4000, issymmetric = true, tol = 1e-8)\n\t@show info\n\t@assert info.converged >= maximum(which)\n\n\t# plot requested eigenvalue pairs\n\tnEVs = length(which)\n\tnrows = Int(ceil(nEVs / ncols))\n\tplt = GridVisualizer(; Plotter = Plotter, layout = (nrows, ncols), clear = true, resolution = (900, 900 / ncols * nrows))\n\tcol, row = 0, 1\n\tfor j in which\n\t\tcol += 1\n\t\tif col == ncols + 1\n\t\t\tcol, row = 1, row + 1\n\t\tend\n\t\tλ = λs[j]\n\t\t@info \"λ[$j] = $λ, residual = $(sum(info.residual[j]))\"\n\t\tu.entries .= Real.(x[j])\n\t\tscalarplot!(plt[row, col], id(1), u; Plotter = Plotter, title = \"λ[$j] = $(Float16(λ))\")\n\tend\n\n\treturn u, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"This page was generated using Literate.jl.","category":"page"}]
}
