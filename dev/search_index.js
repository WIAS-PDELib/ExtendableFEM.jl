var documenterSearchIndex = {"docs":
[{"location":"homogeneousdata/#HomogeneousData","page":"HomogeneousData","title":"HomogeneousData","text":"","category":"section"},{"location":"homogeneousdata/","page":"HomogeneousData","title":"HomogeneousData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/homogeneousdata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousData","text":"function HomogeneousData(u; entities = ON_CELLS, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the specifies entities and entity regions (via kwargs).\n\nKeyword arguments:\n\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nregions: subset of regions where operator should be assembly only. Default: Any[]\nvalue: constant value of the data. Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousBoundaryData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousBoundaryData","text":"function HomogeneousBoundaryData(u; entities = ON_BFACES, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the boundary faces and boundary regions (via kwargs).\n\nKeyword arguments:\n\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nregions: subset of regions where operator should be assembly only. Default: Any[]\nvalue: constant value of the data. Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder   = [:function, :type]","category":"page"},{"location":"parallel_assembly/#Parallel-Assembly","page":"Parallel Assembly","title":"Parallel Assembly","text":"","category":"section"},{"location":"parallel_assembly/","page":"Parallel Assembly","title":"Parallel Assembly","text":"Within the solve call, all operators will be assembled according to their configured parameters. When 'parallel = true' is used (not available yet for all DG operators), the operators will be assembled in parallel based on the color partitions within the grid. Hence, the computational grid must provide these partitions, see Documentation of ExtendableGrids.jl on Partitioning for details. Also the sparse system matrix needs to be able to work on different partitions in parallel. Once, the grid has partitions, the solver automatically uses a suitable constructor for the system matrix (MTExtendableSparseMatrixCSC from ExtendableSparse.jl).","category":"page"},{"location":"parallel_assembly/","page":"Parallel Assembly","title":"Parallel Assembly","text":"note: Note\nDG operators that assemble along cell faces need the option 'edges = true' in the partition call for the grid partitioning, otherwise assembly will be still sequentially.","category":"page"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Exported","page":"Index","title":"Exported","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"ExtendableFEM","category":"page"},{"location":"allindex/#ExtendableFEM","page":"Index","title":"ExtendableFEM","text":"ExtendableFEM\n\n(Image: Build status) (Image: ) (Image: ) (Image: DOI) (Image: code style: runic)\n\nExtendableFEM\n\nHigh Level API Finite Element Methods based on ExtendableGrids.jl (for grid management) and ExtendableFEMBase.jl (for finite element basis functions and dof management).  It offers a ProblemDescription interface, that basically involves assigning Unknowns and Operators. Such operators usually stem from a weak formulation of the problem and mainly consist of three types that can be customized via kernel functions:\n\nBilinearOperator,\nLinearOperator,\nNonlinearOperator (that automatically assemble Newton's method by automatic differentiation)\n\nQuick Example\n\nThe following minimal example demonstrates how to setup a Poisson problem.\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# build/load any grid (here: a uniform-refined 2D unit square into triangles)\nxgrid = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n# create empty PDE description\nPD = ProblemDescription()\n\n# create and assign unknown\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\n\n# assign Laplace operator\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\n\n# assign right-hand side data\nfunction f!(fval, qpinfo)\n    x = qpinfo.x # global coordinates of quadrature point\n    fval[1] = x[1] * x[2]\nend\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\n\n# assign boundary data (here: u = 0)\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n# discretise = choose FESpace\nFEType = H1Pk{1,2,3} # cubic H1-conforming element with 1 component in 2D\nFES = FESpace{FEType}(xgrid)\n\n# solve\nsol = solve!(Problem, [FES])\n\n# plot\nusing PyPlot\nplot(id(u), sol; Plotter = PyPlot)\n\n\n\n\n\n","category":"module"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:function]","category":"page"},{"location":"callbackoperator/#CallbackOperator","page":"CallbackOperator","title":"CallbackOperator","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"A callback operator passes the matrix and rhs to a user-defined function where they can be modified as desired. An example where this is used is Example265.","category":"page"},{"location":"callbackoperator/#Constructors","page":"CallbackOperator","title":"Constructors","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/callback_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"callbackoperator/#ExtendableFEM.CallbackOperator","page":"CallbackOperator","title":"ExtendableFEM.CallbackOperator","text":"function CallbackOperator(\n\tcallback!::Function,\n\tu_args = [];\n\tkwargs...)\n\nGenerates an operator that simply passes the matrix and rhs to a user-specified call back function. The callback function needs to be conform to the interface\n\ncallback!(A, b, args; assemble_matrix = true, assemble_rhs = true, time = 0, kwargs...)\n\nThe u_args argument can be used to specify the arguments of the solution that should be passed as args (a vector of FEVectorBlocks) to the callback.\n\nKeyword arguments:\n\nlinearized_dependencies: [uansatz, utest] when linearized. Default: auto\nmodifies_matrix: callback function modifies the matrix?. Default: true\nmodifies_rhs: callback function modifies the rhs?. Default: true\nname: name for operator used in printouts. Default: ''CallbackOperator''\nstore: store matrix and rhs separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"fixdofs/#FixDofs","page":"FixDofs","title":"FixDofs","text":"","category":"section"},{"location":"fixdofs/","page":"FixDofs","title":"FixDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/fixdofs_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fixdofs/#ExtendableFEM.FixDofs-Tuple{Any}","page":"FixDofs","title":"ExtendableFEM.FixDofs","text":"function FixDofs(u; vals = [], dofs = [], kwargs...)\n\nWhen assembled, all specified dofs of the unknown u will be penalized to the specified values.\n\nKeyword arguments:\n\nname: name for operator used in printouts. Default: ''FixDofs''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Problem-Description","page":"Problem Description","title":"Problem Description","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Central object is the ProblemDescription which is given as a weak form of your problem and usually does not need any information on the discretisation at this point (but of course can depend on region numbers).","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"ProblemDescription","category":"page"},{"location":"problemdescription/#ExtendableFEM.ProblemDescription","page":"Problem Description","title":"ExtendableFEM.ProblemDescription","text":"struct ProblemDescription\n\nStructure holding data for a problem description with the following fields:\n\nname::String: The name of the problem used for printout messages. Default: \"My Problem\"\n\nunknowns::Vector{Unknown}: A vector of Unknowns that are involved in the problem.\n\noperators::Vector{ExtendableFEM.AbstractOperator}: A vector of operators that are involved in the problem.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#Constructors-and-assign-functions","page":"Problem Description","title":"Constructors and assign functions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"problemdescription.jl\"]\nOrder   = [:function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.assign_operator!-Tuple{ProblemDescription, ExtendableFEM.AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.assign_operator!","text":"assign_operator!(PD::ProblemDescription, o::AbstractOperator)\n\nAssigns the AbstractOperator o to the ProblemDescription PD and returns its position in the operators array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.assign_unknown!-Tuple{ProblemDescription, Unknown}","page":"Problem Description","title":"ExtendableFEM.assign_unknown!","text":"assign_unknown!(PD::ProblemDescription, u::Unknown)\n\nAssigns the Unknown u to the ProblemDescription PD and returns its position in the unknowns array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.replace_operator!-Tuple{ProblemDescription, Any, ExtendableFEM.AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.replace_operator!","text":"replace_operator!(PD::ProblemDescription, j::Int, o::AbstractOperator)\n\nReplaces the j-th operator of the ProblemDescription PD by the new operator o. Here, j is the position in operator array returned by the assign_operator! function. Nothing is returned (as the new operator gets position j).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Unknowns","page":"Problem Description","title":"Unknowns","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"An Unknown is an identifies that encodes a physical quantity in the ProblemDescription.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"unknowns.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Unknown","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"struct Unknown\n\nStructure holding information for an unknown with the following fields:\n\nname::String: The name of the unknown used for printout messages.\n\nidentifier::Any: The identifier of the unknown used for assignments to operators.\n\nparameters::Dict{Symbol, Any}: Further properties of the unknown can be stored in a Dict, see constructor.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Unknown-Tuple{String}","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"function Unknown(\n\tu::String;\n\tidentifier = Symbol(u),\n\tname = u,\n\tkwargs...)\n\nGenerates and returns an Unknown with the specified name, identifier and other traits.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nalgebraic_constraint: is this unknown an algebraic constraint?. Default: nothing\ndimension: dimension of the unknown. Default: nothing\nsymbol_ansatz: symbol for ansatz functions of this unknown in printouts. Default: nothing\nsymbol_test: symbol for test functions of this unknown in printouts. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Base.div-Tuple{Any}","page":"Problem Description","title":"Base.div","text":"div(u)\n\nalias for (u, Divergence)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.apply-Tuple{Any, Type{<:??}}","page":"Problem Description","title":"ExtendableFEM.apply","text":"apply(u, FO::Type{<:AbstractFunctionOperator})\n\nalias for (u, FO)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.average-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.average","text":"average(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Average{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl1-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl1","text":"curl1(u)\n\nalias for (u, CurlScalar)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl2-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl2","text":"curl2(u)\n\nalias for (u, Curl2D)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl3-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl3","text":"curl3(u)\n\nalias for (u, Curl3D)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.dofgrid-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.dofgrid","text":"dofgrid(u)\n\nalias for (u, \"dofgrid\") (triggers gridplot for the dofgrid in plot)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.grad-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.grad","text":"grad(u)\n\nalias for (u, Gradient)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.grid-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.grid","text":"grid(u)\n\nalias for (u, \"grid\") (triggers gridplot in plot)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.hessian-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.hessian","text":"hessian(u)\n\nalias for (u, Hessian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.id-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.id","text":"id(u)\n\nalias for (u, Identity)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.jump-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.jump","text":"jump(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Jump{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.laplace-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.laplace","text":"laplace(u)\n\nalias for (u, Laplacian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.normalflux-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.normalflux","text":"normalflux(u)\n\nalias for (u, NormalFlux)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.other-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.other","text":"other(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Right{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.symgrad_voigt-Tuple{Any, Any}","page":"Problem Description","title":"ExtendableFEM.symgrad_voigt","text":"symgrad_voigt(u, factor)\n\nalias for (u, SymmetricGradient{factor}) in Voigt notation.\n\nThe factor is a real number applied to the (summed) off-diagonal entries. In the current implementation in ExtendableFEMBase, factor = 0.5 represents the Voigt strain mapping [σ₁₁ σ₂₂ σ₃₃ σ₁₃ σ₂₃ σ₁₂], while factor = 1.0 represents the Voigt strain mapping [ε₁₁ ε₂₂ ε₃₃ 2ε₁₃ 2ε₂₃ 2ε₁₂].\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.tangentialflux-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.tangentialflux","text":"tangentialflux(u)\n\nalias for (u, TangentFlux)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.tangentialgrad-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.tangentialgrad","text":"tangentialgrad(u)\n\nalias for (u, TangentialGradient)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.this-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.this","text":"this(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Left{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.Δ-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.Δ","text":"Δ(u)\n\nalias for (u, Laplacian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.εV-Tuple{Any, Any}","page":"Problem Description","title":"ExtendableFEM.εV","text":"εV(u, factor)\n\nunicode alias for symgrad_voigt(u, factor).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Operators","page":"Problem Description","title":"Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Operator is a quite general concept and is everything that makes modifications to the system matrix, hence classical representations of weak discretisations of differential operators, penalisations for boundary conditions or constraints, or stabilisation terms.","category":"page"},{"location":"problemdescription/#Types-of-operators","page":"Problem Description","title":"Types of operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The three most important operator classes are:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"NonlinearOperator (e.g. the convection term in a Navier-Stokes problem)\nBilinearOperator (e.g. the Laplacian in a Poisson problem)\nLinearOperator (e.g. the right-hand side in a Poisson or Navier-Stokes problem)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"To assign boundary conditions or global constraints there are three possibilities:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"InterpolateBoundaryData\nHomogeneousData\nFixDofs\nCombineDofs","category":"page"},{"location":"problemdescription/#Entities-and-Regions","page":"Problem Description","title":"Entities and Regions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Each operator assembles on certain entities of the mesh, the default is a cell-wise assembly. Most operators have the entities kwarg to changes that. Restrictions to subsets of the entities can be made via the regions kwarg.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Entities Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate on the cells of the mesh\nON_FACES assemble/interpolate on all faces of the mesh\nON_IFACES assemble/interpolate on the interior faces of the mesh\nON_BFACES assemble/interpolate on the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate on all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate on the boundary edges of the mesh (in 3D)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"problemdescription/#Function-Operators","page":"Problem Description","title":"Function Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The definition of operators often involves paris of an Unknown and a FunctionOperator (or an alias as listed above). FunctionOperators are something like Identity, Gradient etc. (see here for a complete list). Additional FunctionOperators for the evaluation of discontinuous operators on faces available (needed in particular for defining operators in  DG context or face terms in a posteriori error estimators):","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"jump_operators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Average","page":"Problem Description","title":"ExtendableFEM.Average","text":"Average{StandardFunctionOperator}\n\nevaluates the average of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.DiscontinuousFunctionOperator","page":"Problem Description","title":"ExtendableFEM.DiscontinuousFunctionOperator","text":"DiscontinuousFunctionOperator\n\nSubtype of AbstractFunctionOperator dedicated to evaluations of discontinuous quantities on faces like jumps, averages etc.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Jump","page":"Problem Description","title":"ExtendableFEM.Jump","text":"Jump{StandardFunctionOperator}\n\nevaluates the jump of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Left","page":"Problem Description","title":"ExtendableFEM.Left","text":"Left{StandardFunctionOperator}\n\nevaluates the left (w.r.t. orientation of the face) value of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Right","page":"Problem Description","title":"ExtendableFEM.Right","text":"Average{StandardFunctionOperator}\n\nevaluates the right (w.r.t. orientation of the face) value of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"faceinterpolator/#Face-interpolator","page":"Face interpolator","title":"Face interpolator","text":"","category":"section"},{"location":"faceinterpolator/","page":"Face interpolator","title":"Face interpolator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/discface_interpolator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"faceinterpolator/#ExtendableFEM.FaceInterpolator-Tuple{Any, Any, Any}","page":"Face interpolator","title":"ExtendableFEM.FaceInterpolator","text":"function FaceInterpolator(\n\t[kernel,]\n\tu_args,\n\tops_args;\n\tTv = Float64,\n\tTi = Int,\n\tkwargs...)\n\nGenerates a FaceInterpolator that evaluates discontinuous function operator of its arguments, possibly further postprocessed via a kernel function of interface function kernel(result, input, qpinfo), into a FEVector of H1Pk living on the faces of the grid with the fitting order and number of components.\n\nKeyword arguments:\n\nname: name for operator used in printouts. Default: ''Projector''\nonly_interior: only interior faces, interpolation of boundary faces will be zero. Default: false\norder: interpolation order (default: match order of applied finite element space). Default: ''auto''\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: true\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"faceinterpolator/#ExtendableFEMBase.evaluate!-Union{Tuple{UT}, Tuple{Ti}, Tuple{Tv}, Tuple{FaceInterpolator{Tv, Ti, UT}, Any}} where {Tv, Ti, UT}","page":"Face interpolator","title":"ExtendableFEMBase.evaluate!","text":"function evaluate!(O::FaceInterpolator{Tv, Ti, UT}, sol; kwargs...)\n\nEvaluates the FaceInterpolator using the blocks of sol as arguments and returns the FEVector with the results.\n\n\n\n\n\n","category":"method"},{"location":"nonlinearoperator/#NonlinearOperator","page":"NonlinearOperator","title":"NonlinearOperator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"A nonlinear operator automatically assembles all necessary terms for the Newton method. Other linearisations of a nonlinear operator can be constructed with special constructors for BilinearOperator or LinearOperator.","category":"page"},{"location":"nonlinearoperator/#Constructor","page":"NonlinearOperator","title":"Constructor","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To describe a NonlinearOperator we have to specify a kernel function.  These functions are 'flat' in the sense that the input and output vector  contain the components of the test-function values and derivatives as specified by oa_test and oa_args respectively. The assembly of the local matrix will be done internally  by multiplying the subvectors of result with its test-function counterparts. For a more detailed explanation of this see the following","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/nonlinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"nonlinearoperator/#ExtendableFEM.NonlinearOperator","page":"NonlinearOperator","title":"ExtendableFEM.NonlinearOperator","text":"function NonlinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tjacobian = nothing,\n\tkwargs...)\n\nGenerates a nonlinear form for the specified kernel function, test function operators, and argument operators evaluations. Operator evaluations are tuples that pair an unknown identifier or integer with a FunctionOperator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, input, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nDuring assembly the Newton update is computed via local jacobians of the kernel which are calculated by automatic differentiation or by the user-provided jacobian function with interface\n\njacobian!(jac, input_args, params)\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nextra_inputsize: additional entries in input vector (e.g. for type-stable storage for intermediate results). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''NonlinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nsparse_jacobians: use sparse jacobians. Default: true\nsparse_jacobians_pattern: user provided sparsity pattern for the sparse jacobians (in case automatic detection fails). Default: nothing\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"nonlinearoperator/#Example-NSE-convection-operator","page":"NonlinearOperator","title":"Example - NSE convection operator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"For the Navier–Stokes equations, we need a kernel function for the nonlinear convection term","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n(vucdotnabla u) = (vnabla u^T u)\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"In 2D the input (as specified below) will contain the two components of u=(u_1u_2) and the four components of the gradient  nabla u = beginpmatrix u_11  u_12  u_21  u_22endpmatrix in order, i.e. (u_1u_2u_11u_12u_21u_22). As the convection term is tested with v,  the output vector o only has to contain what should be tested with each component of v, i.e.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n    A_textlocal = (v_1v_2)^T(o_1o_2) = \n        beginpmatrix\n            v_1o_1  v_1o_2\n            v_2o_1  v_2o_2\n        endpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To construct the kernel there are two options,  component-wise and based on tensor_view. For the first we have to write the convection term as individual components","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\no = \n    beginpmatrix\n        u_1cdot u_11+u_2cdot u_12\n        u_1cdot u_21+u_2cdot u_22\n    endpmatrix\n= \nbeginpmatrix\n    ucdot (u_11u_12)^T\n    ucdot (u_21u_22)^T\nendpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To make our lives a bit easier we will extract the subcompontents of  input as views, such that ∇u[3] actually accesses input[5], which corresponds to the third entry u_21 of nabla u. ","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input,3:6)\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4))\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To improve readability of the kernels and to make them easier to understand, we provide the function tensor_view which constructs a view and reshapes  it into an object matching the given TensorDescription. See the table  to see which tensor size is needed for which derivative of a scalar, vector  or matrix-valued variable.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(2))\n    v = tensor_view(result,1,TDVector(2))\n    ∇u = tensor_view(input,3,TDMatrix(2))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The coressponding NonlinearOperator constructor call is the same in both cases  and reads","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\nNonlinearOperator(kernel!, [id(u)], [id(u),grad(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The second argument triggers that the evaluation of the Identity and Gradient operator of the current velocity iterate at each quadrature point go (in that order) into the input vector (of length 6) of the kernel, while the third argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the velocity test function.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"remark: Remark\nAlso note, that the same kernel could be used for a fully explicit linearisation of the convection term as a LinearOperator viau = Unknown(\"u\"; name = \"velocity\")\nLinearOperator(kernel!, [id(u)], [id(u),grad(u)])For a Picard iteration of the convection term, a BilinearOperator can be used with a slightly modified kernel that separates the operator evaluations of the ansatz function and the current solution, i.e.,function kernel_picard!(result, input_ansatz, input_args, qpinfo)\n    a, ∇u = view(input_args, 1:2), view(input_ansatz,1:4)\n    result[1] = dot(a, view(∇u,1:2))\n    result[2] = dot(a, view(∇u,3:4))\nend\nu = Unknown(\"u\"; name = \"velocity\")\nBilinearOperator(kernel_picard!, [id(u)], [grad(u)], [id(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Note\nKernels are allowed to depend on region numbers, space and time coordinates via the qpinfo argument.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Dimension independent kernels\nIf done correctly, the operator-based approach allows us to write a kernel  that is 'independent' of the spatial dimension,  i.e. one instead of up to three kernels. Assuming dim is a known variable we can re-write the kernel from above asfunction kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(dim))\n    v = tensor_view(result,1,TDVector(dim))\n    ∇u = tensor_view(input,1+dim,TDMatrix(dim))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/#Newton-by-local-jacobians-of-kernel","page":"NonlinearOperator","title":"Newton by local jacobians of kernel","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To demonstrate the general approach consider a model problem with a nonlinear operator that has the weak formulation that seeks some function u(x) in X in some finite-dimensional space X with N = mathrmdim X, i.e., some coefficient vector x in mathbbR^N, such that","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) = int_Omega A(L_1u(x)(y)) cdot L_2v(y) textitdy  = 0 quad textfor all  v in X\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"for some given nonlinear kernel function A  mathbbR^m rightarrow mathbbR^n where m is the dimension of the input L_1 u(x)(y) in mathbbR^m and n is the dimension of the result L_2 v(y) in mathbbR^n. Here, L_1 and L_2 are linear operators, e.g. primitive differential operator evaluations of u or v.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Let us consider the Newton scheme to find a root of the residual function F  mathbbR^N rightarrow mathbbR^N, which iterates","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nx_n+1 = x_n - D_xF(x_n)^-1 F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"or, equivalently, solves","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x_n) left(x_n+1 - x_nright) = -F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To compute the jacobian of F, observe that its discretisation on a mesh mathcalT and some quadrature rule (x_qp w_qp) leads to","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp A(L_1u_h(x)(x_qp)) cdot L_2v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Now, by linearity of everything involved other than A, we can evaluate the jacobian by","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp DA(L_1 u_h(x)(x_qp)) cdot L_2 v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Hence, assembly only requires to evaluate the low-dimensional jacobians DA in mathbbR^m times n of A at L_1 u_h(x)(x_qp). These jacobians are computed by automatic differentiation via ForwardDiff.jl (or via the user-given jacobian function). If m and n are a little larger, e.g. when more operator evaluations L_1 and L_2 or more unknowns are involved, there is the option to use sparse_jacobians (using the sparsity detection of Symbolics.jl).","category":"page"},{"location":"linearoperator/#LinearOperator","page":"LinearOperator","title":"LinearOperator","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"A linear operator allows to add vectors to the right-hand side of the system that usually refer to right-hand side data or linearisations of PDE operators (see remark in NonlinearOperator example). If the linear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluate more than the degrees of freedom on the face) there is the possibility to use LinearOperatorDG. It is also possible to assign a vector assembled by the user as a LinearOperator.","category":"page"},{"location":"linearoperator/#Constructors","page":"LinearOperator","title":"Constructors","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Vector{<:Union{Int64, Unknown}}, Vector{<:Union{Int64, Unknown}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tA,\n\tu_test,\n\tu_args;\n\tkwargs...)\n\nGenerates a linear form from a user-provided matrix A, which can be an AbstractMatrix or a FEMatrix with multiple blocks. The arguments uargs specify which coefficients of the current solution should be multiplied with the matrix and utest specifies where to put the (blocks of the) resulting vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Any}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tb,\n\tu_test;\n\tkwargs...)\n\nGenerates a linear form from a user-provided vector b, which can be an AbstractVector or a FEVector with multiple blocks. The argument u_test specifies where to put the (blocks of the) vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tkernel!::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperator''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: LinearOperator(kernel!, [id(1)]; kwargs...) generates the right-hand side for a Poisson problem, where kernel! evaluates the right-hand side.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperator''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#Example-right-hand-side","page":"LinearOperator","title":"Example - right-hand side","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"For a right-hand side operator of a Poisson problem with some given function f(x) a kernel could look like","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"function kernel!(result, qpinfo)\n    result[1] = f(qpinfo.x)\nend","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"and the coressponding LinearOperator constructor call reads","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"u = Unknown(\"u\")\nNonlinearOperator(kernel!, [id(u)])","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"The second argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the test function.","category":"page"},{"location":"linearoperator/#LinearOperatorDG","page":"LinearOperator","title":"LinearOperatorDG","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"LinearOperatorDG is intended for linear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using FaceAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the (discontinuous) operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using FaceAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times, the printouts in the documentation are taken from a second run after compilations are done","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, perform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"pdesolvers_dt/#Time-dependent-Solvers","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"For time-dependent (non-stationary) problems the user currently has these options:","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"fully manual option: add custom time derivatives to the problem (i.e. a mass matrix as a BilinearOperator and necessary LinearOperators for evaluating the previous time step(s), if more than one previous time step needs to be remembered, their memorization must be handled manually, e.g. by registering further unknowns)\nfully automatic option: reframe the ProblemDescription as an ODE problem and evolve it via DifferentialEquations with ExtendableFEMDiffEQExt.jl extension (see below)","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Several time-dependent examples are available where both options are implemented, see e.g. Examples103 (Burger's equation) and Example205 (Heat equation).","category":"page"},{"location":"pdesolvers_dt/#Using-SciMLBase.ODEProblem-and-DifferentialEquations.jl","page":"Time-dependent Solvers","title":"Using SciMLBase.ODEProblem and DifferentialEquations.jl","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"It is possible to reframe the ProblemDescription for the spatial differential operator of the PDE as the right-hand side of an ODEProblem. Here, the ProblemDescription contains the right-hand side description of the ODE","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"beginaligned\nM u_t(t)  = b(u(t)) - A(u(t)) u(t)\nendaligned","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"where A and b correspond to the assembled (linearized) spatial operator and the right-hand side operators in the ProblemDescription. Note, that A comes with a minus sign. The matrix M is the mass matrix and can be customized somewhat (as long as it stays constant). The operators in the ProblemDescription might depend on time (if their kernels use qpinfo.time) and will be reassembled in each time step. To avoid this single operator reassemblies can be switched off by using the store = true argument. The full matrix reassembly can be skipped if constant_matrix = true is used in the SolverConfiguration.","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Modules = [ExtendableFEM]\nPages = [\"solvers_diffeq.jl\", \"diffeq_interface.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tPD::ProblemDescription,\n\tFES,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into an ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nAdditional keyword arguments:\n\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers_dt/#ExtendableFEM.eval_jacobian!-NTuple{4, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.eval_jacobian!","text":"Provides the jacobi matrix calculation function for DifferentialEquations.jl/ODEProblem.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.eval_rhs!-NTuple{4, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.eval_rhs!","text":"Provides the rhs function for DifferentialEquations.jl/ODEProblem.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem-Tuple{ProblemDescription, Any, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tSC::SolverConfiguration,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into a SciMLBase.ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nKeyword arguments:\n\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.jac_prototype-Tuple{Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.jac_prototype","text":"Provides the system matrix as prototype for the jacobian.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"note: Note\nThe solvers of DifferentialEquations should be run with the autodiff=false option as it is currently not possible to differentiate the right-hand side of the generated ODEProblem with respect to time.","category":"page"},{"location":"pdesolvers_dt/#Example-:-2D-Heat-equation","page":"Time-dependent Solvers","title":"Example : 2D Heat equation","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"The following ProblemDescription yields the space discretisation of the heat equation (including homogeneous boundary conditions and equivalent to the Poisson equation).","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"PD = ProblemDescription(\"Heat Equation\")\nu = Unknown(\"u\"; name = \"temperature\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\nassign_operator!(PD, HomogeneousBoundaryData(u))","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Given a finite element space FES and an initial FEVector sol for the unknown, the ODEProblem for some time interval (0,T) can be generated and solved via","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"prob = generate_ODEProblem(PD, FES, (0, T); init = sol)\nDifferentialEquations.solve(prob, Rosenbrock23(autodiff = false), dt = 1e-3, dtmin = 1e-6, adaptive = true)","category":"page"},{"location":"postprocessing/#Other-packages","page":"Other packages","title":"Other packages","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"A lot of functionality is already provided by the bases packages, e.g.:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"ExtendableGrids.jl offers an interface to WriteVTK.jl which can be used, e.g. in combination with nodevalues interpolations or (piecewise constant) item integrator results. There is also the CellFinder that can be used to find the right cell for a certain point of the domain.\nExtendableFEMBase.jl offers a PointEvaluator and a SegmentIntegrator to evaluate solutions at arbitrary points of the domain or integrating along 1D line intersections with the cells of the triangulation. It also provides some basic unicode plots.\nGridVisualize.jl provides grid and scalar piecewise linear function plotting for various plotting backends on simplicial grids in one, two or three space dimensions. The main supported backends are PyPlot, GLMakie and PlutoVista.","category":"page"},{"location":"postprocessing/#Plots-and-Tables","page":"Other packages","title":"Plots and Tables","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"Some convenient plotting shortcuts are avaiables via these functions:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"Modules = [ExtendableFEM]\nPages = [\"plots.jl\", \"io.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"postprocessing/#ExtendableFEM.plot!-Tuple{GridVisualize.GridVisualizer, Any, Any}","page":"Other packages","title":"ExtendableFEM.plot!","text":"function plot!(p::GridVisualizer, ops, sol; kwargs...)\n\nPlots the operator evaluations ops of blocks in sol into the GridVisualizer.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.plot","text":"function plot!(p::GridVisualizer, ops, sol; Plotter = nothing, kwargs...)\n\nPlots the operator evaluations ops of blocks in sol with the specified Plotter module that is supported by GridVisualize (e.g. GLMakie, PyPlot, Plots)\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_convergencehistory!-Tuple{Any, Any, Any}","page":"Other packages","title":"ExtendableFEM.plot_convergencehistory!","text":"function plot_convergencehistory!(\n\tp::GridVisualizer, \n\tX,\n\tY;\n\tadd_h_powers = [],\n\tX_to_h = X -> X,\n\tcolors = [:blue, :green, :red, :magenta, :lightblue],\n\ttitle = \"convergence history\",\n\tlegend = :best,\n\tylabel = \"\",\n\tylabels = [],\n\txlabel = \"ndofs\",\n\tmarkershape = :circle,\n\tmarkevery = 1,\n\tclear = true,\n\targs...,\n\nPlots a convergence history based on arrays X vs. Y into the GridVisualizer.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_convergencehistory-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.plot_convergencehistory","text":"function plot_convergencehistory(X, Y; Plotter = nothing, kwargs...)\n\nPlots a convergence history based on arrays X vs. Y into the GridVisualizer with the specified Plotter module (that needs to be supported by GridVisualize).\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_unicode-Tuple{Any}","page":"Other packages","title":"ExtendableFEM.plot_unicode","text":"function plot_unicode(sol; kwargs...)\n\nPlots all blocks of sol into stdout (via plot_scalarplot from the UnicodePlots extension of ExtendableFEMBase)\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.print_convergencehistory-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.print_convergencehistory","text":"function print_convergencehistory(X, Y; X_to_h = X -> X, ylabels = [], xlabel = \"ndofs\", latex_mode = false, separator = latex_mode ? \"&\" : \"|\", order_seperator = latex_mode ? \"&\" : \"\")\n\nPrints a convergence history based on arrays X vs. Y.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.print_table-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.print_table","text":"function print_table(X, Y; ylabels = [], xlabel = \"ndofs\")\n\nPrints a table with data X vs. Y\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#Item-Integrators","page":"Item Integrators","title":"Item Integrators","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Item integrators compute certain quantities of the Solution, like a posteriori errors estimators, norms, drag/lift coefficients or other statistics.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegrator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegrator","text":"function ItemIntegrator(\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs). If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nparallel: assemble operator in parallel using partitions information. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.L2NormIntegrator-Tuple{Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.L2NormIntegrator","text":"function L2NormIntegrator(\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nItemIntegrator with a fixed kernel that computes the (componentwise) L2Norm of the arguments.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nparallel: assemble operator in parallel using partitions information. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegrator{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegrator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ItemIntegratorDG","page":"Item Integrators","title":"ItemIntegratorDG","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"ItemIntegratorDG is intended for quantities that involve jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions or jumps of broken FESpaces. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegratorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegratorDG","text":"function ItemIntegratorDG(\n\tkernel::Function,\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified (discontinuous) operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs) along cell boundaries. If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONFACES\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegratorDG''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegratorDG{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegratorDG,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers/#Stationary-Solvers","page":"Stationary Solvers","title":"Stationary Solvers","text":"","category":"section"},{"location":"pdesolvers/#Meshes-and-FESpaces","page":"Stationary Solvers","title":"Meshes and FESpaces","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Meshes are expected in the form of an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl. There is also an extension to read meshes from gmsh files.","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"FESpace{FEType}(grid::ExtendableGrid)","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Here, FEType denotes the type of finite element. A list of available FETypes can be found in the Documentation of ExtendableFEMBase.jl.","category":"page"},{"location":"pdesolvers/#Solve-(monolithic)","page":"Stationary Solvers","title":"Solve (monolithic)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. ","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"solve\nresidual","category":"page"},{"location":"pdesolvers/#CommonSolve.solve","page":"Stationary Solvers","title":"CommonSolve.solve","text":"function solve(\n\tPD::ProblemDescription,\n\t[FES::Union{<:FESpace,Vector{<:FESpace}}],\n\tSC = nothing;\n\tunknowns = PD.unknowns,\n\tkwargs...)\n\nReturns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nThis function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.\n\nKeyword arguments:\n\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\nprecon_linear: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_config: show configuration at the beginning of solve. Default: false\nshow_matrix: show system matrix after assembly. Default: false\nspy: show unicode spy plot of system matrix during solve. Default: false\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\ntime: current time to be used in all time-dependent operators. Default: 0.0\nverbosity: verbosity level. Default: 0\n\nDepending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#ExtendableFEM.residual","page":"Stationary Solvers","title":"ExtendableFEM.residual","text":"residual(S::SolverConfiguration)\n\nreturns the residual of the last solve\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"note: Note\nThe type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat customized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.","category":"page"},{"location":"pdesolvers/#Solve-(iterating-subproblems)","page":"Stationary Solvers","title":"Solve (iterating subproblems)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"SolverConfiguration\nget_unknown_id","category":"page"},{"location":"pdesolvers/#ExtendableFEM.SolverConfiguration","page":"Stationary Solvers","title":"ExtendableFEM.SolverConfiguration","text":"function iterate_until_stationarity(\n\tSolverConfiguration(Problem::ProblemDescription\n\t[FES::Union{<:FESpace, Vector{<:FESpace}}];\n\tinit = nothing,\n\tunknowns = Problem.unknowns,\n\tkwargs...)\n\nReturns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nKeyword arguments:\n\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\nprecon_linear: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_config: show configuration at the beginning of solve. Default: false\nshow_matrix: show system matrix after assembly. Default: false\nspy: show unicode spy plot of system matrix during solve. Default: false\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\ntime: current time to be used in all time-dependent operators. Default: 0.0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#ExtendableFEM.get_unknown_id","page":"Stationary Solvers","title":"ExtendableFEM.get_unknown_id","text":"get_unknown_id(SC::SolverConfiguration, u::Unknown)\n\nreturns the id of the unknown u in SC\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"iterate_until_stationarity","category":"page"},{"location":"pdesolvers/#ExtendableFEM.iterate_until_stationarity","page":"Stationary Solvers","title":"ExtendableFEM.iterate_until_stationarity","text":"function iterate_until_stationarity(\n\tSCs::Array{<:SolverConfiguration, 1},\n\tFES = nothing;\n\tmaxsteps = 1000,\n\tinit = nothing,\n\tunknowns = [SC.PD.unknowns for SC in SCs],\n\tkwargs...)\n\nIterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corresponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.\n\nUsing the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by\n\nSolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)\n\nwith the usual keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"bilinearoperator/#BilinearOperator","page":"BilinearOperator","title":"BilinearOperator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluat more than the degrees of freedom on the face) there is the possibility to use BilinearOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.","category":"page"},{"location":"bilinearoperator/#Constructors","page":"BilinearOperator","title":"Constructors","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-2","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tA::AbstractMatrix,\n\tu_test,\n\tu_ansatz = u_test;\n\tkwargs...)\n\nGenerates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments utest and uansatz specify where to put the (blocks of the) matrix in the system.\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#BilinearOperatorDG","page":"BilinearOperator","title":"BilinearOperatorDG","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\ncallback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: lump the operator (= only assemble the diagonal). Default: false\nname: name for operator used in printouts. Default: ''BilinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#Examples","page":"BilinearOperator","title":"Examples","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Below two examples illustrate some use cases.","category":"page"},{"location":"bilinearoperator/#Example-Stokes-operator","page":"BilinearOperator","title":"Example - Stokes operator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"For the linear operator of a Stokes problem a kernel could look like","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"μ = 0.1 # viscosity parameter\nfunction kernel!(result, input, qpinfo)\n    ∇u, p = view(input,1:4), view(input, 5)\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the coressponding BilinearOperator constructor call reads","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\np = Unknown(\"p\"; name = \"pressure\")\nBilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since input[5] does not couple with result[5].","category":"page"},{"location":"bilinearoperator/#Example-interior-penalty-stabilization","page":"BilinearOperator","title":"Example - interior penalty stabilization","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"function stab_kernel!(result, input, qpinfo)\n    result .= input .* qpinfo.volume^2\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the BilinearOperatorDG constructor call","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\")\nassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))","category":"page"},{"location":"combinedofs/#CombineDofs","page":"CombineDofs","title":"CombineDofs","text":"","category":"section"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/combinedofs.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"combinedofs/#ExtendableFEM.CombineDofs","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, dofsX, dofsY, factors; kwargs...)\n\nWhen assembled, the dofsX of the unknown uX will be coupled with the dofsY of uY, e.g., for periodic boundary conditions.\n\nKeyword arguments:\n\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"combinedofs/#ExtendableFEM.CombineDofs-Tuple{Any, Any, AbstractMatrix}","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, coupling_matrix::AbstractMatrix; kwargs...)\n\nInput:     uX: FEVectorBlock of the \"from\" boundary region     uY: FEVectorBlock of the \"to\" boundary region (usually the same as uX)     couplingmatrix: coupling matrix computed from `getperiodiccouplingmatrix`\n\nKeyword arguments:\n\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"The following function might be useful to find out the dofs the need to be coupled for periodic boundary conditions:","category":"page"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"get_periodic_coupling_info","category":"page"},{"location":"combinedofs/#ExtendableFEM.get_periodic_coupling_info","page":"CombineDofs","title":"ExtendableFEM.get_periodic_coupling_info","text":"function get_periodic_coupling_info(FES, xgrid, b1, b2, is_opposite::Function; factor_vectordofs = \"auto\")\n\ncomputes the dofs that have to be coupled for periodic boundary conditions on the given xgrid for boundary regions b1, b2. The isopposite function evaluates if two provided face midpoints are on opposite sides to each other (the mesh xgrid should be appropriate). For vector-valued FETypes the user can provide factorvectordofs to incorporate a sign change if needed. This is automatically done for all Hdiv-conforming elements and (for the normal-weighted face bubbles of) the Bernardi-Raugel element H1BR. \n\n\n\n\n\n","category":"function"},{"location":"interpolateboundarydata/#InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"","category":"section"},{"location":"interpolateboundarydata/","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/interpolateboundarydata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"interpolateboundarydata/#ExtendableFEM.InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"ExtendableFEM.InterpolateBoundaryData","text":"function InterpolateBoundaryData(u, data!::Function; kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to match the standard interpolation of the provided data! function. The header of this function needs to be conform to the interface\n\ndata!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x provides the global coordinates of the quadrature/evaluation point.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to the quadorder chosen by the interpolator. Default: 0\nname: name for operator used in printouts. Default: ''BoundaryData''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nplot: plot unicode plot of boundary data into terminal when assembled. Default: false\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"interpolateboundarydata/#ExtendableFEM.apply!-Tuple{ExtendableFEMBase.FEVectorBlock, InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.apply!","text":"apply!(U::FEVectorBlock, O::InterpolateBoundaryData; offset = 0, kwargs...)\n\napplies the boundary data of O to U, i.e., sets the boundary dofs to the correct values that have been computed during the last assemble! call.\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.apply_penalties!-Union{Tuple{UT}, Tuple{Any, Any, Any, InterpolateBoundaryData{UT}, SolverConfiguration}} where UT","page":"InterpolateBoundaryData","title":"ExtendableFEM.apply_penalties!","text":"apply_penalties!(A, b, sol, O::InterpolateBoundaryData{UT}, SC::SolverConfiguration; kwargs...)\n\nmodifies the linear system A|b such that the boundary dofs are penalized and attain the correct values from the last assemble! call of O. Also applies the correct values to sol.\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.assemble!-Union{Tuple{UT}, Tuple{Any, Any, Any, InterpolateBoundaryData{UT}, SolverConfiguration}} where UT","page":"InterpolateBoundaryData","title":"ExtendableFEM.assemble!","text":"assemble!(A, b, sol, O::InterpolateBoundaryData{UT}, SC::SolverConfiguration; kwargs...)\n\nassembles the correct boundary values for O by interpolating the boundary data with the current kwargs (where e.g. time and params might have changed).\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.fixed_dofs-Tuple{InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.fixed_dofs","text":"fixed_dofs(O::InterpolateBoundaryData)\n\nreturns the fixed degrees of freedoms of O\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.fixed_vals-Tuple{InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.fixed_vals","text":"fixed_vals(O::InterpolateBoundaryData)\n\nreturns the currently assembled values for the fixed degrees of freedom of O\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEM.jl","page":"Home","title":"ExtendableFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers a toolkit to easily setup (mostly low-order, standard and non-standard) finite element methods for multiphysics problems in Julia and to run fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl (for meshing and administration) and ExtendableFEMBase.jl (for quadrature and FEM basis functions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nExtendableFEMBase.jl\nGridVisualize.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\n","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"#1.-Geometry-description-/-meshing","page":"Home","title":"1. Geometry description / meshing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The geometry description and meshing is not really separated. For meshes of rectangular domains, there are simple constructors available in ExtendableGrids.jl, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExtendableGrids\n## unit square criss-cross into Triangles\nxgrid1 = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n## uniform rectangular grid\nxgrid2 = simplexgrid(0:0.1:1, 0:0.2:2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that these grids generate boundary regions from 1 to 4 (bottom, left, top, right) that can be used to assign boundary conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More complex grids can be created via the mesh generators in SimplexGridFactory.jl, see e.g. Examples 245 or 265, or by loading a Gmsh grid file via the corresponding ExtendableGrids.jl extension.","category":"page"},{"location":"#2.-Problem-description","page":"Home","title":"2. Problem description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Before discretizing the user has the option to pose his problems in form of a Problem Description. Note, that usually no grid has to be defined at this point, but region numbers correspond to regions defined in the grid. Here is a short example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# a simple Poisson problem with right-hand side f(x,y) = x*y and u = 0 along boundary\nPD = ProblemDescription()\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\nf! = (result, qpinfo) -> (result[1] = qpinfo.x[1] * qpinfo.x[2])\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))","category":"page"},{"location":"#3.-Discretization","page":"Home","title":"3. Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this step, the user chooses suitable finite element types for the unknowns of the problem, and generates finite element spaces on the grid (and probably already a solution vector to preoccupy it with an initial solution).","category":"page"},{"location":"","page":"Home","title":"Home","text":"# cubic H1 element in 2D with one component\nFES = FESpace{H1Pk{1,2,3}}(xgrid) \n# alternatively: create solution vector and tag blocks with problem unknowns\nsol = FEVector(FES; tags = PD.unknowns) \n# fill block corresponding to unknown u with initial values\nfill(sol[u], 1)\n# interpolate some given function u!(result, qpinfo)\ninterpolate!(sol[u], u!)","category":"page"},{"location":"#4.-Solve","page":"Home","title":"4. Solve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here, we solve the problem. If the problem is nonlinear, several additional arguments allow to steer the fixed-point iteration, see Stationary Solvers. In the simplest case, the user only needs to call:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# solve problem with finite element space(s)\n# (in case of more than one unknown, provide a vector of FESpaces)\nsol = solve(PD, FES; init = sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For time-dependent problem, the user can add the necessary operators for the time derivative manually. Alternatively, the problem description in space can be turned into an ODE and solve via DifferentialEquations.jl, see Time-dependent Solvers for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that the use can bypass the problem description and control the algebraic level manually via assembling the operators directly into an FEMatrix, see e.g. Example310. It is also possible to take control over the low-level assembly of the operators, see ExtendableFEMBase.jl for details.","category":"page"},{"location":"#5.-Plot-and-postprocess","page":"Home","title":"5. Plot and postprocess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After solving, the user can postprocess the solution, calculate quantities of interest or plot components.","category":"page"},{"location":"#Gradient-robustness","page":"Home","title":"Gradient-robustness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers some ingredients to build gradient-robust schemes via reconstruction operators or divergence-free elements. Gradient-robustness is a feature of discretisations that exactly balances gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to construct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfunctions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"tensordescription/#Tensor-Description","page":"Tensor Description","title":"Tensor Description","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"To be able to construct reshaped views  of the test functions and their derivates, we can describe the  shape of the view through a TensorDescription{R,D}  where R is the rank of the tensor and D is the dimension  or extent of the tensor in each of the R directions.  That means a real valued R-tensor is an element of  underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.  Specifically, we can identify the following mathematical objects with  tensors of different ranks:","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"math. object R-Tensor\nscalar inmathbbR 0-Tensor\nvector inmathbbR^D 1-Tensor\nmatrix inmathbbR^DtimesmathbbR^D 2-Tensor","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For finite elements, D usually matches the spatial dimension of  the problem we want to solve, i.e. D=2 for 2D and D=3 for 3D.","category":"page"},{"location":"tensordescription/#Tensor-Types","page":"Tensor Description","title":"Tensor Types","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"ExtendableFEM.TensorDescription\nExtendableFEM.TDScalar\nExtendableFEM.TDVector\nExtendableFEM.TDMatrix\nExtendableFEM.TDRank3\nExtendableFEM.TDRank4","category":"page"},{"location":"tensordescription/#ExtendableFEM.TensorDescription","page":"Tensor Description","title":"ExtendableFEM.TensorDescription","text":"TensorDescription{R,D}\n\nGeneral type for an R-tensor of dimension/extent D. Mathematically, this describes the shape of an element  in underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.\n\nSee also:  TDScalar{D}, TDVector{D}, TDMatrix{D}, TDRank3{D}, TDRank4{D}\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDScalar","page":"Tensor Description","title":"ExtendableFEM.TDScalar","text":"TDScalar{D}\n\nSpecification for a 0-tensor or scalar, i.e. TensorDescription{0,D}, to improve readability.\n\nNote that in this case D has no greater effect  and is only provided to have a matching interface  between all the specifications.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDVector","page":"Tensor Description","title":"ExtendableFEM.TDVector","text":"TDVector{D}\n\nSpecification for a 1-tensor or vector, i.e. TensorDescription{1,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDMatrix","page":"Tensor Description","title":"ExtendableFEM.TDMatrix","text":"TDMatrix{D}\n\nSpecification for a 2-tensor or matrix, i.e. TensorDescription{2,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank3","page":"Tensor Description","title":"ExtendableFEM.TDRank3","text":"TDRank3{D}\n\nSpecification for a 3-tensor, i.e. TensorDescription{3,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank4","page":"Tensor Description","title":"ExtendableFEM.TDRank4","text":"TDRank4{D}\n\nSpecification for a 4-tensor, i.e. TensorDescription{4,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#Reshaped-views","page":"Tensor Description","title":"Reshaped views","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"Modules = [ExtendableFEM]\nPages = [\"tensors.jl\"]\nOrder   = [:function]","category":"page"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDMatrix{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{2,dim})\n\nReturns a view of input[i:i+dim^2-1] reshaped as a (dim,dim) matrix.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank3{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{3,dim})\n\nReturns a view of input[i:i+dim^3-1] reshaped as a (dim,dim,dim) 3-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank4{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{4,dim})\n\nReturns a view of input[i:i+dim^4-1] reshaped as (dim,dim,dim,dim) 4-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDScalar{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{0,dim})\n\nReturns a view of input[i] reshaped as a vector of length 1.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDVector{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{1,dim})\n\nReturns a view of input[i:i+dim-1] reshaped as a vector of length dim.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{rank}, Tuple{Any, Int64, TensorDescription{rank, dim}}} where {rank, dim}","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{rank,dim})\n\nReturns a view of input[i] and subsequent entries,  reshaped as a rank-tensor of dimension dim.\n\nNote that this general implementation is a fallback for rank>4 that will likely produce allocations and slow assembly  times if used in a kernel function.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#Which-tensor-for-which-unknown?","page":"Tensor Description","title":"Which tensor for which unknown?","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For an unknown variable u of tensor rank r  a derivative of order n has rank r+n, i.e. the hessian (n=2) of a scalar unknown (rank 0) and the gradient (n=1) of a vector valued (rank 1)  variable are both matrices (rank 2).","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For a more comprehensive list see the following table","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"derivative order scalar-valued vector-valued matrix-valued\n0 (value/id) TDScalar(D) TDVector(D) TDMatrix(D)\n1 (grad) TDVector(D) TDMatrix(D) TDRank3(D)\n2 (hessian) TDMatrix(D) TDRank3(D) TDRank4(D)\n3 TDRank3(D) TDRank4(D) TensorDescription(5,D)\n4 TDRank4(D) TensorDescription(5,D) TensorDescription(6,D)\nvdots vdots vdots vdots","category":"page"},{"location":"tensordescription/#Helpers","page":"Tensor Description","title":"Helpers","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"tmul!","category":"page"},{"location":"tensordescription/#ExtendableFEM.tmul!","page":"Tensor Description","title":"ExtendableFEM.tmul!","text":"function tmul!(y,A,x,α=1.0,β=0.0)\n\nCombined inplace  matrix-vector multiply-add A^T x α + y β. The result is stored in y by overwriting it.  Note that y must not be aliased with either A or x.\n\n\n\n\n\nfunction tmul!(y::AbstractVector{T}, A::AbstractMatrix{T}, x::AbstractVector{T}, α=1.0, β=0.0) where {T<:AbstractFloat}\n\nOverload of the generic function for types supported by  LinearAlgebra.BLAS.gemv! to avoid slow run times for large inputs.\n\n\n\n\n\n","category":"function"}]
}
