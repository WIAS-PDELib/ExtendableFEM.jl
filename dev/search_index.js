var documenterSearchIndex = {"docs":
[{"location":"parallel_assembly/#Parallel-Assembly","page":"Parallel Assembly","title":"Parallel Assembly","text":"","category":"section"},{"location":"parallel_assembly/","page":"Parallel Assembly","title":"Parallel Assembly","text":"Within the solve call, all operators will be assembled according to their configured parameters. When 'parallel = true' is used (not available yet for all DG operators), the operators will be assembled in parallel based on the color partitions within the grid. Hence, the computational grid must provide these partitions, see Documentation of ExtendableGrids.jl on Partitioning for details. Also the sparse system matrix needs to be able to work on different partitions in parallel. Once, the grid has partitions, the solver automatically uses a suitable constructor for the system matrix (MTExtendableSparseMatrixCSC from ExtendableSparse.jl).","category":"page"},{"location":"parallel_assembly/","page":"Parallel Assembly","title":"Parallel Assembly","text":"note: Note\nDG operators that assemble along cell faces need the option 'edges = true' in the partition call for the grid partitioning, otherwise assembly will be still sequentially.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/#220-:-Reaction-Convection-Diffusion-Problem","page":"Example220_ReactionConvectionDiffusion","title":"220 : Reaction-Convection-Diffusion-Problem","text":"","category":"section"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"(source code)","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"-nu Delta u + mathbfbeta cdot nabla u + alpha u = f quad textin  Omega","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta, some scalar-valued function alpha and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"We prescribe an analytic solution with mathbfbeta = (10) and alpha = 01 and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"(Image: )","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"module Example220_ReactionConvectionDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\nconst α = 0.01\nconst β = [1.0, 0]\nconst ν = 1.0e-5\n\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[1] * x[2] * (x[1] - 1) * (x[2] - 1) + x[1]\n    return nothing\nend\nfunction ∇u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[2] * (2 * x[1] - 1) * (x[2] - 1) + 1\n    result[2] = x[1] * (2 * x[2] - 1) * (x[1] - 1)\n    return nothing\nend\nfunction Δu!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 2 * (x[2] * (x[2] - 1) + x[1] * (x[1] - 1))\n    return nothing\nend\n\nfunction rhs()\n    ∇u = zeros(Float64, 2)\n    Δu = zeros(Float64, 1)\n    u = zeros(Float64, 1)\n    return function closure(result, qpinfo)\n        ∇u!(∇u, qpinfo)\n        u!(u, qpinfo)\n        Δu!(Δu, qpinfo)\n        result[1] = -ν * Δu[1] + α * u[1] + dot(β, ∇u)\n        return nothing\n    end\nend\n\nfunction kernel_DCR!(result, input, qpinfo)\n    u, ∇u = view(input, 1), view(input, 2:3)\n    result[1] = α * u[1] + dot(β, ∇u)\n    result[2] = ν * ∇u[1]\n    result[3] = ν * ∇u[2]\n    return nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n    u!(result, qpinfo)\n    ∇u!(view(result, 2:3), qpinfo)\n    result .-= u\n    result .= result .^ 2\n    return nothing\nend\n\n# stab_kernel!\nfunction stab_kernel!(result, ∇u, qpinfo)\n    result .= ∇u .* qpinfo.volume^2\n    return nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, τ = 1.0e-2, nlevels = 5, order = 2, kwargs...)\n\n    # create problem description\n    PD = ProblemDescription(\"reaction-convection-diffusion problem\")\n    u = Unknown(\"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator(kernel_DCR!, [id(u), grad(u)]; bonus_quadorder = 1, kwargs...))\n    assign_operator!(PD, LinearOperator(rhs(), [id(u)]; bonus_quadorder = 2, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4, kwargs...))\n\n    # add a gradient jump (interior penalty) stabilisation for dominant convection\n    if τ > 0\n        assign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = τ))\n    end\n\n    # prepare error calculation\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n    Results = zeros(Float64, nlevels, 4)\n    NDofs = zeros(Int, nlevels)\n\n    # refinement loop over levels\n    sol = nothing\n    xgrid = grid_unitsquare(Triangle2D) # initial grid\n    for level in 1:nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpace and solve\n        FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n        sol = solve(PD, FES)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(sol.entries)\n        error = evaluate(ErrorIntegratorExact, sol)\n        Results[level, 1] = sqrt(sum(view(error, 1, :)))\n        Results[level, 3] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n\n        # interpolate (just for comparison)\n        I = FEVector(FES)\n        interpolate!(I[1], u!)\n        error = evaluate(ErrorIntegratorExact, I)\n        Results[level, 2] = sqrt(sum(view(error, 1, :)))\n        Results[level, 4] = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n    end\n\n    # plot\n    plt = plot([id(u), grad(u)], sol; add = 1, ncols = 3, Plotter = Plotter)\n    plot_convergencehistory!(plt[1, 3], NDofs, Results; add_h_powers = [order, order + 1], X_to_h = X -> X .^ (-1 / 2), legend = :lb, ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"], limits = (1.0e-8, 1.0e-1))\n\n    # print convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\n\n    return Results, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"","category":"page"},{"location":"module_examples/Example220_ReactionConvectionDiffusion/","page":"Example220_ReactionConvectionDiffusion","title":"Example220_ReactionConvectionDiffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"faceinterpolator/#Face-interpolator","page":"Face interpolator","title":"Face interpolator","text":"","category":"section"},{"location":"faceinterpolator/","page":"Face interpolator","title":"Face interpolator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/discface_interpolator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"faceinterpolator/#ExtendableFEM.FaceInterpolator-Tuple{Any, Any, Any}","page":"Face interpolator","title":"ExtendableFEM.FaceInterpolator","text":"function FaceInterpolator(\n\t[kernel,]\n\tu_args,\n\tops_args;\n\tTv = Float64,\n\tTi = Int,\n\tkwargs...)\n\nGenerates a FaceInterpolator that evaluates discontinuous function operator of its arguments, possibly further postprocessed via a kernel function of interface function kernel(result, input, qpinfo), into a FEVector of H1Pk living on the faces of the grid with the fitting order and number of components.\n\nKeyword arguments:\n\nname: name for operator used in printouts. Default: ''Projector''\nonly_interior: only interior faces, interpolation of boundary faces will be zero. Default: false\norder: interpolation order (default: match order of applied finite element space). Default: ''auto''\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: true\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"faceinterpolator/#ExtendableFEMBase.evaluate!-Union{Tuple{UT}, Tuple{Ti}, Tuple{Tv}, Tuple{FaceInterpolator{Tv, Ti, UT}, Any}} where {Tv, Ti, UT}","page":"Face interpolator","title":"ExtendableFEMBase.evaluate!","text":"function evaluate!(O::FaceInterpolator{Tv, Ti, UT}, sol; kwargs...)\n\nEvaluates the FaceInterpolator using the blocks of sol as arguments and returns the FEVector with the results.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example225_ObstacleProblem/#225-:-Obstacle-Problem","page":"Example225_ObstacleProblem","title":"225 : Obstacle Problem","text":"","category":"section"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"This example computes the solution u of the nonlinear obstacle problem that seeks the minimiser of the energy functional","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tE(u) = frac12 int_Omega lvert nabla u rvert^2 dx - int_Omega f u dx\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"with some right-hand side f within the set of admissible functions that lie above an obstacle  chi","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tmathcalK = lbrace u in H^1_0(Omega)  u geq chi rbrace\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"The obstacle constraint is realised via a penalty term","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"beginaligned\n\tfrac1epsilon  min(0 u - chi) ^2_L^2\nendaligned","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"that is added to the energy above and is automatically differentiated for a Newton scheme. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"module Example225_ObstacleProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define obstacle and penalty kernel\nconst χ! = (result, x) -> (result[1] = (cos(4 * x[1] * π) * cos(4 * x[2] * π) - 1) / 20)\nfunction obstacle_penalty_kernel!(result, input, qpinfo)\n    χ!(result, qpinfo.x) # eval obstacle\n    result[1] = min(0, input[1] - result[1])\n    return nothing\nend\n\nfunction main(; Plotter = nothing, ϵ = 1.0e-4, nrefs = 6, order = 1, parallel = false, npart = 8, kwargs...)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    if parallel\n        xgrid = partition(xgrid, RecursiveMetisPartitioning(npart = npart))\n    end\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"potential\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(obstacle_penalty_kernel!, [id(u)]; factor = 1 / ϵ, parallel = parallel, kwargs...))\n    assign_operator!(PD, BilinearOperator([grad(u)]; store = true, parallel = parallel, kwargs...))\n    assign_operator!(PD, LinearOperator([id(u)]; store = true, parallel = parallel, factor = -1, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n\n    # create finite element space\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # plot\n    plt = plot([id(u), grad(u)], sol; Plotter = Plotter, ncols = 3)\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"","category":"page"},{"location":"module_examples/Example225_ObstacleProblem/","page":"Example225_ObstacleProblem","title":"Example225_ObstacleProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/#108-:-Robin-Boundary-Condition","page":"Example108_RobinBoundaryCondition","title":"108 : Robin Boundary Condition","text":"","category":"section"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"(source code)","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"This demonstrates the assignment of a mixed Robin boundary condition for a nonlinear 1D convection-diffusion-reaction PDE on the unit interval, i.e.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"beginaligned\n-partial^2 u  partial x^2 + u partial u  partial x + u  = f  textin  Omega\nu + partial u  partial_x  = g  textat  Gamma_1 =  0 \nu  = u_D  textat  Gamma_2 =  1 \nendaligned","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"tested with data f(x) = e^2x, g = 2 and u_D = e such that u(x) = e^x is the exact solution.","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"(Image: )","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"module Example108_RobinBoundaryCondition\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\n\n# data and exact solution\nfunction f!(result, qpinfo)\n    result[1] = exp(2 * qpinfo.x[1])\n    return nothing\nend\nfunction u!(result, qpinfo)\n    result[1] = exp(qpinfo.x[1])\n    return nothing\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion operator\nfunction nonlinear_kernel!(result, input, qpinfo)\n    u, ∇u = input[1], input[2]\n    result[1] = u * ∇u + u     # convection + reaction (will be multiplied with v)\n    result[2] = ∇u             # diffusion (will be multiplied with ∇v)\n    return nothing\nend\n\n# kernel for Robin boundary condition\nfunction robin_kernel!(result, input, qpinfo)\n    result[1] = 2 - input[1] # = g - u (will be multiplied with v)\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 1.0e-1, h_fine = 1.0e-3, order = 2, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; kwargs...))\n    assign_operator!(PD, BilinearOperator(robin_kernel!, [id(u)]; entities = ON_BFACES, regions = [1], kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = [2], kwargs...))\n\n    # generate coarse and fine mesh\n    xgrid = simplexgrid(0:h:1)\n\n    # choose finite element type and generate FESpace\n    FEType = H1Pk{1, 1, order}\n    FES = FESpace{FEType}(xgrid)\n\n    # generate a solution vector and solve\n    sol = solve(PD, FES; kwargs...)\n\n    # plot discrete and exact solution (on finer grid)\n    plt = GridVisualizer(Plotter = Plotter, layout = (1, 1))\n    scalarplot!(plt[1, 1], id(u), sol; color = :black, label = \"u_h\", markershape = :circle, markersize = 10, markevery = 1)\n    xgrid_fine = simplexgrid(0:h_fine:1)\n    scalarplot!(plt[1, 1], xgrid_fine, view(nodevalues(xgrid_fine, u!), 1, :), clear = false, color = :red, label = \"u\", legend = :rb, markershape = :none)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"","category":"page"},{"location":"module_examples/Example108_RobinBoundaryCondition/","page":"Example108_RobinBoundaryCondition","title":"Example108_RobinBoundaryCondition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"linearoperator/#LinearOperator","page":"LinearOperator","title":"LinearOperator","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"A linear operator allows to add vectors to the right-hand side of the system that usually refer to right-hand side data or linearisations of PDE operators (see remark in NonlinearOperator example). If the linear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluate more than the degrees of freedom on the face) there is the possibility to use LinearOperatorDG. It is also possible to assign a vector assembled by the user as a LinearOperator.","category":"page"},{"location":"linearoperator/#Constructors","page":"LinearOperator","title":"Constructors","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Vector{<:Union{Int64, Unknown}}, Vector{<:Union{Int64, Unknown}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tA,\n\tu_test,\n\tu_args;\n\tkwargs...)\n\nGenerates a linear form from a user-provided matrix A, which can be an AbstractMatrix or a FEMatrix with multiple blocks. The arguments uargs specify which coefficients of the current solution should be multiplied with the matrix and utest specifies where to put the (blocks of the) resulting vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Any}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tb,\n\tu_test;\n\tkwargs...)\n\nGenerates a linear form from a user-provided vector b, which can be an AbstractVector or a FEVector with multiple blocks. The argument u_test specifies where to put the (blocks of the) vector in the system right-hand side.\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\tkernel!::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperator''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperator","text":"function LinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: LinearOperator(kernel!, [id(1)]; kwargs...) generates the right-hand side for a Poisson problem, where kernel! evaluates the right-hand side.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperator''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#Example-right-hand-side","page":"LinearOperator","title":"Example - right-hand side","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"For a right-hand side operator of a Poisson problem with some given function f(x) a kernel could look like","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"function kernel!(result, qpinfo)\n    result[1] = f(qpinfo.x)\nend","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"and the coressponding LinearOperator constructor call reads","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"u = Unknown(\"u\")\nNonlinearOperator(kernel!, [id(u)])","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"The second argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the test function.","category":"page"},{"location":"linearoperator/#LinearOperatorDG","page":"LinearOperator","title":"LinearOperatorDG","text":"","category":"section"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"LinearOperatorDG is intended for linear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"linearoperator/","page":"LinearOperator","title":"LinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/linear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear linear form that evaluates a kernel function that depends on the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using FaceAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"linearoperator/#ExtendableFEM.LinearOperatorDG-Tuple{Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"LinearOperator","title":"ExtendableFEM.LinearOperatorDG","text":"function LinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the (discontinuous) operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''LinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information. Default: false\nparallel_groups: assemble operator in parallel using FaceAssemblyGroups. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example310_DivFreeBasis/#310-:-Div-free-RT0-basis","page":"Example310_DivFreeBasis","title":"310 : Div-free RT0 basis","text":"","category":"section"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"(source code)","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"This example computes the best-approximation mathbfpsi_h of a divergence-free velocity mathbfu = mathrmcurl mathbfpsi by solving for a curl-potential mathbfphi_h in N_0 with","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"beginaligned\n(mathrmcurl mathbfphi_h mathrmcurl mathbftheta_h)  = (mathbfu mathrmcurl mathbftheta_h) quad textfor all  mathbftheta in N_0\nendaligned","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"Here, N_0 denotes the lowest-order Nedelec space which renders the problem ill-posed unless one selects a linear independent basis. This is done with the algorithm suggested in the reference below.","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"reference: Reference\n\"Decoupling three-dimensional mixed problems using divergence-free finite elements\",\nR. Scheichl,\nSIAM J. Sci. Comput. 23(5) (2002),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"(Image: )","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"module Example310_DivFreeBasis\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing Symbolics\n\n# exact data for problem generated by symbolics\nfunction prepare_data()\n\n    @variables x y z\n\n    # stream function ξ\n    ξ = [x * y * z, x * y * z, x * y * z]\n\n    # velocity u = curl ξ\n    ∇ξ = Symbolics.jacobian(ξ, [x, y, z])\n    u = [∇ξ[3, 2] - ∇ξ[2, 3], ∇ξ[1, 3] - ∇ξ[3, 1], ∇ξ[2, 1] - ∇ξ[1, 2]]\n\n    # build function\n    u_eval = build_function(u, x, y, z, expression = Val{false})\n\n    return u_eval[2]\nend\n\nfunction main(;\n        nrefs = 4,                      ## number of refinement levels\n        bonus_quadorder = 2,            ## additional quadrature order for data evaluations\n        divfree_basis = true,            ## if true uses curl(N0), if false uses mixed FEM RT0xP0\n        Plotter = nothing,              ## Plotter (e.g. PyPlot)\n        kwargs...\n    )\n\n    # prepare problem data\n    u_eval = prepare_data()\n    exact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.x[3]))\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (800, 800))\n\n    # prepare error calculation\n    function exact_error!(result, u, qpinfo)\n        exact_u!(view(result, 1:3), qpinfo)\n        result .-= u\n        return result .= result .^ 2\n    end\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [divfree_basis ? curl3(1) : id(1)]; bonus_quadorder = 2 + bonus_quadorder, kwargs...)\n    NDofs = zeros(Int, nrefs)\n    L2error = zeros(Float64, nrefs)\n\n    sol = nothing\n    for lvl in 1:nrefs\n        # grid\n        xgrid = uniform_refine(grid_unitcube(Tetrahedron3D), lvl)\n\n        if divfree_basis\n\n            # use Nedelec FESpace and determine linear independent basis\n            FES = FESpace{HCURLN0{3}}(xgrid)\n\n            @time begin\n                # get subset of edges, spanning the node graph\n                spanning_tree = get_spanning_edge_subset(xgrid)\n\n                # get all other edges = linear independent degrees of freedom\n                subset = setdiff(1:num_edges(xgrid), spanning_tree)\n            end\n            NDofs[lvl] = length(subset)\n\n            # assemble full Nedelec curl-curl problem...\n            u = Unknown(\"u\"; name = \"curl potential of velocity\")\n            PD = ProblemDescription(\"curl-curl formulation\")\n            assign_unknown!(PD, u)\n            assign_operator!(PD, BilinearOperator([curl3(u)]))\n            assign_operator!(PD, LinearOperator(exact_u!, [curl3(u)]; bonus_quadorder = bonus_quadorder))\n\n            # ...and solve with subset\n            sol = solve(PD, FES; restrict_dofs = [subset[:]])\n        else\n            # use RT0 functions + side constraint for divergence\n            FES = [FESpace{HDIVRT0{3}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n            NDofs[lvl] = FES[1].ndofs + FES[2].ndofs\n\n            u = Unknown(\"u\"; name = \"velocity\")\n            p = Unknown(\"u\"; name = \"pressure\")\n            PD = ProblemDescription(\"mixed formulation\")\n            assign_unknown!(PD, u)\n            assign_unknown!(PD, p)\n            assign_operator!(PD, BilinearOperator([id(u)]))\n            assign_operator!(PD, BilinearOperator([div(u)], [id(p)]; transposed_copy = 1))\n            assign_operator!(PD, LinearOperator(exact_u!, [id(u)]; bonus_quadorder = bonus_quadorder))\n            sol = solve(PD, FES)\n        end\n\n        # evaluate error\n        error = evaluate(ErrorIntegratorExact, sol)\n        L2error[lvl] = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n        if divfree_basis\n            @info \"|| u - curl(ϕ_h) || = $(L2error[lvl])\"\n        else\n            @info \"|| u - u_h || = $(L2error[lvl])\"\n        end\n    end\n\n    # plot\n    if divfree_basis\n        scalarplot!(plt[1, 1], curl3(1), sol; abs = true)\n    else\n        scalarplot!(plt[1, 1], id(1), sol; abs = true)\n    end\n\n    # print convergence history as table\n    print_convergencehistory(NDofs, L2error; X_to_h = X -> X .^ (-1 / 3), ylabels = [\"|| u - u_h ||\"], xlabel = \"ndof\")\n\n    return L2error, plt\nend\n\n\n# finds a minimal subset (of dimension #nodes - 1) of edges, such that all nodes are connected\nfunction get_spanning_edge_subset(xgrid)\n    nnodes = num_nodes(xgrid)\n    edgenodes = xgrid[EdgeNodes]\n    bedgenodes = xgrid[BEdgeNodes]\n    bedgeedges = xgrid[BEdgeEdges]\n\n    # boolean arrays to memorize which nodes are visited\n    # and which edges belong to the spanning tree\n    visited = zeros(Bool, nnodes)\n    markededges = zeros(Bool, num_edges(xgrid))\n\n    function find_spanning_tree(edgenodes, remap)\n        nodeedges = atranspose(edgenodes)\n        function recursive(node)\n            visited[node] = true\n            nneighbors = num_targets(nodeedges, node)\n            for e in 1:nneighbors\n                edge = nodeedges[e, node]\n                for k in 1:2\n                    node2 = edgenodes[k, edge]\n                    if !visited[node2]\n                        # mark edge\n                        markededges[remap[edge]] = true\n                        recursive(node2)\n                    end\n                end\n            end\n            return nothing\n        end\n        return recursive(edgenodes[1])\n    end\n\n    # find spanning tree for Neumann boundary\n    # local bedges >> global edge numbers\n    find_spanning_tree(bedgenodes, bedgeedges)\n\n    # find spanning tree for remaining part\n    other_nodes = setdiff(1:nnodes, unique(view(bedgenodes, :)))\n    if length(other_nodes) > 0\n        find_spanning_tree(edgenodes, 1:num_edges(xgrid))\n    end\n\n    # return all marked edges\n    return findall(==(true), markededges)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"","category":"page"},{"location":"module_examples/Example310_DivFreeBasis/","page":"Example310_DivFreeBasis","title":"Example310_DivFreeBasis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdesolvers_dt/#Time-dependent-Solvers","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"For time-dependent (non-stationary) problems the user currently has these options:","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"fully manual option: add custom time derivatives to the problem (i.e. a mass matrix as a BilinearOperator and necessary LinearOperators for evaluating the previous time step(s), if more than one previous time step needs to be remembered, their memorization must be handled manually, e.g. by registering further unknowns)\nfully automatic option: reframe the ProblemDescription as an ODE problem and evolve it via DifferentialEquations with ExtendableFEMDiffEQExt.jl extension (see below)","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Several time-dependent examples are available where both options are implemented, see e.g. Examples103 (Burger's equation) and Example205 (Heat equation).","category":"page"},{"location":"pdesolvers_dt/#Using-SciMLBase.ODEProblem-and-DifferentialEquations.jl","page":"Time-dependent Solvers","title":"Using SciMLBase.ODEProblem and DifferentialEquations.jl","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"It is possible to reframe the ProblemDescription for the spatial differential operator of the PDE as the right-hand side of an ODEProblem. Here, the ProblemDescription contains the right-hand side description of the ODE","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"beginaligned\nM u_t(t)  = b(u(t)) - A(u(t)) u(t)\nendaligned","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"where A and b correspond to the assembled (linearized) spatial operator and the right-hand side operators in the ProblemDescription. Note, that A comes with a minus sign. The matrix M is the mass matrix and can be customized somewhat (as long as it stays constant). The operators in the ProblemDescription might depend on time (if their kernels use qpinfo.time) and will be reassembled in each time step. To avoid this single operator reassemblies can be switched off by using the store = true argument. The full matrix reassembly can be skipped if constant_matrix = true is used in the SolverConfiguration.","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Modules = [ExtendableFEM]\nPages = [\"solvers_diffeq.jl\", \"diffeq_interface.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tPD::ProblemDescription,\n\tFES,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into an ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nAdditional keyword arguments:\n\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers_dt/#ExtendableFEM.eval_jacobian!-NTuple{4, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.eval_jacobian!","text":"Provides the jacobi matrix calculation function for DifferentialEquations.jl/ODEProblem.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.eval_rhs!-NTuple{4, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.eval_rhs!","text":"Provides the rhs function for DifferentialEquations.jl/ODEProblem.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.generate_ODEProblem-Tuple{ProblemDescription, Any, Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.generate_ODEProblem","text":"function generate_ODEProblem(\n\tSC::SolverConfiguration,\n\ttspan;\n\tmass_matrix = nothing)\n\tkwargs...)\n\nReframes the ProblemDescription inside the SolverConfiguration into a SciMLBase.ODEProblem, for DifferentialEquations.jl where tspan is the desired time interval.\n\nIf no mass matrix is provided the standard mass matrix for the respective finite element space(s) for all unknowns is assembled.\n\nKeyword arguments:\n\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ninit: initial solution (otherwise starts with a zero vector). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first assembly). Default: false\nsametol: tolerance to identify two solution vectors to be identical (and to skip reassemblies called by DifferentialEquations.jl). Default: 1.0e-15\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/#ExtendableFEM.jac_prototype-Tuple{Any}","page":"Time-dependent Solvers","title":"ExtendableFEM.jac_prototype","text":"Provides the system matrix as prototype for the jacobian.\n\n\n\n\n\n","category":"method"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"note: Note\nThe solvers of DifferentialEquations should be run with the autodiff=false option as it is currently not possible to differentiate the right-hand side of the generated ODEProblem with respect to time.","category":"page"},{"location":"pdesolvers_dt/#Example-:-2D-Heat-equation","page":"Time-dependent Solvers","title":"Example : 2D Heat equation","text":"","category":"section"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"The following ProblemDescription yields the space discretisation of the heat equation (including homogeneous boundary conditions and equivalent to the Poisson equation).","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"PD = ProblemDescription(\"Heat Equation\")\nu = Unknown(\"u\"; name = \"temperature\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\nassign_operator!(PD, HomogeneousBoundaryData(u))","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"Given a finite element space FES and an initial FEVector sol for the unknown, the ODEProblem for some time interval (0,T) can be generated and solved via","category":"page"},{"location":"pdesolvers_dt/","page":"Time-dependent Solvers","title":"Time-dependent Solvers","text":"prob = generate_ODEProblem(PD, FES, (0, T); init = sol)\nDifferentialEquations.solve(prob, Rosenbrock23(autodiff = false), dt = 1e-3, dtmin = 1e-6, adaptive = true)","category":"page"},{"location":"postprocessing/#Other-packages","page":"Other packages","title":"Other packages","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"A lot of functionality is already provided by the bases packages, e.g.:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"ExtendableGrids.jl offers an interface to WriteVTK.jl which can be used, e.g. in combination with nodevalues interpolations or (piecewise constant) item integrator results. There is also the CellFinder that can be used to find the right cell for a certain point of the domain.\nExtendableFEMBase.jl offers a PointEvaluator and a SegmentIntegrator to evaluate solutions at arbitrary points of the domain or integrating along 1D line intersections with the cells of the triangulation. It also provides some basic unicode plots.\nGridVisualize.jl provides grid and scalar piecewise linear function plotting for various plotting backends on simplicial grids in one, two or three space dimensions. The main supported backends are PyPlot, GLMakie and PlutoVista.","category":"page"},{"location":"postprocessing/#Plots-and-Tables","page":"Other packages","title":"Plots and Tables","text":"","category":"section"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"Some convenient plotting shortcuts are avaiables via these functions:","category":"page"},{"location":"postprocessing/","page":"Other packages","title":"Other packages","text":"Modules = [ExtendableFEM]\nPages = [\"plots.jl\", \"io.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"postprocessing/#ExtendableFEM.plot!-Tuple{GridVisualize.GridVisualizer, Any, Any}","page":"Other packages","title":"ExtendableFEM.plot!","text":"function plot!(p::GridVisualizer, ops, sol; kwargs...)\n\nPlots the operator evaluations ops of blocks in sol into the GridVisualizer.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.plot","text":"function plot!(p::GridVisualizer, ops, sol; Plotter = nothing, kwargs...)\n\nPlots the operator evaluations ops of blocks in sol with the specified Plotter module that is supported by GridVisualize (e.g. GLMakie, PyPlot, Plots)\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_convergencehistory!-Tuple{Any, Any, Any}","page":"Other packages","title":"ExtendableFEM.plot_convergencehistory!","text":"function plot_convergencehistory!(\n\tp::GridVisualizer, \n\tX,\n\tY;\n\tadd_h_powers = [],\n\tX_to_h = X -> X,\n\tcolors = [:blue, :green, :red, :magenta, :lightblue],\n\ttitle = \"convergence history\",\n\tlegend = :best,\n\tylabel = \"\",\n\tylabels = [],\n\txlabel = \"ndofs\",\n\tmarkershape = :circle,\n\tmarkevery = 1,\n\tclear = true,\n\targs...,\n\nPlots a convergence history based on arrays X vs. Y into the GridVisualizer.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_convergencehistory-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.plot_convergencehistory","text":"function plot_convergencehistory(X, Y; Plotter = nothing, kwargs...)\n\nPlots a convergence history based on arrays X vs. Y into the GridVisualizer with the specified Plotter module (that needs to be supported by GridVisualize).\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.plot_unicode-Tuple{Any}","page":"Other packages","title":"ExtendableFEM.plot_unicode","text":"function plot_unicode(sol; kwargs...)\n\nPlots all blocks of sol into stdout (via plot_scalarplot from the UnicodePlots extension of ExtendableFEMBase)\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.print_convergencehistory-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.print_convergencehistory","text":"function print_convergencehistory(X, Y; X_to_h = X -> X, ylabels = [], xlabel = \"ndofs\", latex_mode = false, separator = latex_mode ? \"&\" : \"|\", order_seperator = latex_mode ? \"&\" : \"\")\n\nPrints a convergence history based on arrays X vs. Y.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#ExtendableFEM.print_table-Tuple{Any, Any}","page":"Other packages","title":"ExtendableFEM.print_table","text":"function print_table(X, Y; ylabels = [], xlabel = \"ndofs\")\n\nPrints a table with data X vs. Y\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example301_PoissonProblem/#301-:-Poisson-Problem","page":"Example301_PoissonProblem","title":"301 : Poisson-Problem","text":"","category":"section"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit cube domain Omega on a given grid. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"module Example301_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\nfunction f!(fval, qpinfo)\n    fval[1] = qpinfo.x[1] * qpinfo.x[2] * qpinfo.x[3]\n    return nothing\nend\n\nfunction main(; μ = 1.0, nrefs = 3, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"potential\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n    # discretize\n    xgrid = uniform_refine(grid_unitcube(Tetrahedron3D), nrefs)\n    FES = FESpace{H1P2{1, 3}}(xgrid)\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # plot\n    plt = plot([id(u)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"","category":"page"},{"location":"module_examples/Example301_PoissonProblem/","page":"Example301_PoissonProblem","title":"Example301_PoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interpolateboundarydata/#InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"","category":"section"},{"location":"interpolateboundarydata/","page":"InterpolateBoundaryData","title":"InterpolateBoundaryData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/interpolateboundarydata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"interpolateboundarydata/#ExtendableFEM.InterpolateBoundaryData","page":"InterpolateBoundaryData","title":"ExtendableFEM.InterpolateBoundaryData","text":"function InterpolateBoundaryData(u, data!::Function; kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to match the standard interpolation of the provided data! function. The header of this function needs to be conform to the interface\n\ndata!(result, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x provides the global coordinates of the quadrature/evaluation point.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to the quadorder chosen by the interpolator. Default: 0\nname: name for operator used in printouts. Default: ''BoundaryData''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nplot: plot unicode plot of boundary data into terminal when assembled. Default: false\nregions: subset of regions where operator should be assembly only. Default: Any[]\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"interpolateboundarydata/#ExtendableFEM.apply!-Tuple{ExtendableFEMBase.FEVectorBlock, InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.apply!","text":"apply!(U::FEVectorBlock, O::InterpolateBoundaryData; offset = 0, kwargs...)\n\napplies the boundary data of O to U, i.e., sets the boundary dofs to the correct values that have been computed during the last assemble! call.\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.apply_penalties!-Union{Tuple{UT}, Tuple{Any, Any, Any, InterpolateBoundaryData{UT}, SolverConfiguration}} where UT","page":"InterpolateBoundaryData","title":"ExtendableFEM.apply_penalties!","text":"apply_penalties!(A, b, sol, O::InterpolateBoundaryData{UT}, SC::SolverConfiguration; kwargs...)\n\nmodifies the linear system A|b such that the boundary dofs are penalized and attain the correct values from the last assemble! call of O. Also applies the correct values to sol.\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.assemble!-Union{Tuple{UT}, Tuple{Any, Any, Any, InterpolateBoundaryData{UT}, SolverConfiguration}} where UT","page":"InterpolateBoundaryData","title":"ExtendableFEM.assemble!","text":"assemble!(A, b, sol, O::InterpolateBoundaryData{UT}, SC::SolverConfiguration; kwargs...)\n\nassembles the correct boundary values for O by interpolating the boundary data with the current kwargs (where e.g. time and params might have changed).\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.fixed_dofs-Tuple{InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.fixed_dofs","text":"fixed_dofs(O::InterpolateBoundaryData)\n\nreturns the fixed degrees of freedoms of O\n\n\n\n\n\n","category":"method"},{"location":"interpolateboundarydata/#ExtendableFEM.fixed_vals-Tuple{InterpolateBoundaryData}","page":"InterpolateBoundaryData","title":"ExtendableFEM.fixed_vals","text":"fixed_vals(O::InterpolateBoundaryData)\n\nreturns the currently assembled values for the fixed degrees of freedom of O\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/#211-:-Poisson-L-shape-Local-Equilibrated-Fluxes","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"211 : Poisson L-shape Local Equilibrated Fluxes","text":"","category":"section"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This example computes a local equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"where sigma_h discretisates the exact sigma in the dual mixed problem","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"by some local equilibration strategy, see reference below for details.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This examples demonstrates the use of low-level structures to assemble individual problems and a strategy to solve several small problems in parallel by use of non-overlapping node patch groups.","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"reference: Reference\n''A posteriori error estimates for efficiency and error control in numerical simulations'' Lecture Notes by M. Vohralik >Link<","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"The resulting mesh and error convergence history for the default parameters looks like:","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"module Example211_LshapeAdaptiveEQPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    r2 = x[1]^2 + x[2]^2\n    φ = atan(x[2], x[1])\n    if φ < 0\n        φ += 2 * pi\n    end\n    result[1] = r2^(1 / 3) * sin(2 * φ / 3)\n    return nothing\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n    x = qpinfo.x\n    φ = atan(x[2], x[1])\n    r2 = x[1]^2 + x[2]^2\n    if φ < 0\n        φ += 2 * pi\n    end\n    ∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n    ∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n    result[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n    result[2] = sin(φ) * ∂r + cos(φ) * ∂φ\n    return nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n    u!(result, qpinfo)\n    ∇u!(view(result, 2:3), qpinfo)\n    result .-= u\n    result .= result .^ 2\n    return nothing\nend\n\n# kernel for equilibration error estimator\nfunction eqestimator_kernel!(result, input, qpinfo)\n    σ_h, divσ_h, ∇u_h = view(input, 1:2), input[3], view(input, 4:5)\n    result[1] = norm(σ_h .- ∇u_h)^2 + divσ_h^2\n    return nothing\nend\n\n# unknowns for primal and dual problem\nu = Unknown(\"u\"; name = \"u\")\nσ = Unknown(\"σ\"; name = \"equilibrated fluxes / dual stress\")\n\n# everything is wrapped in a main function\nfunction main(; maxdofs = 4000, μ = 1, order = 2, nlevels = 16, θ = 0.5, Plotter = nothing, kwargs...)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite elements for primal and dual problem (= for equilibrated fluxes)\n    FEType = H1Pk{1, 2, order}\n    FETypeDual = HDIVRTk{2, order}\n\n    # setup Poisson problem\n    PD = ProblemDescription(\"Poisson problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n    # define error estimator : || σ_h - ∇u_h ||^2 + || div σ_h ||^2\n    EQIntegrator = ItemIntegrator(eqestimator_kernel!, [id(σ), div(σ), grad(u)]; resultdim = 1, quadorder = 2 * order)\n\n    # setup exact error evaluations\n    ErrorIntegrator = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * order, kwargs...)\n\n    # refinement loop (only uniform for now)\n    NDofs = zeros(Int, 0)\n    NDofsDual = zeros(Int, 0)\n    ResultsL2 = zeros(Float64, 0)\n    ResultsH1 = zeros(Float64, 0)\n    Resultsη = zeros(Float64, 0)\n    sol = nothing\n    level = 0\n    while (true)\n        level += 1\n\n        # create a solution vector and solve the problem\n        FES = FESpace{FEType}(xgrid)\n        sol = solve(PD, FES)\n        push!(NDofs, length(view(sol[u])))\n        println(\"\\n  SOLVE LEVEL $level\")\n        println(\"    ndofs = $(NDofs[end])\")\n\n        # evaluate eqilibration error estimator and append it to sol vector (for plotting etc.)\n        local_equilibration_estimator!(sol, FETypeDual)\n        η4cell = evaluate(EQIntegrator, sol)\n        push!(Resultsη, sqrt(sum(view(η4cell, 1, :))))\n\n        # calculate L2 error, H1 error, estimator, dual L2 error and write to results\n        push!(NDofsDual, length(view(sol[σ])))\n        error = evaluate(ErrorIntegrator, sol)\n        push!(ResultsL2, sqrt(sum(view(error, 1, :))))\n        push!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n        println(\"  ESTIMATE\")\n        println(\"    ndofsDual = $(NDofsDual[end])\")\n        println(\"    estim H1 error = $(Resultsη[end])\")\n        println(\"    exact H1 error = $(ResultsH1[end])\")\n        println(\"    exact L2 error = $(ResultsL2[end])\")\n\n        if NDofs[end] >= maxdofs\n            break\n        end\n\n        # mesh refinement\n        if θ >= 1 ## uniform mesh refinement\n            xgrid = uniform_refine(xgrid)\n        else ## adaptive mesh refinement\n            facemarker = bulk_mark(xgrid, view(η4cell, :), θ; indicator_AT = ON_CELLS)\n            xgrid = RGB_refine(xgrid, facemarker)\n        end\n    end\n\n    # plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, resolution = (1000, 1000))\n    scalarplot!(plt[1, 1], id(u), sol; levels = 11, title = \"u_h\")\n    plot_convergencehistory!(plt[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n    gridplot!(plt[2, 1], xgrid; linewidth = 1)\n    gridplot!(plt[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\n    return sol, plt\nend\n\n# this function computes the local equilibrated fluxes\n# by solving local problems on (disjunct groups of) node patches\nfunction local_equilibration_estimator!(sol, FETypeDual)\n    # needed grid stuff\n    xgrid = sol[u].FES.xgrid\n    xCellNodes::Array{Int32, 2} = xgrid[CellNodes]\n    xCellVolumes::Array{Float64, 1} = xgrid[CellVolumes]\n    xNodeCells::Adjacency{Int32} = atranspose(xCellNodes)\n    nnodes::Int = num_sources(xNodeCells)\n\n    # get node patch groups that can be solved in parallel\n    group4node = xgrid[NodePatchGroups]\n\n    # init equilibration space (and Lagrange multiplier space)\n    FESDual = FESpace{FETypeDual}(xgrid)\n    xItemDofs::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = FESDual[CellDofs]\n    xItemDofs_uh::Union{VariableTargetAdjacency{Int32}, SerialVariableTargetAdjacency{Int32}, Array{Int32, 2}} = sol[u].FES[CellDofs]\n\n    # append block in solution vector for equilibrated fluxes\n    append!(sol, FESDual; tag = σ)\n\n    # partition of unity and their gradients = P1 basis functions\n    POUFES = FESpace{H1P1{1}}(xgrid)\n    POUqf = QuadratureRule{Float64, Triangle2D}(0)\n\n    # quadrature formulas\n    qf = QuadratureRule{Float64, Triangle2D}(2 * get_polynomialorder(FETypeDual, Triangle2D))\n    weights::Array{Float64, 1} = qf.w\n\n    # some constants\n    offset::Int = sol[u].offset\n    div_penalty::Float64 = 1.0e5      # divergence constraint is realized by penalisation\n    bnd_penalty::Float64 = 1.0e60     # penalty for non-involved dofs of a group\n    maxdofs::Int = max_num_targets_per_source(xItemDofs)\n    maxdofs_uh::Int = max_num_targets_per_source(xItemDofs_uh)\n\n    # redistribute groups for more equilibrated thread load (first groups are larger)\n    maxgroups = maximum(group4node)\n    groups = Array{Int, 1}(1:maxgroups)\n    for j::Int in 1:floor(maxgroups / 2)\n        a = groups[j]\n        groups[j] = groups[2 * j]\n        groups[2 * j] = a\n    end\n    X = Array{Array{Float64, 1}, 1}(undef, maxgroups)\n\n    function solve_patchgroup!(group)\n        # temporary variables\n        graduh = zeros(Float64, 2)\n        coeffs_uh = zeros(Float64, maxdofs_uh)\n        Alocal = zeros(Float64, maxdofs, maxdofs)\n        blocal = zeros(Float64, maxdofs)\n\n        # init system\n        A = ExtendableSparseMatrix{Float64, Int64}(FESDual.ndofs, FESDual.ndofs)\n        b = zeros(Float64, FESDual.ndofs)\n\n        # init FEBasiEvaluators\n        FEE_∇φ = FEEvaluator(POUFES, Gradient, POUqf)\n        FEE_xref = FEEvaluator(POUFES, Identity, qf)\n        FEE_∇u = FEEvaluator(sol[u].FES, Gradient, qf)\n        FEE_div = FEEvaluator(FESDual, Divergence, qf)\n        FEE_id = FEEvaluator(FESDual, Identity, qf)\n        idvals = FEE_id.cvals\n        divvals = FEE_div.cvals\n        xref_vals = FEE_xref.cvals\n        ∇φvals = FEE_∇φ.cvals\n\n        # find dofs at boundary of current node patches\n        # and in interior of cells outside of current node patch group\n        is_noninvolveddof = zeros(Bool, FESDual.ndofs)\n        outside_cell::Bool = false\n        for cell in 1:num_cells(xgrid)\n            outside_cell = true\n            for k in 1:3\n                if group4node[xCellNodes[k, cell]] == group\n                    outside_cell = false\n                    break\n                end\n            end\n            if (outside_cell) # mark interior dofs of outside cell\n                for j in 1:maxdofs\n                    is_noninvolveddof[xItemDofs[j, cell]] = true\n                end\n            end\n        end\n\n        for node in 1:nnodes\n            if group4node[node] == group\n                for c in 1:num_targets(xNodeCells, node)\n                    cell = xNodeCells[c, node]\n\n                    # find local node number of global node z\n                    # and evaluate (constant) gradient of nodal basis function phi_z\n                    localnode = 1\n                    while xCellNodes[localnode, cell] != node\n                        localnode += 1\n                    end\n                    FEE_∇φ.citem[] = cell\n                    update_basis!(FEE_∇φ)\n\n                    # read coefficients for discrete flux\n                    for j in 1:maxdofs_uh\n                        coeffs_uh[j] = sol.entries[offset + xItemDofs_uh[j, cell]]\n                    end\n\n                    # update other FE evaluators\n                    FEE_∇u.citem[] = cell\n                    FEE_div.citem[] = cell\n                    FEE_id.citem[] = cell\n                    update_basis!(FEE_∇u)\n                    update_basis!(FEE_div)\n                    update_basis!(FEE_id)\n\n                    # assembly on this cell\n                    for i in eachindex(weights)\n                        weight = weights[i] * xCellVolumes[cell]\n\n                        # evaluate grad(u_h) and nodal basis function at quadrature point\n                        fill!(graduh, 0)\n                        eval_febe!(graduh, FEE_∇u, coeffs_uh, i)\n\n                        # compute residual -f*phi_z + grad(u_h) * grad(phi_z) at quadrature point i ( f = 0 in this example !!! )\n                        temp2 = div_penalty * sqrt(xCellVolumes[cell]) * weight\n                        temp = temp2 * dot(graduh, view(∇φvals, :, localnode, 1))\n                        for dof_i in 1:maxdofs\n                            # right-hand side for best-approximation (grad(u_h)*phi)\n                            blocal[dof_i] += dot(graduh, view(idvals, :, dof_i, i)) * xref_vals[1, localnode, i] * weight\n                            # mass matrix Hdiv\n                            for dof_j in dof_i:maxdofs\n                                Alocal[dof_i, dof_j] += dot(view(idvals, :, dof_i, i), view(idvals, :, dof_j, i)) * weight\n                            end\n                            # div-div matrix Hdiv * penalty (quick and dirty to avoid Lagrange multiplier)\n                            blocal[dof_i] += temp * divvals[1, dof_i, i]\n                            temp3 = temp2 * divvals[1, dof_i, i]\n                            for dof_j in dof_i:maxdofs\n                                Alocal[dof_i, dof_j] += temp3 * divvals[1, dof_j, i]\n                            end\n                        end\n                    end\n\n                    # write into global A and b\n                    for dof_i in 1:maxdofs\n                        dofi = xItemDofs[dof_i, cell]\n                        b[dofi] += blocal[dof_i]\n                        for dof_j in 1:maxdofs\n                            dofj = xItemDofs[dof_j, cell]\n                            if dof_j < dof_i # use that Alocal is symmetric\n                                _addnz(A, dofi, dofj, Alocal[dof_j, dof_i], 1)\n                            else\n                                _addnz(A, dofi, dofj, Alocal[dof_i, dof_j], 1)\n                            end\n                        end\n                    end\n\n                    # reset local A and b\n                    fill!(Alocal, 0)\n                    fill!(blocal, 0)\n                end\n            end\n        end\n\n        # penalize dofs that are not involved\n        for j in 1:FESDual.ndofs\n            if is_noninvolveddof[j]\n                A[j, j] = bnd_penalty\n                b[j] = 0\n            end\n        end\n\n        # solve local problem\n        return A \\ b\n    end\n\n    # solve equilibration problems on vertex patches (in parallel)\n    Threads.@threads for group in groups\n        grouptime = @elapsed begin\n            @info \"  Starting equilibrating patch group $group on thread $(Threads.threadid())... \"\n            X[group] = solve_patchgroup!(group)\n        end\n        @info \"Finished equilibration patch group $group on thread $(Threads.threadid()) in $(grouptime)s \"\n    end\n\n    # write local solutions to global vector (sequentially)\n    for group in 1:maxgroups\n        view(sol[σ]) .+= X[group]\n    end\n    return\nend\n\nend","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"","category":"page"},{"location":"module_examples/Example211_LshapeAdaptiveEQPoissonProblem/","page":"Example211_LshapeAdaptiveEQPoissonProblem","title":"Example211_LshapeAdaptiveEQPoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/#245-:-Flow-around-a-cylinder","page":"Example245_NSEFlowAroundCylinder","title":"245 : Flow around a cylinder","text":"","category":"section"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(source code)","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This example solves the DFG Navier-Stokes benchmark problem","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"on a rectangular 2D domain with a circular obstacle, see here for details.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This script demonstrates the employment of external grid generators and the computation of drag and lift coefficients.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"Note: This example needs the additional packages Triangulate and SimplexGridFactory to generate the mesh.","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"(Image: )","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"module Example245_NSEFlowAroundCylinder\n\nusing ExtendableFEM\nusing Triangulate\nusing SimplexGridFactory\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\n# inlet data for Karman vortex street example\n# as in DFG benchmark 2D-1 (Re = 20, laminar)\nconst umax = 0.3\nconst umean = 2 // 3 * umax\nconst L, W, H = 0.1, 2.2, 0.41\nfunction inflow!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 4 * umax * x[2] * (H - x[2]) / (H * H)\n    result[2] = 0.0\n    return nothing\nend\n\n# hand constructed identity matrix for kernel to avoid allocations\nconst II = [1 0; 0 1]\n\n\n# Example of a kernel using tensor_view() function to allow for an operator\n# based style of writing the semilinear form.\n# For comparison we also provide the kernel_nonlinear_flat! function below\n# that uses a component-wise style of writing the semilinear form.\n\n#\n# the scalar product ``(\\nabla v, \\mu \\nabla u - pI)`` will be evaluated\n# so in general `a = b` corresponds to ``(a,b)``.\n\n# Note that the order of vector entries between the kernel and the call to\n# NonlinearOperator have to match.\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    # Shape values of vectorial u are starting at index 1\n    # view as 1-tensor(vector) of length dim=2 in 2D\n    u = tensor_view(u_ops, 1, TDVector(2))\n    v = tensor_view(result, 1, TDVector(2))\n    # gradients of vectorial u are starting at index 3\n    # view as 2-tensor of size 2x2 in 2D\n    ∇u = tensor_view(u_ops, 3, TDMatrix(2))\n    ∇v = tensor_view(result, 3, TDMatrix(2))\n    # values of scalar p are starting at index 7\n    # view as 0-tensor (single value)\n    p = tensor_view(u_ops, 7, TDScalar())\n    q = tensor_view(result, 7, TDScalar())\n    # get viscosity at current quadrature point\n    μ = qpinfo.params[1]\n    # Note that all operators should be element-wise to avoid allocations\n    # `(v,u⋅∇u) = (v,∇u^T⋅u)`\n    tmul!(v, ∇u, u)\n    # `(∇v,μ∇u-pI)`\n    ∇v .= μ .* ∇u .- p[1] .* II\n    # `(q,-∇⋅u)`\n    q[1] = -dot(∇u, II)\n    return nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1.0e-3, maxvol = 1.0e-3, reconstruct = true, parallel = false, npart = 8, kwargs...)\n\n    # load grid (see function below)\n    xgrid = make_grid(W, H; n = Int(ceil(sqrt(1 / maxvol))), maxvol = maxvol)\n    if parallel\n        xgrid = partition(xgrid, RecursiveMetisPartitioning(npart = npart))\n    end\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], parallel = parallel, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, inflow!; regions = 4))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 3, 5]))\n\n    # P2-bubble + reconstruction operator\n    FETypes = [H1P2B{2, 2}, H1P1{1}]\n\n    # generate FESpaces and Solution vector\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n\n    # solve\n    sol = solve(PD, FES; maxiterations = 50, target_residual = 1.0e-10)\n\n    # postprocess : compute drag/lift (see function below)\n    draglift = get_draglift(sol, μ; parallel = parallel, kwargs...)\n    pdiff = get_pressure_difference(sol)\n    println(\"[drag, lift] = $draglift\")\n    println(\"p difference = $pdiff\")\n\n    # plots via GridVisualize\n    plt = GridVisualizer(; Plotter = Plotter, layout = (4, 1), clear = true, size = (800, 1200))\n    gridplot!(plt[1, 1], xgrid, cellcoloring = :partitions, linewidth = 1)\n    gridplot!(plt[2, 1], xgrid, cellcoloring = :partitions, linewidth = 1, xlimits = [0, 0.3], ylimits = [0.1, 0.3])\n    scalarplot!(plt[3, 1], xgrid, nodevalues(sol[u]; abs = true)[1, :])\n    vectorplot!(plt[3, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), rasterpoints = 20, clear = false)\n    scalarplot!(plt[4, 1], xgrid, view(nodevalues(sol[p]), 1, :), levels = 11, title = \"p_h\")\n\n    return [draglift[1], draglift[2], pdiff[1]], plt\nend\n\nfunction get_pressure_difference(sol::FEVector)\n    xgrid = sol[2].FES.xgrid\n    PE = PointEvaluator([id(2)], sol)\n    p_left = zeros(Float64, 1)\n    x1 = [0.15, 0.2]\n    p_right = zeros(Float64, 1)\n    x2 = [0.25, 0.2]\n    evaluate!(p_left, PE, x1)\n    evaluate!(p_right, PE, x2)\n    @show p_left, p_right\n    return p_left - p_right\nend\n\nfunction get_draglift(sol::FEVector, μ; parallel = false, kwargs...)\n\n    # this function is interpolated for drag/lift test function creation\n    function DL_testfunction(component)\n        return function closure(result, qpinfo)\n            x = qpinfo.x\n            fill!(result, 0)\n            return if sqrt((x[1] - 0.2)^2 + (x[2] - 0.2)^2) <= 0.06\n                result[component] = 1\n            end\n        end\n    end\n\n    # drag lift calculation by testfunctions\n    function draglift_kernel(result, input, qpinfo)\n        # input = [ u, grad(u), p , v , grad(v)]\n        #         [1:2,  3:6,   7 ,8:9,  10:13 ]\n        result[1] = μ * (input[3] * input[10] + input[4] * input[11] + input[5] * input[12] + input[6] * input[13])\n        result[1] += (input[1] * input[3] + input[2] * input[4]) * input[8]\n        result[1] += (input[1] * input[5] + input[2] * input[6]) * input[9]\n        result[1] -= input[7] * (input[10] + input[13])\n        result[1] *= -(2 / (umean^2 * L))\n        return nothing\n    end\n    DLIntegrator = ItemIntegrator(draglift_kernel, [id(1), grad(1), id(2), id(3), grad(3)]; quadorder = 4, parallel = parallel, kwargs...)\n\n    # test for drag\n    TestFunction = FEVector(sol[1].FES; name = \"drag/lift testfunction\")\n    interpolate!(TestFunction[1], ON_BFACES, DL_testfunction(1))\n    drag = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n    # test for lift\n    interpolate!(TestFunction[1], ON_BFACES, DL_testfunction(2))\n    lift = sum(evaluate(DLIntegrator, [sol[1], sol[2], TestFunction[1]]))\n\n    return [drag, lift]\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(W, H; n = 20, maxvol = 0.1)\n    builder = SimplexGridBuilder(Generator = Triangulate)\n    function circlehole!(builder, center, radius; n = 20)\n        points = [point!(builder, center[1] + radius * sin(t), center[2] + radius * cos(t)) for t in range(0, 2π, length = n)]\n        for i in 1:(n - 1)\n            facet!(builder, points[i], points[i + 1])\n        end\n        facet!(builder, points[end], points[1])\n        return holepoint!(builder, center)\n    end\n    p1 = point!(builder, 0, 0)\n    p2 = point!(builder, W, 0)\n    p3 = point!(builder, W, H)\n    p4 = point!(builder, 0, H)\n\n    # heuristic refinement around cylinder\n    refine_radius = 0.25\n    maxrefinefactor = 1 // 20\n    function unsuitable(x1, y1, x2, y2, x3, y3, area)\n        if area > maxvol * min(max(4 * maxrefinefactor, abs((x1 + x2 + x3) / 3 - 0.2)), 1 / maxrefinefactor)\n            return true\n        end\n        dist = sqrt(((x1 + x2 + x3) / 3 - 0.2)^2 + ((y1 + y2 + y3) / 3 - 0.2)^2) - 0.05\n        myarea = dist < refine_radius ? maxvol * max(maxrefinefactor, 1 - (refine_radius - dist) / refine_radius) : maxvol\n        if area > myarea\n            return true\n        else\n            return false\n        end\n    end\n\n    facetregion!(builder, 1)\n    facet!(builder, p1, p2)\n    facetregion!(builder, 2)\n    facet!(builder, p2, p3)\n    facetregion!(builder, 3)\n    facet!(builder, p3, p4)\n    facetregion!(builder, 4)\n    facet!(builder, p4, p1)\n    facetregion!(builder, 5)\n    circlehole!(builder, (0.2, 0.2), 0.05, n = n)\n\n    return simplexgrid(builder, maxvolume = 16 * maxvol, unsuitable = unsuitable)\nend\n\nend","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"","category":"page"},{"location":"module_examples/Example245_NSEFlowAroundCylinder/","page":"Example245_NSEFlowAroundCylinder","title":"Example245_NSEFlowAroundCylinder","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example205_HeatEquation/#205-:-Heat-equation","page":"Example205_HeatEquation","title":"205 : Heat equation","text":"","category":"section"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"This example computes the solution u of the two-dimensional heat equation","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"beginaligned\nu_t - Delta u  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"for homogeneous Dirichlet boundary conditions and some given initial state on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"The initial condition and the final solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"module Example205_HeatEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing OrdinaryDiffEqSDIRK\n\n# initial state u at time t0\nfunction initial_data!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = exp(-5 * x[1]^2 - 5 * x[2]^2)\n    return nothing\nend\n\nfunction main(;\n        nrefs = 4, T = 2.0, τ = 1.0e-3, order = 2, use_diffeq = true,\n        solver = ImplicitEuler(autodiff = false), Plotter = nothing, kwargs...\n    )\n\n    # problem description\n    PD = ProblemDescription(\"Heat Equation\")\n    u = Unknown(\"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; store = true, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n    # prepare solution vector and initial data u0\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n    sol = FEVector(FES; tags = PD.unknowns)\n    interpolate!(sol[u], initial_data!; bonus_quadorder = 5)\n\n    # init plotter and plot u0\n    plt = plot([id(u)], sol; add = 1, Plotter = Plotter, title_add = \" (t = 0)\")\n\n    if (use_diffeq)\n        # generate DifferentialEquations.ODEProblem\n        prob = generate_ODEProblem(PD, FES, (0.0, T); init = sol, constant_matrix = true)\n\n        # solve ODE problem\n        de_sol = solve(prob, solver, abstol = 1.0e-6, reltol = 1.0e-3, dt = τ, dtmin = 1.0e-6, adaptive = true)\n        @info \"#tsteps = $(length(de_sol))\"\n\n        # get final solution\n        sol.entries .= de_sol[end]\n    else\n        # add backward Euler time derivative\n        M = FEMatrix(FES)\n        assemble!(M, BilinearOperator([id(1)]))\n        assign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n        assign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n        # generate solver configuration\n        SC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, constant_matrix = true, kwargs...)\n\n        # iterate tspan\n        t = 0\n        for it in 1:Int(floor(T / τ))\n            t += τ\n            ExtendableFEM.solve(PD, FES, SC; time = t)\n        end\n    end\n\n    # plot final state\n    plot!(plt, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"","category":"page"},{"location":"module_examples/Example205_HeatEquation/","page":"Example205_HeatEquation","title":"Example205_HeatEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/#212-:-Periodic-Boundary-2D","page":"Example212_PeriodicBoundary2D","title":"212 : Periodic Boundary 2D","text":"","category":"section"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"(source code)","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"This is a simple demonstration and validation of the generic periodic boundary operator.","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"We construct an unstructured periodic 2D grid and solve a simple linear elastic problem with periodic boundary coupling along the x-axis.","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"(Image: )","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"module Example212_PeriodicBoundary2D\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing GridVisualize\nusing Triangulate\nusing UnicodePlots\nusing StaticArrays\nusing LinearAlgebra\nusing SparseArrays\n\n# enumerate the boundary regions\nconst reg_left = 4\nconst reg_right = 2\nconst reg_dirichlet = 1\nconst reg_default = 3\n\n# 2D reduction of the material used in Example 312\n# in Voigt notation\nfunction material_tensor()\n    c11 = 396.0\n    c12 = 137.0\n    c44 = 116.0\n\n    return @SArray [\n        c11 c12 0\n        c12 c11 0\n        0   0   c44\n    ]\nend\n\n# generate the kernels for the linear problem\n# 𝐂: Hooke tensor, 𝑓: body force\nfunction make_kernels(𝐂, 𝑓)\n\n    # linear stress-strain mapping\n    bilinear_kernel!(σ, εv, qpinfo) = mul!(σ, 𝐂, εv)\n\n    # plain body force\n    linear_kernel!(result, qpinfo) = (result .= 𝑓)\n\n    return bilinear_kernel!, linear_kernel!\nend\n\n\n\"\"\"\n    create a 2D grid with Dirichlet boundary region at the bottom center\n\"\"\"\nfunction create_grid(; h, height, width)\n    builder = SimplexGridBuilder(; Generator = Triangulate)\n\n    # bottom points\n    b1 = point!(builder, 0, 0)\n    b2 = point!(builder, 0.45 * width, 0)\n    b3 = point!(builder, 0.5 * width, 0)\n    b4 = point!(builder, 0.55 * width, 0)\n    b5 = point!(builder, width, 0)\n\n    # top points\n    t1 = point!(builder, 0, height)\n    t2 = point!(builder, width / 2, height)\n    t3 = point!(builder, width, height)\n\n    # default faces\n    facetregion!(builder, reg_default)\n    facet!(builder, b1, b2)\n    facet!(builder, b4, b5)\n    facet!(builder, t1, t2)\n    facet!(builder, t2, t3)\n\n    # left face\n    facetregion!(builder, reg_left)\n    facet!(builder, b1, t1)\n\n    # right face\n    facetregion!(builder, reg_right)\n    facet!(builder, b5, t3)\n\n    # Dirichlet face\n    facetregion!(builder, reg_dirichlet)\n    facet!(builder, b3, b4)\n    facet!(builder, b2, b3)\n\n    # divider\n    facetregion!(builder, reg_default)\n    facet!(builder, t2, b3)\n\n\n    cellregion!(builder, 1)\n    maxvolume!(builder, h)\n    regionpoint!(builder, width / 3, height / 2)\n\n    cellregion!(builder, 2)","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"much finer grid on the right half to make periodic coupling non-trivial","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"    maxvolume!(builder, 0.1 * h)\n    regionpoint!(builder, 2width / 3, height / 2)\n\n    return simplexgrid(builder)\nend\n\nfunction main(;\n        order = 1,\n        periodic = true,\n        Plotter = nothing,\n        force = 10.0,\n        h = 1.0e-2,\n        width = 6.0,\n        height = 1.0,\n        kwargs...\n    )\n    xgrid = create_grid(; h, width, height)\n\n    # create finite element space and solution vector\n    if order == 1\n        FES = FESpace{H1P1{2}}(xgrid)\n    elseif order == 2\n        FES = FESpace{H1P2{2, 2}}(xgrid)\n    end\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"displacement\")\n    assign_unknown!(PD, u)\n\n    𝐂 = material_tensor()\n    𝑓 = force * [0, 1]\n\n    bilinear_kernel!, linear_kernel! = make_kernels(𝐂, 𝑓)\n    assign_operator!(PD, BilinearOperator(bilinear_kernel!, [εV(u, 1.0)]; kwargs...))\n    assign_operator!(PD, LinearOperator(linear_kernel!, [id(u)]; kwargs...))\n\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [reg_dirichlet]))\n\n    if periodic\n        function give_opposite!(y, x)\n            y .= x\n            y[1] = width - x[1]\n            return nothing\n        end\n\n        coupling_matrix = get_periodic_coupling_matrix(FES, xgrid, reg_left, reg_right, give_opposite!)\n        display(coupling_matrix)\n        assign_operator!(PD, CombineDofs(u, u, coupling_matrix; kwargs...))\n    end\n\n    sol = solve(PD, FES)\n\n    plt = GridVisualizer(; Plotter, size = (1300, 800))\n\n    magnification = 1\n    displaced_grid = deepcopy(xgrid)\n    displace_mesh!(displaced_grid, sol[1], magnify = magnification)\n    gridplot!(plt, displaced_grid, linewidth = 1, title = \"displaced mesh, $(magnification)x magnified\", scene3d = :LScene)\n\n    return sol, plt\nend\n\n\nend # module","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"","category":"page"},{"location":"module_examples/Example212_PeriodicBoundary2D/","page":"Example212_PeriodicBoundary2D","title":"Example212_PeriodicBoundary2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/#280-:-Compressible-Stokes","page":"Example280_CompressibleStokes","title":"280 : Compressible Stokes","text":"","category":"section"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"(source code)","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This example solves the two-dimensional compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"Here, eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"There are two testcases. The first testcase solves an analytical toy problem with the prescribed solution","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = exp(-yc) \np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. The second testcase tests an analytical nonzero velocity benchmark problem with the same density.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This example is designed to study the well-balanced property of a discretisation. The gradient-robust discretisation approximates the well-balanced state much better, i.e. has a much smaller L2 velocity error. For larger c (= smaller Mach number) the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. See reference below for more details.","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"(Image: )","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"module Example280_CompressibleStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Triangulate\nusing SimplexGridFactory\nusing GridVisualize\nusing Symbolics\nusing LinearAlgebra\n\n# everything is wrapped in a main function\n# testcase = 1 : well-balanced test (stratified no-flow over mountain)\n# testcase = 2 : vortex example (ϱu is div-free p7 vortex)\nfunction main(;\n        testcase = 1,\n        nrefs = 4,\n        M = 1,\n        c = 1,\n        ufac = 100,\n        pressure_stab = 0,\n        laplacian_in_rhs = false, # for data in example 2\n        maxsteps = 5000,\n        target_residual = 1.0e-11,\n        Plotter = nothing,\n        reconstruct = true,\n        μ = 1,\n        order = 1,\n        kwargs...\n    )\n\n    # load data for testcase\n    grid_builder, kernel_gravity!, kernel_rhs!, u!, ∇u!, ϱ!, τfac = load_testcase_data(testcase; laplacian_in_rhs = laplacian_in_rhs, M = M, c = c, μ = μ, ufac = ufac)\n    xgrid = grid_builder(nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    ϱ = Unknown(\"ϱ\"; name = \"density\", dim = 1)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n\n    # define reconstruction operator\n    if order == 1\n        FETypes = [H1BR{2}, L2P0{1}, L2P0{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT0{2}, Identity}) : id(u)\n    elseif order == 2\n        FETypes = [H1P2B{2, 2}, L2P1{1}, L2P1{1}]\n        id_u = reconstruct ? apply(u, Reconstruct{HDIVRT1{2}, Identity}) : id(u)\n    end\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n    assign_operator!(PD, LinearOperator([div(u)], [id(ϱ)]; factor = c, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    if kernel_rhs! !== nothing\n        assign_operator!(PD, LinearOperator(kernel_rhs!, [id_u]; factor = 1, store = true, bonus_quadorder = 3 * order, kwargs...))\n    end\n    assign_operator!(PD, LinearOperator(kernel_gravity!, [id_u], [id(ϱ)]; factor = 1, bonus_quadorder = 3 * order, kwargs...))\n\n    # FVM for continuity equation\n    τ = μ / (order^2 * M * sqrt(τfac)) # time step for pseudo timestepping\n    @info \"timestep = $τ\"\n    PDT = ProblemDescription(\"continuity equation\")\n    assign_unknown!(PDT, ϱ)\n    if order > 1\n        assign_operator!(PDT, BilinearOperator(kernel_continuity!, [grad(ϱ)], [id(ϱ)], [id(u)]; quadorder = 2 * order, factor = -1, kwargs...))\n    end\n    if pressure_stab > 0\n        psf = pressure_stab #* xgrid[CellVolumes][1]\n        assign_operator!(PDT, BilinearOperator(stab_kernel!, [jump(id(ϱ))], [jump(id(ϱ))], [id(u)]; entities = ON_IFACES, factor = psf, kwargs...))\n    end\n    assign_operator!(PDT, BilinearOperator([id(ϱ)]; quadorder = 2 * (order - 1), factor = 1 / τ, store = true, kwargs...))\n    assign_operator!(PDT, LinearOperator([id(ϱ)], [id(ϱ)]; quadorder = 2 * (order - 1), factor = 1 / τ, kwargs...))\n    assign_operator!(PDT, BilinearOperatorDG(kernel_upwind!, [jump(id(ϱ))], [this(id(ϱ)), other(id(ϱ))], [id(u)]; quadorder = order + 1, entities = ON_IFACES, kwargs...))\n\n    # prepare error calculation\n    EnergyIntegrator = ItemIntegrator(energy_kernel!, [id(u)]; resultdim = 1, quadorder = 2 * (order + 1), kwargs...)\n    ErrorIntegratorExact = ItemIntegrator(exact_error!(u!, ∇u!, ϱ!), [id(u), grad(u), id(ϱ)]; resultdim = 9, quadorder = 2 * (order + 1), kwargs...)\n    NDofs = zeros(Int, nrefs)\n    Results = zeros(Float64, nrefs, 5)\n\n    sol = nothing\n    xgrid = nothing\n    op_upwind = 0\n    for lvl in 1:nrefs\n        xgrid = grid_builder(lvl)\n        @show xgrid\n        FES = [FESpace{FETypes[j]}(xgrid) for j in 1:3]\n        sol = FEVector(FES; tags = [u, ϱ, p])\n\n        # initial guess\n        fill!(sol[ϱ], M)\n        interpolate!(sol[u], u!)\n        interpolate!(sol[ϱ], ϱ!)\n        NDofs[lvl] = length(sol.entries)\n\n        # solve the two problems iteratively [1] >> [2] >> [1] >> [2] ...\n        SC1 = SolverConfiguration(PD; init = sol, maxiterations = 1, target_residual = target_residual, constant_matrix = true, kwargs...)\n        SC2 = SolverConfiguration(PDT; init = sol, maxiterations = 1, target_residual = target_residual, kwargs...)\n        sol, nits = iterate_until_stationarity([SC1, SC2]; energy_integrator = EnergyIntegrator, maxsteps = maxsteps, init = sol, kwargs...)\n\n        # calculate error\n        error = evaluate(ErrorIntegratorExact, sol)\n        Results[lvl, 1] = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n        Results[lvl, 2] = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n        Results[lvl, 3] = sqrt(sum(view(error, 7, :)))\n        Results[lvl, 4] = sqrt(sum(view(error, 8, :)) + sum(view(error, 9, :)))\n        Results[lvl, 5] = nits\n\n        # print results\n        print_convergencehistory(NDofs[1:lvl], Results[1:lvl, :]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\", \"#its\"], xlabel = \"ndof\")\n    end\n\n\n    # plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n    scalarplot!(plt[1, 1], xgrid, view(nodevalues(sol[u]; abs = true), 1, :), levels = 0, colorbarticks = 7)\n    vectorplot!(plt[1, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), rasterpoints = 10, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(plt[2, 1], xgrid, view(nodevalues(sol[ϱ]), 1, :), levels = 11, title = \"ϱ_h\")\n    plot_convergencehistory!(plt[1, 2], NDofs, Results[:, 1:4]; add_h_powers = [order, order + 1], X_to_h = X -> 0.2 * X .^ (-1 / 2), legend = :best, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| ϱ - ϱ_h ||\", \"|| ϱu - ϱu_h ||\", \"#its\"])\n    gridplot!(plt[2, 2], xgrid)\n\n    return Results, plt\nend\n\nfunction stab_kernel!(result, p, u, qpinfo)\n    result[1] = p[1] #*abs(u[1] + u[2])\n    return nothing\nend\n\n# kernel for (uϱ, ∇λ) ON_CELLS in continuity equation\nfunction kernel_continuity!(result, ϱ, u, qpinfo)\n    result[1] = ϱ[1] * u[1]\n    result[2] = ϱ[1] * u[2]\n    return nothing\nend\n\n# kernel for (u⋅n ϱ^upw, λ) ON_IFACES in continuity equation\nfunction kernel_upwind!(result, input, u, qpinfo)\n    flux = dot(u, qpinfo.normal) # u * n\n    return if flux > 0\n        result[1] = input[1] * flux # rho_left * flux\n    else\n        result[1] = input[2] * flux # rho_righ * flux\n    end\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!, ∇u!, ϱ!)\n    return function closure(result, u, qpinfo)\n        u!(view(result, 1:2), qpinfo)\n        ∇u!(view(result, 3:6), qpinfo)\n        ϱ!(view(result, 7), qpinfo)\n        result[8] = result[1] * result[7]\n        result[9] = result[2] * result[7]\n        view(result, 1:7) .-= u\n        result[8] -= u[1] * u[7]\n        result[9] -= u[2] * u[7]\n        return result .= result .^ 2\n    end\nend\n\n# kernel for gravity term in testcase 1\nfunction standard_gravity!(result, ϱ, qpinfo)\n    result[1] = 0\n    result[2] = -ϱ[1]\n    return nothing\nend\n\nfunction energy_kernel!(result, u, qpinfo)\n    result[1] = dot(u, u) / 2\n    return nothing\nend\n\nfunction load_testcase_data(testcase::Int = 1; laplacian_in_rhs = true, M = 1, c = 1, μ = 1, ufac = 100)\n    if testcase == 1\n        grid_builder = (nref) -> simplexgrid(\n            Triangulate;\n            points = [0 0; 0.2 0; 0.3 0.2; 0.45 0.05; 0.55 0.35; 0.65 0.2; 0.7 0.3; 0.8 0; 1 0; 1 1 ; 0 1]',\n            bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 1]',\n            bfaceregions = ones(Int, 11),\n            regionpoints = [0.5 0.5;]',\n            regionnumbers = [1],\n            regionvolumes = [4.0^-(nref) / 2]\n        )\n        xgrid = grid_builder(3)\n        u1!(result, qpinfo) = (fill!(result, 0);)\n        ∇u1!(result, qpinfo) = (fill!(result, 0);)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[2] / c) / M;), 1; quadorder = 20)\n        area = sum(xgrid[CellVolumes])\n        ϱ1!(result, qpinfo) = (result[1] = exp(-qpinfo.x[2] / c) / (M_exact / area);)\n        return grid_builder, standard_gravity!, nothing, u1!, ∇u1!, ϱ1!, 1\n    elseif testcase == 2\n        grid_builder = (nref) -> simplexgrid(\n            Triangulate;\n            points = [0 0; 1 0; 1 1 ; 0 1]',\n            bfaces = [1 2; 2 3; 3 4; 4 1]',\n            bfaceregions = ones(Int, 4),\n            regionpoints = [0.5 0.5;]',\n            regionnumbers = [1],\n            regionvolumes = [4.0^-(nref)]\n        )\n\n        xgrid = grid_builder(3)\n        M_exact = integrate(xgrid, ON_CELLS, (result, qpinfo) -> (result[1] = exp(-qpinfo.x[1]^3 / (3 * c));), 1; quadorder = 20)\n        ϱ_eval, g_eval, f_eval, u_eval, ∇u_eval = prepare_data!(; laplacian_in_rhs = laplacian_in_rhs, M = M_exact, c = c, μ = μ, ufac = ufac)\n        ϱ2!(result, qpinfo) = (result[1] = ϱ_eval(qpinfo.x[1], qpinfo.x[2]);)\n\n        M_exact = integrate(xgrid, ON_CELLS, ϱ2!, 1)\n        area = sum(xgrid[CellVolumes])\n\n        function kernel_gravity!(result, input, qpinfo)\n            g_eval(result, qpinfo.x[1], qpinfo.x[2])\n            return result .*= input[1]\n        end\n\n        function kernel_rhs!(result, qpinfo)\n            return f_eval(result, qpinfo.x[1], qpinfo.x[2])\n        end\n\n        u2!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        ∇u2!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n        return grid_builder, kernel_gravity!, f_eval === nothing ? nothing : kernel_rhs!, u2!, ∇u2!, ϱ2!, ufac\n    end\nend\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; M = 1, c = 1, μ = 1, ufac = 100, laplacian_in_rhs = true)\n\n    @variables x y\n\n    # density\n    ϱ = exp(-x^3 / (3 * c)) / M\n\n    # stream function ξ\n    # sucht that ϱu = curl ξ\n    ξ = x^2 * y^2 * (x - 1)^2 * (y - 1)^2 * ufac\n\n    ∇ξ = Symbolics.gradient(ξ, [x, y])\n\n    # velocity u = curl ξ / ϱ\n    u = [-∇ξ[2], ∇ξ[1]] ./ ϱ\n\n    # gradient of velocity\n    ∇u = Symbolics.jacobian(u, [x, y])\n    ∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n    # Laplacian\n    Δu = [\n        (Symbolics.gradient(∇u[1, 1], [x]) + Symbolics.gradient(∇u[1, 2], [y]))[1],\n        (Symbolics.gradient(∇u[2, 1], [x]) + Symbolics.gradient(∇u[2, 2], [y]))[1],\n    ]\n\n    # gravity ϱg = - Δu + ϱ∇log(ϱ)\n\n    if laplacian_in_rhs\n        f = - μ * Δu\n        g = c * Symbolics.gradient(log(ϱ), [x, y])\n    else\n        g = - μ * Δu / ϱ + c * Symbolics.gradient(log(ϱ), [x, y])\n        f = 0\n    end\n\n    #Δu = Symbolics.derivative(∇u[1,1], [x]) + Symbolics.derivative(∇u[2,2], [y])\n\n    ϱ_eval = build_function(ϱ, x, y, expression = Val{false})\n    u_eval = build_function(u, x, y, expression = Val{false})\n    ∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n    g_eval = build_function(g, x, y, expression = Val{false})\n    f_eval = build_function(f, x, y, expression = Val{false})\n\n    return ϱ_eval, g_eval[2], f == 0 ? nothing : f_eval[2], u_eval[2], ∇u_eval[2]\nend\n\nend","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"","category":"page"},{"location":"module_examples/Example280_CompressibleStokes/","page":"Example280_CompressibleStokes","title":"Example280_CompressibleStokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"callbackoperator/#CallbackOperator","page":"CallbackOperator","title":"CallbackOperator","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"A callback operator passes the matrix and rhs to a user-defined function where they can be modified as desired. An example where this is used is Example265.","category":"page"},{"location":"callbackoperator/#Constructors","page":"CallbackOperator","title":"Constructors","text":"","category":"section"},{"location":"callbackoperator/","page":"CallbackOperator","title":"CallbackOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/callback_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"callbackoperator/#ExtendableFEM.CallbackOperator","page":"CallbackOperator","title":"ExtendableFEM.CallbackOperator","text":"function CallbackOperator(\n\tcallback!::Function,\n\tu_args = [];\n\tkwargs...)\n\nGenerates an operator that simply passes the matrix and rhs to a user-specified call back function. The callback function needs to be conform to the interface\n\ncallback!(A, b, args; assemble_matrix = true, assemble_rhs = true, time = 0, kwargs...)\n\nThe u_args argument can be used to specify the arguments of the solution that should be passed as args (a vector of FEVectorBlocks) to the callback.\n\nKeyword arguments:\n\nlinearized_dependencies: [uansatz, utest] when linearized. Default: auto\nmodifies_matrix: callback function modifies the matrix?. Default: true\nmodifies_rhs: callback function modifies the rhs?. Default: true\nname: name for operator used in printouts. Default: ''CallbackOperator''\nstore: store matrix and rhs separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"fixdofs/#FixDofs","page":"FixDofs","title":"FixDofs","text":"","category":"section"},{"location":"fixdofs/","page":"FixDofs","title":"FixDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/fixdofs_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fixdofs/#ExtendableFEM.FixDofs-Tuple{Any}","page":"FixDofs","title":"ExtendableFEM.FixDofs","text":"function FixDofs(u; vals = [], dofs = [], kwargs...)\n\nWhen assembled, all specified dofs of the unknown u will be penalized to the specified values.\n\nKeyword arguments:\n\nname: name for operator used in printouts. Default: ''FixDofs''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example290_PoroElasticity/#290-:-Poro-Elasticity","page":"Example290_PoroElasticity","title":"290 : Poro-Elasticity","text":"","category":"section"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"This example concerns the three-field solution (mathbfwmathbfup) of Biot's consolidation model in poroelasticity given by","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"beginaligned\n-(lambda + mu) nabla (mathrmdiv mathbfv) - mu Delta mathbfv + alpha nabla p  = f quad textin  Omega times 0T\npartial_t (c_o + α mathrmdiv(mathbfv)) + mathrmdiv(wmathbfw)  = g quad textin  Omega times 0T\nK^-1 mathbfw + nabla p  = 0 quad textin  Omega times 0T\nendaligned","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"and suitable boundary conditions and given initial state.","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"The discretisation involves an Hdiv-conforming reconstruction operator to avoid Poisson locking which results in a scheme similar to the one suggested in the reference below. As a test problem the first benchmark problem from the same reference is used.","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"reference: Reference\n\"A study of two modes of locking in poroelasticity\",\nS.-Y. Yi,\nSIAM J. Num. Anal. 55(4) (2017),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"module Example290_PoroElasticity\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing Symbolics\n\n\n# exact data for testcase 2 computed by Symbolics\nfunction prepare_data!(; μ = 1, λ = 1, K = 1, c0 = 1, α = 1)\n\n    @variables x y t\n\n    # displacement and pressure\n    u = [\n        exp(-t) * (sin(2 * pi * y) * (-1 + cos(2 * pi * x)) + sin(pi * x) * sin(pi * y) / (μ + λ))\n        exp(-t) * (sin(2 * pi * x) * (1 - cos(2 * pi * y)) + sin(pi * x) * sin(pi * y) / (μ + λ))\n    ]\n    p = exp(-t) * sin(pi * x) * sin(pi * y)\n\n    # gradient of displacement\n    ∇u = Symbolics.jacobian(u, [x, y])\n    ∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n    # gradient of pressure\n    ∇p = [Symbolics.gradient(p, [x])[1], Symbolics.gradient(p, [y])[1]]\n\n    # Laplacian\n    Δu = [\n        (Symbolics.gradient(∇u[1, 1], [x]) + Symbolics.gradient(∇u[1, 2], [y]))[1],\n        (Symbolics.gradient(∇u[2, 1], [x]) + Symbolics.gradient(∇u[2, 2], [y]))[1],\n    ]\n    Δp = Symbolics.gradient(∇p[1], [x]) + Symbolics.gradient(∇p[2], [y])\n    divu = ∇u[1, 1] + ∇u[2, 2]\n    ∇divu = [Symbolics.gradient(divu, [x])[1], Symbolics.gradient(divu, [y])[1]]\n    divu_dt = Symbolics.gradient(divu, [t])\n\n    f = -μ * Δu .+ α * ∇p .- (μ + λ) * ∇divu\n    g = c0 * Symbolics.gradient(p, [t]) - K * Δp + α * divu_dt\n\n    u_eval = build_function(u, x, y, t, expression = Val{false})\n    ∇u_eval = build_function(∇u_reshaped, x, y, t, expression = Val{false})\n    g_eval = build_function(g, x, y, t, expression = Val{false})\n    f_eval = build_function(f, x, y, t, expression = Val{false})\n    p_eval = build_function(p, x, y, t, expression = Val{false})\n    ∇p_eval = build_function(∇p, x, y, t, expression = Val{false})\n\n    return f_eval[2], g_eval[2], u_eval[2], ∇u_eval[2], p_eval, ∇p_eval[2]\nend\n\nfunction linear_kernel!(result, input, qpinfo)\n    ∇u, divu, p, w, divw = view(input, 1:4), view(input, 5), view(input, 6), view(input, 7:8), view(input, 9)\n    μ, λ, α, K = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3], qpinfo.params[4]\n    result[1] = μ * ∇u[1] + (λ + μ) * divu[1] - p[1]\n    result[2] = μ * ∇u[2]\n    result[3] = μ * ∇u[3]\n    result[4] = μ * ∇u[4] + (λ + μ) * divu[1] - p[1]\n    result[5] = divu[1]\n    result[6] = divw[1]\n    result[7] = w[1] / K\n    result[8] = w[2] / K\n    result[9] = -p[1]\n    return nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(u!, ∇u!, p!)\n    return function closure(result, u, qpinfo)\n        u!(view(result, 1:2), qpinfo)\n        ∇u!(view(result, 3:6), qpinfo)\n        p!(view(result, 7), qpinfo)\n        view(result, 1:7) .-= u\n        return result .= result .^ 2\n    end\nend\n\nfunction main(; α = 0.93, E = 1.0e5, ν = 0.4, K = 1.0e-7, nrefs = 6, T = 0.5, τ = 1.0e-2, c0 = 1, order = 1, reconstruct = true, Plotter = nothing, kwargs...)\n\n    # calculate Lame' parameter\n    μ = E / (2 * (1 + ν))\n    λ = E * ν / ((1 - 2 * ν) * (1 + ν))\n\n    # initial and exact state for u and p at time t0\n    f_eval, g_eval, u_eval, ∇u_eval, p_eval, ∇p_eval = prepare_data!(; μ = μ, λ = λ, K = K, c0 = c0, α = α)\n    f!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n    g!(result, qpinfo) = (g_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n    exact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n    exact_∇p!(result, qpinfo) = (∇p_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n    exact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n    exact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2], qpinfo.time))\n\n    # problem description\n    PD = ProblemDescription(\"Heat Equation\")\n    u = Unknown(\"u\"; name = \"displacement\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    w = Unknown(\"w\"; name = \"Darcy velocity\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, w)\n\n    # prepare reconstruction operator\n    if reconstruct\n        FES_Reconst = order == 1 ? HDIVBDM1{2} : HDIVBDM2{2}\n        divu = apply(u, Reconstruct{FES_Reconst, Divergence})\n        idu = apply(u, Reconstruct{FES_Reconst, Identity})\n    else\n        divu = div(u)\n        idu = id(u)\n    end\n\n    # linear operator\n    assign_operator!(PD, BilinearOperator(linear_kernel!, [grad(u), divu, id(p), id(w), div(w)]; params = [μ, λ, α, K], store = true, kwargs...))\n\n    # right-hand side data\n    assign_operator!(PD, LinearOperator(f!, [idu]; kwargs...))\n    assign_operator!(PD, LinearOperator(g!, [id(p)]; kwargs...))\n\n    # boundary conditions\n    assign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4))\n    assign_operator!(PD, InterpolateBoundaryData(p, exact_p!; regions = 1:4))\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D; scale = [4, 4], shift = [-0.5, -0.5]), nrefs)\n\n    # prepare solution vector\n    if order == 1\n        FES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid; broken = true), FESpace{HDIVRT0{2}}(xgrid)]\n    elseif order == 2\n        FES = [FESpace{H1P2B{2, 2}}(xgrid), FESpace{H1P1{1}}(xgrid; broken = true), FESpace{HDIVRT1{2}}(xgrid)]\n    end\n    sol = FEVector(FES; tags = PD.unknowns)\n\n    # initial data\n    interpolate!(sol[u], exact_u!; bonus_quadorder = 5, time = 0)\n    interpolate!(sol[p], exact_p!; bonus_quadorder = 5, time = 0)\n\n    # init plotter and plot initial data and grid\n    plt = GridVisualizer(; Plotter = Plotter, layout = (3, 2), clear = true, size = (800, 1200))\n    scalarplot!(plt[1, 1], id(u), sol; abs = true, title = \"u_h (t = 0)\")\n    scalarplot!(plt[2, 1], id(p), sol; title = \"p_h (t = 0)\")\n    gridplot!(plt[3, 1], xgrid; linewidth = 1)\n\n    # compute mass matrix\n    M = FEMatrix(FES)\n    assemble!(M, BilinearOperator([id(2)]; factor = c0))\n    assemble!(M, BilinearOperator([id(2)], [div(1)]; factor = -α))\n\n    # add backward Euler time derivative\n    assign_operator!(PD, BilinearOperator(M, [u, p, w]; factor = 1 / τ, kwargs...))\n    assign_operator!(PD, LinearOperator(M, [u, p, w], [u, p, w]; factor = 1 / τ, kwargs...))\n\n    # generate solver configuration\n    SC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, verbosity = -1, constant_matrix = true, kwargs...)\n\n    # iterate tspan\n    t = 0\n    for it in 1:Int(floor(T / τ))\n        t += τ\n        @info \"t = $t\"\n        ExtendableFEM.solve(PD, FES, SC; time = t)\n    end\n\n    # error calculation\n    ErrorIntegrator = ItemIntegrator(exact_error!(exact_u!, exact_∇u!, exact_p!), [id(u), grad(u), id(p)]; quadorder = 2 * (order + 1), kwargs...)\n    error = evaluate(ErrorIntegrator, sol; time = T)\n    L2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n    H1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n    L2errorP = sqrt(sum(view(error, 7, :)))\n    @info \"|| u - u_h || = $L2errorU\n\t|| ∇(u - u_h) || = $H1errorU\n\t|| p - p_h || = $L2errorP\"\n\n    # plot final state\n    scalarplot!(plt[1, 2], id(u), sol; abs = true, title = \"u_h (t = $T)\")\n    scalarplot!(plt[2, 2], id(p), sol; title = \"p_h (t = $T)\")\n    scalarplot!(plt[3, 2], id(w), sol; abs = true, title = \"|w_h| (t = $T)\")\n\n    return L2errorU, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"","category":"page"},{"location":"module_examples/Example290_PoroElasticity/","page":"Example290_PoroElasticity","title":"Example290_PoroElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/#207-:-Advection-Upwind-DG","page":"Example207_AdvectionUpwindDG","title":"207 : Advection Upwind-DG","text":"","category":"section"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"(source code)","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"This example computes the solution u of the two-dimensional advection equation","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"beginaligned\nmathrmdiv (beta u)  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"with some given (divergence-free) advection field beta and inhomogeneous Dirichlet boundary conditions at the inflow boundary (where beta cdot n  0 with n being the outer normal vector).","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"In the example below the field beta(xy) = (-y x) and the inflow data","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"   u(xy) =\nbegincases\n    1  textfor  x in 0r  y = 0\n    0  textfor  x in (r1  y = 0\n    0  textfor  x = 1  y in 01\nendcases","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"is employed. The expected solution is a piecewise constant function that assumes the value one in the circle of radius r and zero elsewhere.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"Moreover, the upwind discontinuous Galerkin method for arbitrary polynomial degree is used for the discretization of the problem, but the continuous Galerkin method can be switched on with dg = false for comparison. For piecewise constants the DG method satisfies the maximum principle.","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"The grid (which is heavily refined along the interface of the circle) and the computed solution looks like this:","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"(Image: )","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"module Example207_AdvectionUpwindDG\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Symbolics\nusing LinearAlgebra\nusing SimplexGridFactory\nusing Triangulate\n\n# wind = advection field β\nfunction β!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = - x[2]\n    result[2] = x[1]\n    return nothing\nend\n\n# exact solution\nfunction exact_u!(result, qpinfo)\n    x = qpinfo.x\n    r = qpinfo.params[1]\n    result[1] = sqrt(x[1]^2 + x[2]^2) <= r ? 1 : 0\n    return nothing\nend\n\n# integrand of the advection bilinearform\nfunction advection_kernel!(result, input, qpinfo)\n    β!(result, qpinfo)  # evaluate wind β\n    result .*= input[1] # multiply with u_h\n    return nothing\nend\n\nfunction outflow_kernel!(xgrid)\n    beta = zeros(Float64, 2)\n    return function closure(result, input, qpinfo)\n        face = qpinfo.item\n        β!(beta, qpinfo)\n        result[1] = dot(beta, qpinfo.normal) * input[1]\n        return nothing\n    end\nend\n\nfunction upwind_kernel!(xgrid)\n    beta = zeros(Float64, 2)\n    return function closure(result, input, qpinfo)\n        face = qpinfo.item\n        β!(beta, qpinfo)\n        result[1] = dot(beta, qpinfo.normal)\n        return if result[1] > 0 ## wind blows this -> other\n            result[1] *= input[1] # upwind value = this\n        else ## wind blows this <- other\n            result[1] *= input[2] # upwind value = other\n        end\n    end\nend\n\n# prepare error calculation\nfunction exact_error!(result, u, qpinfo)\n    exact_u!(result, qpinfo)\n    result[1] = (result[1] - u[1])^2\n    return nothing\nend\n\nfunction main(; nref = 4, order = 0, r = 0.5, dg = true, Plotter = nothing, kwargs...)\n\n    # grid\n    xgrid = make_grid(nref, r)\n\n    # problem description\n    PD = ProblemDescription(\"advection equation\")\n    u = Unknown(\"u\"; name = \"species\")\n    assign_unknown!(PD, u)\n\n    # advection operator\n    assign_operator!(PD, BilinearOperator(advection_kernel!, [grad(u)], [id(u)]; factor = -1, bonus_quadorder = 1, kwargs...))\n    if dg\n        assign_operator!(PD, BilinearOperatorDG(upwind_kernel!(xgrid), [jump(id(u))], [this(id(u)), other(id(u))]; entities = ON_IFACES, bonus_quadorder = 1, kwargs...))\n    end\n\n    # outflow boundary (regions [3,4]) and inflow boundary (regions [5,6])\n    assign_operator!(PD, BilinearOperator(outflow_kernel!(xgrid), [id(u)]; entities = ON_BFACES, regions = [3, 4]))\n    assign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = [5, 6], params = [r], kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 2], kwargs...))\n\n    # solve\n    FES = FESpace{order == 0 ? L2P0{1} : H1Pk{1, 2, order}}(xgrid; broken = dg)\n    sol = solve(PD, FES; kwargs...)\n\n    # calculate L2 error and min/max value\n    ErrorIntegrator = ItemIntegrator(exact_error!, [id(u)]; quadorder = 2 * order, params = [r], kwargs...)\n    L2error = sqrt(sum(view(evaluate(ErrorIntegrator, sol), 1, :)))\n    @info \"L2 error = $L2error\"\n    @info \"extrema = $(extrema(sol.entries))\"\n\n    # plot\n    plt = plot([grid(u), id(u)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(nref = 4, radius = 0.5)\n    builder = SimplexGridBuilder(Generator = Triangulate)\n\n    # define outer boundary nodes and regions\n    p1 = point!(builder, 0, 0)\n    p12 = point!(builder, radius, 0)\n    p2 = point!(builder, 1, 0)\n    p3 = point!(builder, 1, 1)\n    p4 = point!(builder, 0, 1)\n    p41 = point!(builder, 0, radius)\n\n    facetregion!(builder, 5)\n    facet!(builder, p1, p12)\n    facetregion!(builder, 1)\n    facet!(builder, p12, p2)\n    facetregion!(builder, 2)\n    facet!(builder, p2, p3)\n    facetregion!(builder, 3)\n    facet!(builder, p3, p4)\n    facetregion!(builder, 4)\n    facet!(builder, p4, p41)\n    facetregion!(builder, 6)\n    facet!(builder, p41, p1)\n\n    # add interior interface (quarter circle)\n    n = 4^(nref + 1)\n    points = [point!(builder, radius * sin(t), radius * cos(t)) for t in range(0, π / 2, length = n)]\n    facetregion!(builder, 7)\n    for i in 2:(n - 2)\n        facet!(builder, points[i], points[i + 1])\n    end\n    facet!(builder, p41, points[1])\n    facet!(builder, points[end], p12)\n\n    # generate\n    return simplexgrid(builder, maxvolume = 1)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"","category":"page"},{"location":"module_examples/Example207_AdvectionUpwindDG/","page":"Example207_AdvectionUpwindDG","title":"Example207_AdvectionUpwindDG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/#270-:-Natural-convection","page":"Example270_NaturalConvectionProblem","title":"270 : Natural convection","text":"","category":"section"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"Seek velocity mathbfu, pressure p and temperature theta such that","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\t- mu Delta u + (mathbfu cdot nabla) mathbfu + nabla p  = Ra  theta  g \n       - Delta theta + mathbfu cdot nabla theta  = 0\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"on a given domain Omega (here a triangle) and boundary conditions","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\tmathbfu  = 0  quad textalong  partial Omega\n \tT  = T_textbottom quad textalong  y = 0\n\tT  = 0 quad textalong  x = 0\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"The weak formulation seeks (mathbfuptheta) in V times Q times X subseteq H^1_0(Omega)^2 times L^2_0(Omega) times H^1_D(Omega) such that","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"beginaligned\n\t(mu nabla mathbfu nabla mathbfv) + ((mathbfu cdot nabla) mathbfu mathbfv) - (mathrmdiv mathbfv p)  = (mathbfv Ra g  theta)  quad textfor all  mathbfv in V\n(mathrmdiv mathbfu q)  = 0  quad textfor all  q in Q\n       (nabla theta nabla varphi) + (u cdot nabla theta varphi)  = 0\n  quad textfor all  varphi in X\nendaligned","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"To render the discrete method pressure-robust, a reconstruction operator is applied to all identity evaluations of mathbfu and mathbfv (when the switch reconstruct is set to true). Further explanations and discussion on this example can be found in the reference below.","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"reference: Reference\n\"On the divergence constraint in mixed finite element methods for incompressible flows\",\nV. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\nSIAM Review 59(3) (2017),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"module Example270_NaturalConvectionProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, ∇u, p, ∇T, T = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7), view(u_ops, 8:9), view(u_ops, 10)\n    Ra, μ, ϵ = qpinfo.params[1], qpinfo.params[2], qpinfo.params[3]\n    result[1] = dot(u, view(∇u, 1:2))\n    result[2] = dot(u, view(∇u, 3:4)) - Ra * T[1]\n    result[3] = μ * ∇u[1] - p[1]\n    result[4] = μ * ∇u[2]\n    result[5] = μ * ∇u[3]\n    result[6] = μ * ∇u[4] - p[1]\n    result[7] = -(∇u[1] + ∇u[4])\n    result[8] = ϵ * ∇T[1]\n    result[9] = ϵ * ∇T[2]\n    result[10] = dot(u, ∇T)\n    return nothing\nend\n\nfunction T_bottom!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 2 * (1 - cos(2 * π * x[1]))\n    return nothing\nend\n\nfunction main(;\n        nrefs = 5,\n        μ = 1.0,\n        ϵ = 1.0,\n        Ra_final = 1.0e6,\n        reconstruct = true,\n        Plotter = nothing,\n        kwargs...\n    )\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    T = Unknown(\"T\"; name = \"temperature\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, T)\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p), grad(T), id(T)]; kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:3))\n    assign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n    assign_operator!(PD, HomogeneousBoundaryData(T; regions = 3))\n    assign_operator!(PD, InterpolateBoundaryData(T, T_bottom!; regions = 1))\n\n    # grid\n    xgrid = uniform_refine(reference_domain(Triangle2D), nrefs)\n\n    # FESpaces\n    FES = Dict(\n        u => FESpace{H1BR{2}}(xgrid),\n        p => FESpace{L2P0{1}}(xgrid),\n        T => FESpace{H1P1{1}}(xgrid)\n    )\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 3), clear = true, size = (1200, 400))\n\n    # solve by Ra embedding\n    params = Array{Float64, 1}([min(Ra_final, 4000), μ, ϵ])\n    sol = nothing\n    SC = nothing\n    step = 0\n    while (true)\n        # solve (params are given to all operators)\n        sol, SC = ExtendableFEM.solve(PD, FES, SC; init = sol, return_config = true, target_residual = 1.0e-6, params = params, kwargs...)\n\n        # plot\n        scalarplot!(plt[1, 1], id(u), sol; levels = 0, colorbarticks = 7, abs = true)\n        vectorplot!(plt[1, 1], id(u), sol; clear = false, title = \"|u| + quiver (Ra = $(params[1]))\")\n        scalarplot!(plt[1, 2], id(T), sol; title = \"T (Ra = $(params[1]))\")\n        scalarplot!(plt[1, 3], id(p), sol; title = \"p (Ra = $(params[1]))\")\n\n        # stop if Ra_final is reached\n        if params[1] >= Ra_final\n            break\n        end\n\n        # increase Ra\n        params[1] = min(Ra_final, params[1] * 3)\n        step += 1\n        @info \"Step $step : solving for Ra=$(params[1])\"\n    end\n\n    # compute Nusselt number along bottom (= boundary region 1)\n    ∇T_faces = FaceInterpolator([jump(grad(T))]; order = 0, kwargs...)\n    NuIntegrator = ItemIntegrator((result, input, qpinfo) -> (result[1] = -input[2]), [id(1)]; entities = ON_FACES, regions = [1])\n    Nu = sum(evaluate(NuIntegrator, evaluate!(∇T_faces, sol)))\n    @info \"Nu = $Nu\"\n\n    return Nu, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"","category":"page"},{"location":"module_examples/Example270_NaturalConvectionProblem/","page":"Example270_NaturalConvectionProblem","title":"Example270_NaturalConvectionProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nonlinearoperator/#NonlinearOperator","page":"NonlinearOperator","title":"NonlinearOperator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"A nonlinear operator automatically assembles all necessary terms for the Newton method. Other linearisations of a nonlinear operator can be constructed with special constructors for BilinearOperator or LinearOperator.","category":"page"},{"location":"nonlinearoperator/#Constructor","page":"NonlinearOperator","title":"Constructor","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To describe a NonlinearOperator we have to specify a kernel function.  These functions are 'flat' in the sense that the input and output vector  contain the components of the test-function values and derivatives as specified by oa_test and oa_args respectively. The assembly of the local matrix will be done internally  by multiplying the subvectors of result with its test-function counterparts. For a more detailed explanation of this see the following","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/nonlinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"nonlinearoperator/#ExtendableFEM.NonlinearOperator","page":"NonlinearOperator","title":"ExtendableFEM.NonlinearOperator","text":"function NonlinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tjacobian = nothing,\n\tkwargs...)\n\nGenerates a nonlinear form for the specified kernel function, test function operators, and argument operators evaluations. Operator evaluations are tuples that pair an unknown identifier or integer with a FunctionOperator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, input, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nDuring assembly the Newton update is computed via local jacobians of the kernel which are calculated by automatic differentiation or by the user-provided jacobian function with interface\n\njacobian!(jac, input_args, params)\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nextra_inputsize: additional entries in input vector (e.g. for type-stable storage for intermediate results). Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''NonlinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nsparse_jacobians: use sparse jacobians. Default: true\nsparse_jacobians_pattern: user provided sparsity pattern for the sparse jacobians (in case automatic detection fails). Default: nothing\ntime_dependent: operator is time-dependent ?. Default: false\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"nonlinearoperator/#Example-NSE-convection-operator","page":"NonlinearOperator","title":"Example - NSE convection operator","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"For the Navier–Stokes equations, we need a kernel function for the nonlinear convection term","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n(vucdotnabla u) = (vnabla u^T u)\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"In 2D the input (as specified below) will contain the two components of u=(u_1u_2) and the four components of the gradient  nabla u = beginpmatrix u_11  u_12  u_21  u_22endpmatrix in order, i.e. (u_1u_2u_11u_12u_21u_22). As the convection term is tested with v,  the output vector o only has to contain what should be tested with each component of v, i.e.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\n    A_textlocal = (v_1v_2)^T(o_1o_2) = \n        beginpmatrix\n            v_1o_1  v_1o_2\n            v_2o_1  v_2o_2\n        endpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To construct the kernel there are two options,  component-wise and based on tensor_view. For the first we have to write the convection term as individual components","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginequation\no = \n    beginpmatrix\n        u_1cdot u_11+u_2cdot u_12\n        u_1cdot u_21+u_2cdot u_22\n    endpmatrix\n= \nbeginpmatrix\n    ucdot (u_11u_12)^T\n    ucdot (u_21u_22)^T\nendpmatrix\nendequation","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To make our lives a bit easier we will extract the subcompontents of  input as views, such that ∇u[3] actually accesses input[5], which corresponds to the third entry u_21 of nabla u. ","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input,3:6)\n    result[1] = dot(u, view(∇u,1:2))\n    result[2] = dot(u, view(∇u,3:4))\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To improve readability of the kernels and to make them easier to understand, we provide the function tensor_view which constructs a view and reshapes  it into an object matching the given TensorDescription. See the table  to see which tensor size is needed for which derivative of a scalar, vector  or matrix-valued variable.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"function kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(2))\n    v = tensor_view(result,1,TDVector(2))\n    ∇u = tensor_view(input,3,TDMatrix(2))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The coressponding NonlinearOperator constructor call is the same in both cases  and reads","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\nNonlinearOperator(kernel!, [id(u)], [id(u),grad(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"The second argument triggers that the evaluation of the Identity and Gradient operator of the current velocity iterate at each quadrature point go (in that order) into the input vector (of length 6) of the kernel, while the third argument triggers that the result vector of the kernel is multiplied with the Identity evaluation of the velocity test function.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"remark: Remark\nAlso note, that the same kernel could be used for a fully explicit linearisation of the convection term as a LinearOperator viau = Unknown(\"u\"; name = \"velocity\")\nLinearOperator(kernel!, [id(u)], [id(u),grad(u)])For a Picard iteration of the convection term, a BilinearOperator can be used with a slightly modified kernel that separates the operator evaluations of the ansatz function and the current solution, i.e.,function kernel_picard!(result, input_ansatz, input_args, qpinfo)\n    a, ∇u = view(input_args, 1:2), view(input_ansatz,1:4)\n    result[1] = dot(a, view(∇u,1:2))\n    result[2] = dot(a, view(∇u,3:4))\nend\nu = Unknown(\"u\"; name = \"velocity\")\nBilinearOperator(kernel_picard!, [id(u)], [grad(u)], [id(u)])","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Note\nKernels are allowed to depend on region numbers, space and time coordinates via the qpinfo argument.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"note: Dimension independent kernels\nIf done correctly, the operator-based approach allows us to write a kernel  that is 'independent' of the spatial dimension,  i.e. one instead of up to three kernels. Assuming dim is a known variable we can re-write the kernel from above asfunction kernel!(result, input, qpinfo)\n    u = tensor_view(input,1,TDVector(dim))\n    v = tensor_view(result,1,TDVector(dim))\n    ∇u = tensor_view(input,1+dim,TDMatrix(dim))\n    tmul!(v,∇u,u)\n    return nothing\nend","category":"page"},{"location":"nonlinearoperator/#Newton-by-local-jacobians-of-kernel","page":"NonlinearOperator","title":"Newton by local jacobians of kernel","text":"","category":"section"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To demonstrate the general approach consider a model problem with a nonlinear operator that has the weak formulation that seeks some function u(x) in X in some finite-dimensional space X with N = mathrmdim X, i.e., some coefficient vector x in mathbbR^N, such that","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) = int_Omega A(L_1u(x)(y)) cdot L_2v(y) textitdy  = 0 quad textfor all  v in X\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"for some given nonlinear kernel function A  mathbbR^m rightarrow mathbbR^n where m is the dimension of the input L_1 u(x)(y) in mathbbR^m and n is the dimension of the result L_2 v(y) in mathbbR^n. Here, L_1 and L_2 are linear operators, e.g. primitive differential operator evaluations of u or v.","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Let us consider the Newton scheme to find a root of the residual function F  mathbbR^N rightarrow mathbbR^N, which iterates","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nx_n+1 = x_n - D_xF(x_n)^-1 F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"or, equivalently, solves","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x_n) left(x_n+1 - x_nright) = -F(x_n)\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"To compute the jacobian of F, observe that its discretisation on a mesh mathcalT and some quadrature rule (x_qp w_qp) leads to","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp A(L_1u_h(x)(x_qp)) cdot L_2v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Now, by linearity of everything involved other than A, we can evaluate the jacobian by","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"beginaligned\nD_xF(x) =  sum_T in mathcalT lvert T rvert sum_x_qp DA(L_1 u_h(x)(x_qp)) cdot L_2 v_h(x_qp) w_qp  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"nonlinearoperator/","page":"NonlinearOperator","title":"NonlinearOperator","text":"Hence, assembly only requires to evaluate the low-dimensional jacobians DA in mathbbR^m times n of A at L_1 u_h(x)(x_qp). These jacobians are computed by automatic differentiation via ForwardDiff.jl (or via the user-given jacobian function). If m and n are a little larger, e.g. when more operator evaluations L_1 and L_2 or more unknowns are involved, there is the option to use sparse_jacobians (using the sparsity detection of Symbolics.jl).","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/#252-:-Navier–Stokes-Planar-Lattice-Flow","page":"Example252_NSEPlanarLatticeFlow","title":"252 : Navier–Stokes Planar Lattice Flow","text":"","category":"section"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"(source code)","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"This example computes an approximation to the planar lattice flow test problem of the Navier-Stokes equations","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"beginaligned\n- nu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"with an exterior force mathbff and some viscosity parameter nu and Dirichlet boundary data for mathbfu.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"Here the exact data for the planar lattice flow","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"beginaligned\nmathbfu(xyt)  = exp(-8 pi^2 nu t) beginpmatrix sin(2 pi x) sin(2 pi y)  cos(2 pi x) cos(2 pi y) endpmatrix\np(xyt)  = exp(-8 pi^2 nu t) ( cos(4 pi x) - cos(4 pi y))  4\nendaligned","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"is prescribed at fixed time t = 0 with mathbff = - nu Delta mathbfu.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"In this example the Navier-Stokes equations are solved with a pressure-robust variant of the Bernardi–Raugel finite element method and the nonlinear convection term (that involves reconstruction operators) is automatically differentiated for a Newton iteration.","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"(Image: )","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"module Example252_NSEPlanarLatticeFlow\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact velocity (and Dirichlet data)\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n    result[2] = cos(2 * pi * x[1]) * cos(2 * pi * x[2])\n    return nothing\nend\n\n# right-hand side f := -μ Δu + (u⋅∇)u + ∇p\nfunction f!(μ)\n    α = [0, 0]\n    return function closure(result, qpinfo)\n        x = qpinfo.x\n        result[1] = (μ * 8 * pi^2 + α[1]) * sin(2 * pi * x[1]) * sin(2 * pi * x[2])\n        result[2] = (μ * 8 * pi^2 + α[2]) * cos(2 * pi * x[1]) * cos(2 * pi * x[2])\n        return nothing\n    end\nend\n\n# exact pressure\nfunction p!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = (cos(4 * pi * x[1]) - cos(4 * pi * x[2])) / 4\n    return nothing\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n    μ = qpinfo.params[1]\n    result[1] = dot(u, view(∇u, 1:2))\n    result[2] = dot(u, view(∇u, 3:4))\n    result[3] = μ * ∇u[1] - p[1]\n    result[4] = μ * ∇u[2]\n    result[5] = μ * ∇u[3]\n    result[6] = μ * ∇u[4] - p[1]\n    result[7] = -(∇u[1] + ∇u[4])\n    return nothing\nend\n\nfunction exact_error!(result, u, qpinfo)\n    u!(result, qpinfo)\n    p!(view(result, 3), qpinfo)\n    result .-= u\n    return result .= result .^ 2\nend\n\nfunction main(; μ = 0.001, nrefs = 5, reconstruct = true, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id_u, grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, LinearOperator(f!(μ), [id_u]; kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 1:4))\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n    # prepare FESpace\n    FES = [FESpace{H1BR{2}}(xgrid), FESpace{L2P0{1}}(xgrid)]\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # move integral mean of pressure\n    pintegrate = ItemIntegrator([id(p)])\n    pmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n    view(sol[p]) .-= pmean\n\n    # error calculation\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), id(p)]; quadorder = 4, params = [μ], kwargs...)\n    error = evaluate(ErrorIntegratorExact, sol)\n    L2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n    L2errorP = sqrt(sum(view(error, 3, :)))\n    @info \"L2error(u) = $L2errorU\"\n    @info \"L2error(p) = $L2errorP\"\n\n    # plot\n    plt = plot([id(u), id(p)], sol; Plotter = Plotter)\n\n    return L2errorU, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"","category":"page"},{"location":"module_examples/Example252_NSEPlanarLatticeFlow/","page":"Example252_NSEPlanarLatticeFlow","title":"Example252_NSEPlanarLatticeFlow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/#312-:-Periodic-Boundary-3D","page":"Example312_PeriodicBoundary3D","title":"312 : Periodic Boundary 3D","text":"","category":"section"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"(source code)","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"This is a simple demonstration and validation of the generic periodic boundary operator.","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"We construct an unstructured periodic 3D grid and solve a simple linear elastic problem with periodic coupling along the x-axis.","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"(Image: )","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"module Example312_PeriodicBoundary3D\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing GridVisualize\nusing TetGen\nusing UnicodePlots\nusing StaticArrays\nusing LinearAlgebra\n\nconst reg_left = 1\nconst reg_right = 2\nconst reg_dirichlet = 3\nconst reg_default = 4","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"define the Hooke tensor for AlN (from DOI 10.1063/1.1368156)","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"function material_tensor()\n    c11 = 396.0\n    c12 = 137.0\n    c13 = 108.0\n    c33 = 373.0\n    c44 = 116.0\n\n    return @SArray [\n        c11 c12 c13 0   0   0\n        c12 c11 c13 0   0   0\n        c13 c13 c33 0   0   0\n        0   0   0   c44 0   0\n        0   0   0   0   c44 0\n        0   0   0   0   0   c44\n    ]\nend\n\n# generate the kernels for the linear problem\n# 𝐂: Hooke tensor, 𝑓: body force\nfunction make_kernels(𝐂, 𝑓)\n\n    # linear stress-strain mapping\n    bilinear_kernel!(σ, εv, qpinfo) = mul!(σ, 𝐂, εv)\n\n    # body force\n    linear_kernel!(result, qpinfo) = (result .= 𝑓)\n\n    return bilinear_kernel!, linear_kernel!\nend\n\n\n\"\"\"\n    create 3D grid with Dirichlet boundary region at the bottom center\n\"\"\"\nfunction create_grid(; h, height, width, depth)\n    builder = SimplexGridBuilder(; Generator = TetGen)\n\n    # bottom points\n    b01 = point!(builder, 0, 0, 0)\n    b02 = point!(builder, 0.45 * width, 0, 0)\n    b03 = point!(builder, 0.55 * width, 0, 0)\n    b04 = point!(builder, width, 0, 0)\n\n    b11 = point!(builder, 0, depth, 0)\n    b12 = point!(builder, 0.45 * width, depth, 0)\n    b13 = point!(builder, 0.55 * width, depth, 0)\n    b14 = point!(builder, width, depth, 0)\n\n    # top points\n    t01 = point!(builder, 0, 0, height)\n    t02 = point!(builder, width, 0, height)\n\n    t11 = point!(builder, 0, depth, height)\n    t12 = point!(builder, width, depth, height)\n\n    # center points\n    c01 = point!(builder, 0.5 * width, 0, 0)\n    c02 = point!(builder, 0.5 * width, 0, height)\n    c11 = point!(builder, 0.5 * width, depth, 0)\n    c12 = point!(builder, 0.5 * width, depth, height)\n\n    # default faces\n    facetregion!(builder, reg_default)\n    facet!(builder, b01, b02, b12, b11)\n    facet!(builder, b03, b04, b14, b13)\n    facet!(builder, [t01, c02, c12, t11])\n    facet!(builder, [c02, t02, t12, c12])\n    facet!(builder, [b01, b02, c01, c02, t01])\n    facet!(builder, [c01, b03, b04, t02, c02])\n    facet!(builder, [b11, b12, c11, c12, t11])\n    facet!(builder, [c11, b13, b14, t12, c12])\n    facet!(builder, c01, c02, c12, c11)\n\n    # left face\n    facetregion!(builder, reg_left)\n    facet!(builder, b01, t01, t11, b11)\n\n    # right face\n    facetregion!(builder, reg_right)\n    facet!(builder, b04, t02, t12, b14)\n\n    # Dirichlet face\n    facetregion!(builder, reg_dirichlet)\n    facet!(builder, [b02, c01, c11, b12])\n    facet!(builder, [c01, b03, b13, c11])\n\n    cellregion!(builder, 1)\n    maxvolume!(builder, h)\n    regionpoint!(builder, width / 3, depth / 2, height / 2)\n    cellregion!(builder, 2)\n    # finer grid on the right half to make the periodic coupling non-trivial\n    maxvolume!(builder, 0.3 * h)\n    regionpoint!(builder, 2 * width / 3, depth / 2, height / 2)\n\n    return simplexgrid(builder)\nend\n\nfunction main(;\n        order = 1,\n        periodic = true,\n        Plotter = nothing,\n        force = 1.0,\n        h = 1.0e-4,\n        width = 6.0,\n        height = 0.2,\n        depth = 1,\n        kwargs...\n    )\n\n    xgrid = create_grid(; h, width, height, depth)\n\n    # create finite element space and solution vector\n    if order == 1\n        FES = FESpace{H1P1{3}}(xgrid)\n    elseif order == 2\n        FES = FESpace{H1P2{3, 3}}(xgrid)\n    end\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"displacement\")\n    assign_unknown!(PD, u)\n\n    𝐂 = material_tensor()\n    𝑓 = force * [0, 0, 1]\n\n    bilinear_kernel!, linear_kernel! = make_kernels(𝐂, 𝑓)\n    assign_operator!(PD, BilinearOperator(bilinear_kernel!, [εV(u, 1.0)]; kwargs...))\n    assign_operator!(PD, LinearOperator(linear_kernel!, [id(u)]; kwargs...))\n\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [reg_dirichlet]))\n\n    if periodic\n        function give_opposite!(y, x)\n            y .= x\n            y[1] = width - x[1]\n            return nothing\n        end\n        coupling_matrix = get_periodic_coupling_matrix(FES, xgrid, reg_left, reg_right, give_opposite!)\n        display(coupling_matrix)\n        assign_operator!(PD, CombineDofs(u, u, coupling_matrix; kwargs...))\n    end\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    displace_mesh!(xgrid, sol[u])\n    plt = plot([grid(u)], sol; Plotter, do_vector_plots = false, width = 1200, height = 800, title = \"displaced mesh\", scene3d = :LScene)\n\n    return sol, plt\n\nend\n\n\nend # module","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"","category":"page"},{"location":"module_examples/Example312_PeriodicBoundary3D/","page":"Example312_PeriodicBoundary3D","title":"Example312_PeriodicBoundary3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/#203-:-Poisson-Problem-DG","page":"Example203_PoissonProblemDG","title":"203 : Poisson-Problem DG","text":"","category":"section"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"(source code)","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"with right-hand side f and inhomogeneous Dirichlet boundary conditions chosen such that u(xy) = x^3 - 3xy^2. This time the problem is solved on a given grid via the discontinuous Galerkin method.","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"The computed solution looks like this:","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"(Image: )","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"module Example203_PoissonProblemDG\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\nusing Metis\nusing Symbolics\n\n# exact data for problem by Symbolics\nfunction prepare_data(; μ = 1)\n\n    @variables x y\n\n    # exact solution\n    u = x^3 - 3 * x * y^2\n    ∇u = Symbolics.gradient(u, [x, y])\n\n    # right-hand side\n    Δu = Symbolics.gradient(∇u[1], [x]) + Symbolics.gradient(∇u[2], [y])\n    f = -μ * Δu[1]\n\n    # build functions\n    u_eval = build_function(u, x, y, expression = Val{false})\n    ∇u_eval = build_function(∇u, x, y, expression = Val{false})\n    f_eval = build_function(f, x, y, expression = Val{false})\n    return f_eval, u_eval, ∇u_eval[2]\nend\n\nfunction main(; dg = true, μ = 1.0, τ = 10.0, nrefs = 4, order = 2, bonus_quadorder = 2, parallel = false, npart = parallel ? 8 : 1, Plotter = nothing, kwargs...)\n\n    # prepare problem data\n    f_eval, u_eval, ∇u_eval = prepare_data(; μ = μ)\n    rhs!(result, qpinfo) = (result[1] = f_eval(qpinfo.x[1], qpinfo.x[2]))\n    exact_u!(result, qpinfo) = (result[1] = u_eval(qpinfo.x[1], qpinfo.x[2]))\n    exact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\n    # problem description\n    PD = ProblemDescription(\"Poisson problem\")\n    u = Unknown(\"u\"; name = \"potential\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, parallel = parallel, kwargs...))\n    assign_operator!(PD, LinearOperator(rhs!, [id(u)]; bonus_quadorder = bonus_quadorder, parallel = parallel, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, exact_u!; bonus_quadorder = bonus_quadorder, regions = 1:4))\n\n    # discretize\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    if npart > 1\n        xgrid = partition(xgrid, PlainMetisPartitioning(npart = npart); edges = true)\n    end\n    FES = FESpace{order == 0 ? L2P0{1} : H1Pk{1, 2, order}}(xgrid; broken = dg)\n\n    # add DG terms\n    assign_operator!(PD, BilinearOperatorDG(dg_kernel, [jump(id(u))], [average(grad(u))]; entities = ON_FACES, factor = -μ, transposed_copy = 1, parallel = parallel, kwargs...))\n    assign_operator!(PD, LinearOperatorDG(dg_kernel_bnd(exact_u!), [average(grad(u))]; entities = ON_BFACES, factor = -μ, bonus_quadorder = bonus_quadorder, parallel = parallel, kwargs...))\n    assign_operator!(PD, BilinearOperatorDG(dg_kernel2, [jump(id(u))]; entities = ON_FACES, factor = μ * τ, parallel = parallel, kwargs...))\n    assign_operator!(PD, LinearOperatorDG(dg_kernel2_bnd(exact_u!), [id(u)]; entities = ON_BFACES, regions = 1:4, factor = μ * τ, bonus_quadorder = bonus_quadorder, parallel = parallel, kwargs...))\n\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # prepare error calculation\n    function exact_error!(result, u, qpinfo)\n        exact_u!(result, qpinfo)\n        exact_∇u!(view(result, 2:3), qpinfo)\n        result .-= u\n        result .= result .^ 2\n        return nothing\n    end\n    function dgjumps!(result, u, qpinfo)\n        result .= u[1]^2 / qpinfo.volume\n        return nothing\n    end\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * (order + 1), params = [μ], kwargs...)\n    DGJumpsIntegrator = ItemIntegratorDG(dgjumps!, [jump(id(u))]; entities = ON_IFACES, kwargs...)\n\n    # calculate error\n    error = evaluate(ErrorIntegratorExact, sol)\n    dgjumps = sqrt(sum(evaluate(DGJumpsIntegrator, sol)))\n    L2error = sqrt(sum(view(error, 1, :)))\n    H1error = sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :)))\n    @info \"L2 error = $L2error\"\n    @info \"H1 error = $H1error\"\n    @info \"dgjumps = $dgjumps\"\n\n    # plot\n    plt = plot([id(u), grad(u)], sol; Plotter = Plotter)\n\n    return L2error, plt\nend\n\nfunction dg_kernel(result, input, qpinfo)\n    result[1] = dot(input, qpinfo.normal)\n    return nothing\nend\nfunction dg_kernel_bnd(uDb! = nothing)\n    return function closure(result, qpinfo)\n        uDb!(result, qpinfo)\n        result[1:2] = result[1] .* qpinfo.normal\n        return nothing\n    end\nend\nfunction dg_kernel2(result, input, qpinfo)\n    result .= input / qpinfo.volume\n    return nothing\nend\nfunction dg_kernel2_bnd(uDb! = nothing)\n    return function closure(result, qpinfo)\n        uDb!(result, qpinfo)\n        result /= qpinfo.volume\n        return nothing\n    end\nend\n\nend # module","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"","category":"page"},{"location":"module_examples/Example203_PoissonProblemDG/","page":"Example203_PoissonProblemDG","title":"Example203_PoissonProblemDG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/#202-:-Poisson-Problem-(Mixed)","page":"Example202_MixedPoissonProblem","title":"202 : Poisson-Problem (Mixed)","text":"","category":"section"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"This example computes the solution u and its stress mathbfsigma = - mu nabla u of the two-dimensional Poisson problem in the mixed form","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"beginaligned\nmathbfsigma + mu nabla u = 0\nmathrmdiv mathbfsigma  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"The computed solution looks like this:","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"module Example202_MixedPoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# define unknowns\nσ = Unknown(\"σ\"; name = \"pseudostress\")\nu = Unknown(\"u\"; name = \"potential\")\n\n# bilinearform kernel for mixed Poisson problem\nfunction blf!(result, u_ops, qpinfo)\n    σ, divσ, u = view(u_ops, 1:2), view(u_ops, 3), view(u_ops, 4)\n    μ = qpinfo.params[1]\n    result[1] = σ[1] / μ\n    result[2] = σ[2] / μ\n    result[3] = -u[1]\n    result[4] = divσ[1]\n    return nothing\nend\n# right-hand side data\nfunction f!(fval, qpinfo)\n    fval[1] = qpinfo.x[1] * qpinfo.x[2]\n    return nothing\nend\n# boundary data\nfunction boundarydata!(result, qpinfo)\n    result[1] = 0\n    return nothing\nend\n\nfunction main(; nrefs = 5, μ = 0.25, order = 0, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, σ)\n    assign_operator!(PD, BilinearOperator(blf!, [id(σ), div(σ), id(u)]; params = [μ], kwargs...))\n    assign_operator!(PD, LinearOperator(boundarydata!, [normalflux(σ)]; entities = ON_BFACES, regions = 1:4, kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]; kwargs...))\n    assign_operator!(PD, FixDofs(u; dofs = [1], vals = [0]))\n\n    # discretize\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    FES = Dict(\n        u => FESpace{order == 0 ? L2P0{1} : H1Pk{1, 2, order}}(xgrid; broken = true),\n        σ => FESpace{HDIVRTk{2, order}}(xgrid)\n    )\n\n    # solve\n    sol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n    # plot\n    plt = plot([id(u), id(σ)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"","category":"page"},{"location":"module_examples/Example202_MixedPoissonProblem/","page":"Example202_MixedPoissonProblem","title":"Example202_MixedPoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#ExtendableFEM.jl","page":"Home","title":"ExtendableFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers a toolkit to easily setup (mostly low-order, standard and non-standard) finite element methods for multiphysics problems in Julia and to run fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl (for meshing and administration) and ExtendableFEMBase.jl (for quadrature and FEM basis functions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nExtendableSparse.jl\nExtendableFEMBase.jl\nGridVisualize.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\n","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"#1.-Geometry-description-/-meshing","page":"Home","title":"1. Geometry description / meshing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The geometry description and meshing is not really separated. For meshes of rectangular domains, there are simple constructors available in ExtendableGrids.jl, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ExtendableGrids\n## unit square criss-cross into Triangles\nxgrid1 = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n## uniform rectangular grid\nxgrid2 = simplexgrid(0:0.1:1, 0:0.2:2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that these grids generate boundary regions from 1 to 4 (bottom, left, top, right) that can be used to assign boundary conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More complex grids can be created via the mesh generators in SimplexGridFactory.jl, see e.g. Examples 245 or 265, or by loading a Gmsh grid file via the corresponding ExtendableGrids.jl extension.","category":"page"},{"location":"#2.-Problem-description","page":"Home","title":"2. Problem description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Before discretizing the user has the option to pose his problems in form of a Problem Description. Note, that usually no grid has to be defined at this point, but region numbers correspond to regions defined in the grid. Here is a short example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# a simple Poisson problem with right-hand side f(x,y) = x*y and u = 0 along boundary\nPD = ProblemDescription()\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\nf! = (result, qpinfo) -> (result[1] = qpinfo.x[1] * qpinfo.x[2])\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))","category":"page"},{"location":"#3.-Discretization","page":"Home","title":"3. Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this step, the user chooses suitable finite element types for the unknowns of the problem, and generates finite element spaces on the grid (and probably already a solution vector to preoccupy it with an initial solution).","category":"page"},{"location":"","page":"Home","title":"Home","text":"# cubic H1 element in 2D with one component\nFES = FESpace{H1Pk{1,2,3}}(xgrid) \n# alternatively: create solution vector and tag blocks with problem unknowns\nsol = FEVector(FES; tags = PD.unknowns) \n# fill block corresponding to unknown u with initial values\nfill(sol[u], 1)\n# interpolate some given function u!(result, qpinfo)\ninterpolate!(sol[u], u!)","category":"page"},{"location":"#4.-Solve","page":"Home","title":"4. Solve","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here, we solve the problem. If the problem is nonlinear, several additional arguments allow to steer the fixed-point iteration, see Stationary Solvers. In the simplest case, the user only needs to call:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# solve problem with finite element space(s)\n# (in case of more than one unknown, provide a vector of FESpaces)\nsol = solve(PD, FES; init = sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For time-dependent problem, the user can add the necessary operators for the time derivative manually. Alternatively, the problem description in space can be turned into an ODE and solve via DifferentialEquations.jl, see Time-dependent Solvers for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that the use can bypass the problem description and control the algebraic level manually via assembling the operators directly into an FEMatrix, see e.g. Example310. It is also possible to take control over the low-level assembly of the operators, see ExtendableFEMBase.jl for details.","category":"page"},{"location":"#5.-Plot-and-postprocess","page":"Home","title":"5. Plot and postprocess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After solving, the user can postprocess the solution, calculate quantities of interest or plot components.","category":"page"},{"location":"#Gradient-robustness","page":"Home","title":"Gradient-robustness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers some ingredients to build gradient-robust schemes via reconstruction operators or divergence-free elements. Gradient-robustness is a feature of discretisations that exactly balances gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to construct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfunctions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/#282-:-Incompressible-MHD","page":"Example282_IncompressibleMHD","title":"282 : Incompressible MHD","text":"","category":"section"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"(source code)","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"This example yields a prototype for the stationary incompressible viscous MHD equations that seek a velocity field mathbfu, a pressure field p and a divergence-free magnetic field mathbfB such that","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"beginaligned\n- mu Delta mathbfu + nabla cdot (mathbfu otimes mathbfu - mathbfB otimes mathbfB) + nabla (p + frac12 mathbfB cdot mathbfB)\n = 0\nmathrmdiv(mathbfu)  = 0\n- eta Delta mathbfB + nabla cdot (mathbfu otimes mathbfB - mathbfB otimes mathbfu)  = 0\nmathrmdiv(mathbfB)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"on a rectangular 2D domain. Here, mu and eta are the viscosity and resistivity of the fluid and the magnetic field, respectively.","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"(Image: )","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"module Example282_IncompressibleMHD\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing LinearAlgebra\n\nfunction f!(result, qpinfo)\n    return result .= 0\nend\n\nfunction g!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = sin(2 * pi * x[2]) * cos(pi * x[1])\n    result[2] = 0\n    return nothing\nend\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, B, ∇u, ∇B, p, q = view(u_ops, 1:2), view(u_ops, 3:4), view(u_ops, 5:8), view(u_ops, 9:12), view(u_ops, 13), view(u_ops, 14)\n    μ = qpinfo.params[1]\n    η = qpinfo.params[2]\n\n    # viscous terms and pressures\n    result[5] = μ * ∇u[1] - p[1]\n    result[6] = μ * ∇u[2]\n    result[7] = μ * ∇u[3]\n    result[8] = μ * ∇u[4] - p[1]\n    result[9] = η * ∇B[1] - q[1]\n    result[10] = η * ∇B[2]\n    result[11] = η * ∇B[3]\n    result[12] = η * ∇B[4] - q[1]\n\n    # Lorentz force\n    result[1] = - dot(B, view(∇B, 1:2))\n    result[2] = - dot(B, view(∇B, 3:4))\n    BdotB = (B[1] * B[1] + B[2] * B[2]) / 2\n    result[5] -= BdotB\n    result[8] -= BdotB\n\n    # convection term for u and B\n    result[1] += dot(u, view(∇u, 1:2))\n    result[2] += dot(u, view(∇u, 3:4))\n    result[3] = dot(u, view(∇B, 1:2)) - dot(B, view(∇u, 1:2))\n    result[4] = dot(u, view(∇B, 3:4)) - dot(B, view(∇u, 3:4))\n\n    # divergence constraint\n    result[13] = -(∇u[1] + ∇u[4])\n    result[14] = -(∇B[1] + ∇B[4])\n    return nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1.0e-3, η = 1.0e-1, nrefs = 5, kwargs...)\n\n    # load grid (see function below)\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    B = Unknown(\"B\"; name = \"magnetic field\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    q = Unknown(\"q\"; name = \"magnetic pressure\")\n\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, B)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, q)\n\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id(u), id(B), grad(u), grad(B), id(p), id(q)]; bonus_quadorder = 2, params = [μ, η], kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]))\n    assign_operator!(PD, LinearOperator(g!, [id(B)]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n    assign_operator!(PD, HomogeneousBoundaryData(B; regions = [1]))\n    assign_operator!(PD, FixDofs(p; dofs = [1]))\n    assign_operator!(PD, FixDofs(q; dofs = [1]))\n\n    # P2-bubble finite element method\n    FETypes = [H1P2{2, 2}, H1P2{2, 2}, H1P1{1}, H1P1{1}]\n\n    # generate FESpaces and Solution vector\n    FES = [FESpace{FETypes[j]}(xgrid) for j in 1:4]\n\n    # solve\n    sol = ExtendableFEM.solve(PD, FES; target_residual = 1.0e-8, time = 0, kwargs...)\n\n    # plot\n    plt = plot([id(u), id(B), id(p), id(q)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"","category":"page"},{"location":"module_examples/Example282_IncompressibleMHD/","page":"Example282_IncompressibleMHD","title":"Example282_IncompressibleMHD","text":"This page was generated using Literate.jl.","category":"page"},{"location":"homogeneousdata/#HomogeneousData","page":"HomogeneousData","title":"HomogeneousData","text":"","category":"section"},{"location":"homogeneousdata/","page":"HomogeneousData","title":"HomogeneousData","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/homogeneousdata_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousData","text":"function HomogeneousData(u; entities = ON_CELLS, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the specifies entities and entity regions (via kwargs).\n\nKeyword arguments:\n\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nregions: subset of regions where operator should be assembly only. Default: Any[]\nvalue: constant value of the data. Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"homogeneousdata/#ExtendableFEM.HomogeneousBoundaryData-Tuple{Any}","page":"HomogeneousData","title":"ExtendableFEM.HomogeneousBoundaryData","text":"function HomogeneousBoundaryData(u; entities = ON_BFACES, kwargs...)\n\nWhen assembled, the unknown u of the Problem will be penalized to zero on the boundary faces and boundary regions (via kwargs).\n\nKeyword arguments:\n\nmask: array of zeros/ones to set which components should be set by the operator (only works with componentwise dofs, add a 1 or 0 to mask additional dofs). Default: Any[]\nname: name for operator used in printouts. Default: ''HomogeneousData''\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nregions: subset of regions where operator should be assembly only. Default: Any[]\nvalue: constant value of the data. Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"package_index/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder   = [:function, :type]","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/#240-:-Stokes-RT-enrichment","page":"Example240_SVRTEnrichment","title":"240 : Stokes RT enrichment","text":"","category":"section"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"(source code)","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"with exterior force mathbff and some parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"The problem will be solved by a (P_k oplus RTenrichment) times P_k-1 scheme, which can be seen as an inf-sup stabilized Scott-Vogelius variant that works with general meshes, see references below. Therein, the velocity space employs continuous P_k functions plus certain (only H(div)-conforming) Raviart-Thomas functions and a discontinuous P_k-1 pressure space leading to an exactly divergence-free discrete velocity. In a reduction step (that can be triggered with the reduce switch) all higher order pressure dofs and the enrichment dofs can be eliminated from the system.","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"reference: Reference\n\"A low-order divergence-free H(div)-conforming finite element method for Stokes flows\",\nX. Li, H. Rui,\nIMA Journal of Numerical Analysis (2021),\n>Journal-Link< >Preprint-Link<\"Inf-sup stabilized Scott–Vogelius pairs on general simplicial grids by Raviart–Thomas enrichment\",\nV. John, X. Li, C. Merdon, H. Rui,\n>Preprint-Link<","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"(Image: )","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"module Example240_SVRTEnrichment\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing ExtendableSparse\nusing Triangulate\nusing SimplexGridFactory\nusing Symbolics\n\n# exact data for problem generated by Symbolics\nfunction prepare_data(; μ = 1)\n\n    @variables x y\n\n    # stream function ξ\n    ξ = -sin(2 * pi * x) * cos(2 * pi * y)\n\n    # velocity u = curl ξ\n    ∇ξ = Symbolics.gradient(ξ, [x, y])\n    u = [-∇ξ[2], ∇ξ[1]]\n\n    # pressure\n    p = (cos(4 * pi * x) - cos(4 * pi * y)) / 4\n\n    # gradient of velocity\n    ∇u = Symbolics.jacobian(u, [x, y])\n    ∇u_reshaped = [∇u[1, 1], ∇u[1, 2], ∇u[2, 1], ∇u[2, 2]]\n\n    # Laplacian\n    Δu = [\n        (Symbolics.gradient(∇u[1, 1], [x]) + Symbolics.gradient(∇u[1, 2], [y]))[1],\n        (Symbolics.gradient(∇u[2, 1], [x]) + Symbolics.gradient(∇u[2, 2], [y]))[1],\n    ]\n\n    # right-hand side\n    f = -μ * Δu + Symbolics.gradient(p, [x, y])\n\n    # build functions\n    p_eval = build_function(p, x, y, expression = Val{false})\n    u_eval = build_function(u, x, y, expression = Val{false})\n    ∇u_eval = build_function(∇u_reshaped, x, y, expression = Val{false})\n    f_eval = build_function(f, x, y, expression = Val{false})\n\n    return f_eval[2], u_eval[2], ∇u_eval[2], p_eval\nend\n\n# grid generator function\nfunction get_grid2D(nref; uniform = false, barycentric = false)\n    if uniform || barycentric\n        gen_ref = 0\n    else\n        gen_ref = nref\n    end\n    grid = simplexgrid(\n        Triangulate;\n        points = [0 0; 0 1; 1 1; 1 0]',\n        bfaces = [1 2; 2 3; 3 4; 4 1]',\n        bfaceregions = [1, 2, 3, 4],\n        regionpoints = [0.5 0.5;]',\n        regionnumbers = [1],\n        regionvolumes = [4.0^(-gen_ref - 1)]\n    )\n    if uniform\n        grid = uniform_refine(grid, nref)\n    end\n    if barycentric\n        grid = barycentric_refine(grid)\n    end\n    return grid\nend\n\n# kernel for Stokes operator\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops, 1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ * ∇u[1] - p[1]\n    result[2] = μ * ∇u[2]\n    result[3] = μ * ∇u[3]\n    result[4] = μ * ∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend\n\nfunction main(; nrefs = 5, μ = 1, α = 1, order = 2, Plotter = nothing, enrich = true, reduce = true, time = 0.5, bonus_quadorder = 5, kwargs...)\n\n    # prepare problem data\n    f_eval, u_eval, ∇u_eval, p_eval = prepare_data(; μ = μ)\n    rhs!(result, qpinfo) = (f_eval(result, qpinfo.x[1], qpinfo.x[2]))\n    exact_p!(result, qpinfo) = (result[1] = p_eval(qpinfo.x[1], qpinfo.x[2]))\n    exact_u!(result, qpinfo) = (u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n    exact_∇u!(result, qpinfo) = (∇u_eval(result, qpinfo.x[1], qpinfo.x[2]))\n\n    # prepare unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    pfull = Unknown(\"p\"; name = \"pressure (full)\", dim = 1)\n    pE = Unknown(\"p⟂\"; name = \"pressure (enriched)\", dim = 1)\n    p0 = Unknown(\"p0\"; name = \"pressure (reduced)\", dim = 1) # only used if enrich && reduced\n    uR = Unknown(\"uR\"; name = \"velocity enrichment\", dim = 2) # only used if enrich == true\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n\n    # prepare error calculations\n    function exact_error!(result, u, qpinfo)\n        exact_u!(view(result, 1:2), qpinfo)\n        exact_∇u!(view(result, 3:6), qpinfo)\n        result .-= u\n        return result .= result .^ 2\n    end\n    function exact_error_p!(result, p, qpinfo)\n        exact_p!(view(result, 1), qpinfo)\n        result .-= p\n        return result .= result .^ 2\n    end\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [id(u), grad(u)]; quadorder = 2 * (order + 1), kwargs...)\n    ErrorIntegratorPressure = ItemIntegrator(exact_error_p!, [order == 1 ? id(p0) : id(pfull)]; quadorder = 2 * (order + 1), kwargs...)\n    L2NormIntegratorE = L2NormIntegrator([id(uR)]; quadorder = 2 * order)\n    function kernel_div!(result, u, qpinfo)\n        return result .= sum(u) .^ 2\n    end\n    DivNormIntegrator = ItemIntegrator(kernel_div!, enrich ? [div(u), div(uR)] : [div(u)]; quadorder = 2 * order)\n    NDofs = zeros(Int, nrefs)\n    Results = zeros(Float64, nrefs, 5)\n\n    for lvl in 1:nrefs\n\n        # grid\n        xgrid = get_grid2D(lvl)\n\n        # define and assign unknowns\n        PD = ProblemDescription(\"Stokes problem\")\n        assign_unknown!(PD, u)\n        p = reduce * enrich ? p0 : pfull\n        assign_unknown!(PD, p)\n\n        ################\n        ### FESPACES ###\n        ################\n        if order == 1\n            FES_enrich = FESpace{HDIVRT0{2}}(xgrid)\n        else\n            FES_enrich = FESpace{HDIVRTkENRICH{2, order - 1, reduce}}(xgrid)\n        end\n        FES = Dict(\n            u => FESpace{H1Pk{2, 2, order}}(xgrid),\n            pfull => FESpace{order == 1 ? L2P0{1} : H1Pk{1, 2, order - 1}}(xgrid; broken = true),\n            p0 => FESpace{L2P0{1}}(xgrid; broken = true),\n            uR => enrich ? FES_enrich : nothing\n        )\n\n        ######################\n        ### STANDARD TERMS ###\n        ######################\n        assign_operator!(PD, LinearOperator(rhs!, [id(u)]; bonus_quadorder = bonus_quadorder, kwargs...))\n        assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n        assign_operator!(PD, InterpolateBoundaryData(u, exact_u!; regions = 1:4, bonus_quadorder = bonus_quadorder))\n        assign_operator!(PD, FixDofs(p; dofs = [1], vals = [0]))\n\n        ##################\n        ### ENRICHMENT ###\n        ##################\n        if enrich\n            if reduce\n                if order == 1\n                    @info \"... preparing condensation of RT0 dofs\"\n                    AR = FEMatrix(FES_enrich)\n                    BR = FEMatrix(FES[p], FES_enrich)\n                    bR = FEVector(FES_enrich)\n                    assemble!(AR, BilinearOperator([div(1)]; lump = true, factor = α * μ, kwargs...))\n                    for bface in xgrid[BFaceFaces]\n                        AR.entries[bface, bface] = 1.0e60\n                    end\n                    assemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n                    assemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n                    # invert AR (diagonal matrix)\n                    AR.entries.cscmatrix.nzval .= 1 ./ AR.entries.cscmatrix.nzval\n                    C = -BR.entries.cscmatrix * AR.entries.cscmatrix * BR.entries.cscmatrix'\n                    c = -BR.entries.cscmatrix * AR.entries.cscmatrix * bR.entries\n                    assign_operator!(PD, BilinearOperator(C, [p], [p]; kwargs...))\n                    assign_operator!(PD, LinearOperator(c, [p]; kwargs...))\n                else\n                    @info \"... preparing removal of enrichment dofs\"\n                    BR = FEMatrix(FES[p], FES_enrich)\n                    A1R = FEMatrix(FES_enrich, FES[u])\n                    bR = FEVector(FES_enrich)\n                    assemble!(BR, BilinearOperator([id(1)], [div(1)]; factor = -1, kwargs...))\n                    assemble!(bR, LinearOperator(rhs!, [id(1)]; bonus_quadorder = 5, kwargs...); time = time)\n                    assemble!(A1R, BilinearOperator([id(1)], [Δ(1)]; factor = -μ, kwargs...))\n                    F, DD_RR = div_projector(FES[u], FES_enrich)\n                    C = F.entries.cscmatrix * A1R.entries.cscmatrix\n                    assign_operator!(PD, BilinearOperator(C, [u], [u]; factor = 1, transposed_copy = -1, kwargs...))\n                    assign_operator!(PD, LinearOperator(F.entries.cscmatrix * bR.entries, [u]; kwargs...))\n                end\n            else\n                assign_unknown!(PD, uR)\n                assign_operator!(PD, LinearOperator(rhs!, [id(uR)]; bonus_quadorder = 5, kwargs...))\n                assign_operator!(PD, BilinearOperator([id(p)], [div(uR)]; transposed_copy = 1, factor = -1, kwargs...))\n                if order == 1\n                    assign_operator!(PD, BilinearOperator([div(uR)]; lump = true, factor = μ, kwargs...))\n                    assign_operator!(PD, HomogeneousBoundaryData(uR; regions = 1:4))\n                else\n                    assign_operator!(PD, BilinearOperator([Δ(u)], [id(uR)]; factor = μ, transposed_copy = -1, kwargs...))\n                end\n            end\n        end\n\n        #############\n        ### SOLVE ###\n        #############\n        sol = solve(PD, FES; time = time, kwargs...)\n        NDofs[lvl] = length(sol.entries)\n\n        # move integral mean of pressure\n        pintegrate = ItemIntegrator([id(p)])\n        pmean = sum(evaluate(pintegrate, sol)) / sum(xgrid[CellVolumes])\n        view(sol[p]) .-= pmean\n\n        ######################\n        ### POSTPROCESSING ###\n        ######################\n        if enrich && reduce\n            append!(sol, FES_enrich; tag = uR)\n            if order == 1\n                # compute enrichment part of velocity\n                view(sol[uR]) .= AR.entries.cscmatrix * (bR.entries - BR.entries.cscmatrix' * view(sol[p]))\n            else\n                # compute enrichment part of velocity\n                view(sol[uR]) .= F.entries.cscmatrix' * view(sol[u])\n            end\n\n            # compute higher order pressure dofs\n            if reduce && order > 1\n                # add blocks for higher order pressures to sol vector\n                VR = FES_enrich\n                append!(sol, VR; tag = pE)\n                append!(sol, FES[pfull]; tag = pfull)\n                sol_pE = view(sol[pE])\n                sol_pfull = view(sol[pfull])\n                sol_p0 = view(sol[p0])\n\n                res = FEVector(VR)\n                addblock_matmul!(res[1], A1R[1, 1], sol[u])\n                celldofs_VR::VariableTargetAdjacency{Int32} = VR[CellDofs]\n                ndofs_VR = max_num_targets_per_source(celldofs_VR)\n                Ap = zeros(Float64, ndofs_VR, ndofs_VR)\n                bp = zeros(Float64, ndofs_VR)\n                xp = zeros(Float64, ndofs_VR)\n                for cell in 1:num_cells(xgrid)\n                    # solve local pressure reconstruction\n                    # (p_h, div VR) = - (f,VR) + a_h(u_h,VR)\n                    for dof_j in 1:ndofs_VR\n                        dof = celldofs_VR[dof_j, cell]\n                        bp[dof_j] = -bR.entries[dof] + res.entries[dof]\n                        for dof_k in 1:ndofs_VR\n                            dof2 = celldofs_VR[dof_k, cell]\n                            Ap[dof_j, dof_k] = DD_RR.entries[dof, dof2]\n                        end\n                    end\n\n                    # solve for coefficients of div(RT1bubbles)\n                    xp = Ap \\ bp\n\n                    # save in block id_pk\n                    for dof_j in 1:ndofs_VR\n                        dof = celldofs_VR[dof_j, cell]\n                        sol_pE[dof] = xp[dof_j]\n                    end\n                end\n\n                # interpolate into Pk basis (= same pressure basis as in full scheme)\n                PF = FES[pfull]\n                append!(sol, PF; tag = pfull)\n                celldofs_PF::SerialVariableTargetAdjacency{Int32} = PF[CellDofs]\n                ndofs_PF::Int = max_num_targets_per_source(celldofs_PF)\n\n                # compute local mass matrix of full pressure space\n                MAMA = FEMatrix(PF)\n                assemble!(MAMA, BilinearOperator([id(1)]))\n                MAMAE::ExtendableSparseMatrix{Float64, Int64} = MAMA.entries\n\n                # full div-pressure matrix\n                PFxVR = FEMatrix(PF, VR)\n                assemble!(PFxVR, BilinearOperator([id(1)], [div(1)]))\n                PFxVRE::ExtendableSparseMatrix{Float64, Int64} = PFxVR.entries\n                bp = zeros(Float64, ndofs_PF)\n                xp = zeros(Float64, ndofs_PF)\n                locMAMA = zeros(Float64, ndofs_PF, ndofs_PF)\n                for cell in 1:num_cells(xgrid)\n                    # solve local pressure reconstruction\n                    fill!(bp, 0)\n                    for dof_k in 1:ndofs_PF\n                        dof2 = celldofs_PF[dof_k, cell]\n                        for dof_j in 1:ndofs_VR\n                            dof = celldofs_VR[dof_j, cell]\n                            bp[dof_k] += PFxVRE[dof2, dof] * sol_pE[dof]\n                        end\n                        for dof_j in 1:ndofs_PF\n                            dof = celldofs_PF[dof_j, cell]\n                            locMAMA[dof_k, dof_j] = MAMAE[dof2, dof]\n                        end\n                    end\n\n                    # solve for coefficients of div(RT1bubbles)\n                    xp = locMAMA \\ bp\n                    for dof_j in 1:ndofs_PF\n                        dof = celldofs_PF[dof_j, cell]\n                        sol_pfull[dof] = sol_p0[cell] + xp[dof_j]\n                    end\n                end\n            elseif reduce && order == 1\n                pfull = p0\n            end\n        end\n\n        ########################\n        ### ERROR EVALUATION ###\n        ########################\n        error = evaluate(ErrorIntegratorExact, sol)\n        L2errorU = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n        H1errorU = sqrt(sum(view(error, 3, :)) + sum(view(error, 4, :)) + sum(view(error, 5, :)) + sum(view(error, 6, :)))\n        @info \"L2error(u) = $L2errorU\"\n        @info \"L2error(∇u) = $H1errorU\"\n        evaluate!(error, ErrorIntegratorPressure, sol)\n        L2errorP = sqrt(sum(view(error, 1, :)))\n        @info \"L2error(p) = $L2errorP\"\n        Results[lvl, 4] = L2errorP\n        if enrich\n            fill!(error, 0)\n            evaluate!(error, L2NormIntegratorE, sol)\n            L2normUR = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n            @info \"L2norm(uR) = $L2normUR\"\n        end\n        fill!(error, 0)\n        evaluate!(error, DivNormIntegrator, sol)\n        L2normDiv = sqrt(sum(view(error, 1, :)))\n        @info \"L2norm(div(u+uR)) = $L2normDiv\"\n\n        Results[lvl, 1] = L2errorU\n        Results[lvl, 2] = H1errorU\n        Results[lvl, 3] = L2normUR\n        Results[lvl, 5] = L2normDiv\n\n        #############\n        ### PLOTS ###\n        #############\n        scalarplot!(plt[1, 1], id(u), sol; abs = true)\n        scalarplot!(plt[1, 2], id(pfull), sol)\n        if order == 1 && enrich\n            scalarplot!(plt[2, 2], id(uR), sol)\n        end\n    end\n    plot_convergencehistory!(\n        plt[2, 1],\n        NDofs,\n        Results[:, 1:4];\n        add_h_powers = [order, order + 1],\n        X_to_h = X -> 8 * X .^ (-1 / 2),\n        legend = :best,\n        ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"],\n    )\n\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"|| uR ||\", \"|| p - p_h ||\", \"|| div(u + uR) ||\"], xlabel = \"ndof\")\n\n    return Results, plt\nend\n\nfunction div_projector(V1, VR)\n\n    # setup interpolation matrix\n    celldofs_V1 = V1[CellDofs]\n    celldofs_VR = VR[CellDofs]\n    ndofs_V1 = max_num_targets_per_source(celldofs_V1)\n    ndofs_VR = max_num_targets_per_source(celldofs_VR)\n\n    DD_RR = FEMatrix(VR)\n    assemble!(DD_RR, BilinearOperator([div(1)]))\n    DD_RRE = DD_RR.entries\n    DD_1R = FEMatrix(V1, VR)\n    assemble!(DD_1R, BilinearOperator([div(1)]))\n    DD_1RE = DD_1R.entries\n    Ap = zeros(Float64, ndofs_VR, ndofs_VR)\n    bp = zeros(Float64, ndofs_VR)\n    xp = zeros(Float64, ndofs_VR)\n    ncells = num_sources(celldofs_V1)\n    F = FEMatrix(V1, VR)\n    FE = F.entries\n    for cell in 1:ncells\n\n        # solve local pressure reconstruction for RTk part\n        for dof_j in 1:ndofs_VR\n            dof = celldofs_VR[dof_j, cell]\n            for dof_k in 1:ndofs_VR\n                dof2 = celldofs_VR[dof_k, cell]\n                Ap[dof_j, dof_k] = DD_RRE[dof, dof2]\n            end\n        end\n\n        for dof_j in 1:ndofs_V1\n            dof = celldofs_V1[dof_j, cell]\n            for dof_k in 1:ndofs_VR\n                dof2 = celldofs_VR[dof_k, cell]\n                bp[dof_k] = -DD_1RE[dof, dof2]\n            end\n\n            xp = Ap \\ bp\n\n            for dof_k in 1:ndofs_VR\n                dof2 = celldofs_VR[dof_k, cell]\n                FE[dof, dof2] = xp[dof_k]\n            end\n        end\n    end\n    flush!(FE)\n    return F, DD_RR\nend\n\nend # module","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"","category":"page"},{"location":"module_examples/Example240_SVRTEnrichment/","page":"Example240_SVRTEnrichment","title":"Example240_SVRTEnrichment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/#235-:-Stokes-iterated-penalty-method","page":"Example235_StokesIteratedPenalty","title":"235 : Stokes iterated penalty method","text":"","category":"section"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"(source code)","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Stokes problem","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbf0\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"with some μ parameter mu.","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain with the iterated penalty method suggested in the reference below adapted to the Bernardi–Raugel finite element method. Given intermediate solutions mathbfu_h and p_h the next approximations are computed by the two equations","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"beginaligned\n(nabla mathbfu_h^next nabla mathbfv_h) + lambda (mathrmdiv_h(mathbfu^next_h) mathrmdiv_h(mathbfv_h))  = (mathbffmathbfv_h) + (p_hmathrmdiv(mathbfv_h))\n textfor all  mathbfv_h in mathbfV_h\n(p^next_hq_h)  = (p_hq_h) - lambda (mathrmdiv(mathbfu_h^next)q_h)  textfor all  q_h in Q_h\nendaligned","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This is done consecutively until the residual of both equations is small enough. The discrete divergence is computed via a RT0 reconstruction operator that preserves the discrete divergence. (another way would be to compute B M^-1 B^T where M is the mass matrix of the pressure and B is the matrix for the div-pressure block).","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"reference: Reference\n\"An iterative penalty method for the finite element solution of the stationary Navier-Stokes equations\",\nR. Codina,\nComputer Methods in Applied Mechanics and Engineering Volume 110, Issues 3–4 (1993),\n>Journal-Link<","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"(Image: )","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"module Example235_StokesIteratedPenalty\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# data for Hagen-Poiseuille flow\nfunction p!(result, qpinfo)\n    x = qpinfo.x\n    μ = qpinfo.params[1]\n    result[1] = μ * (-2 * x[1] + 1.0)\n    return nothing\nend\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[2] * (1.0 - x[2])\n    result[2] = 0.0\n    return nothing\nend\n# kernel for div projection\nfunction div_projection!(result, input, qpinfo)\n    result[1] = input[1] - qpinfo.params[1] * input[2]\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, λ = 1.0e4, μ = 1.0, nrefs = 5, kwargs...)\n\n    # initial grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n    # Bernardi--Raugel element with reconstruction operator\n    FETypes = (H1BR{2}, L2P0{1})\n    PenaltyDivergence = Reconstruct{HDIVRT0{2}, Divergence}\n\n    # generate two problems\n    # one for velocity, one for pressure\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    PDu = ProblemDescription(\"Stokes IPM - velocity update\")\n    assign_unknown!(PDu, u)\n    assign_operator!(PDu, BilinearOperator([grad(u)]; factor = μ, store = true, kwargs...))\n    assign_operator!(PDu, BilinearOperator([apply(u, PenaltyDivergence)]; store = true, factor = λ, kwargs...))\n    assign_operator!(PDu, LinearOperator([div(u)], [id(p)]; factor = 1, kwargs...))\n    assign_operator!(PDu, InterpolateBoundaryData(u, u!; regions = 1:4, params = [μ], bonus_quadorder = 4, kwargs...))\n\n    PDp = ProblemDescription(\"Stokes IPM - pressure update\")\n    assign_unknown!(PDp, p)\n    assign_operator!(PDp, BilinearOperator([id(p)]; store = true, kwargs...))\n    assign_operator!(PDp, LinearOperator(div_projection!, [id(p)], [id(p), div(u)]; params = [λ], factor = 1, kwargs...))\n\n    # show and solve problem\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n    sol = FEVector([FES[1], FES[2]]; tags = [u, p])\n    SC1 = SolverConfiguration(PDu; init = sol, maxiterations = 1, target_residual = 1.0e-8, constant_matrix = true, kwargs...)\n    SC2 = SolverConfiguration(PDp; init = sol, maxiterations = 1, target_residual = 1.0e-8, constant_matrix = true, kwargs...)\n    sol, nits = iterate_until_stationarity([SC1, SC2]; init = sol, kwargs...)\n    @info \"converged after $nits iterations\"\n\n    # plot\n    plt = plot([id(u), id(p)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"","category":"page"},{"location":"module_examples/Example235_StokesIteratedPenalty/","page":"Example235_StokesIteratedPenalty","title":"Example235_StokesIteratedPenalty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example226_Thermoforming/#226-:-Thermoforming","page":"Example226_Thermoforming","title":"226 : Thermoforming","text":"","category":"section"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"(source code)","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"This implements the thermoforming example taken from https://arxiv.org/abs/1802.03564 Section 6.4. The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"(Image: )","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"module Example226_Thermoforming\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SparseArrays\nusing LinearAlgebra\n\nfunction w(r)\n    if 0.1 ≤ r ≤ 0.3\n        return 5.0 * r - 0.5\n    elseif 0.3 < r < 0.7\n        return 1.0\n    elseif 0.7 <= r <= 0.9\n        return 4.5 - 5.0 * r\n    else\n        return 0.0\n    end\nend\n\n# initial mould\nfunction Φ0(x)\n    return w(x[1]) * w(x[2])\nend\n\n\nfunction g(r, κ, s)\n    if r <= 0.0\n        return κ\n    elseif r <= 0.25 * s\n        return κ - 8.0 * κ * r^2 / (3.0 * s^2)\n    elseif r <= 0.75 * s\n        return 7.0 / 6.0 * κ - 4.0 / 3.0 * κ * r / s\n    elseif r <= s\n        return 8.0 / 3.0 * (s - r)^2 / s^2\n    else\n        return 0.0\n    end\nend\n\n\n# The smooth bump function in [0,1]\nbump(x) = (0.0 <= x <= 1.0) ? exp(-0.25 / (x - x^2)) : 0.0\n\n# Bump in [0,1]^2\nbumpInUnitSquare(x) = begin\n    r = sqrt((x[1] - 0.5)^2 + (x[2] - 0.5)^2)\n    return bump(0.5 + r)\nend\n\n\n# nonlinear kernel\nfunction nonlinear_kernel!(result, input, qpinfo)\n    # results and input contain 7 variables (u,∇u,T,∇T,y)\n    u = view(input, 1)\n    ∇u = view(input, 2:3)\n    T = view(input, 4)\n    ∇T = view(input, 5:6)\n    y = view(input, 7)\n\n    α = qpinfo.params[1]\n    k = qpinfo.params[2]\n    f = qpinfo.params[3]\n    β = qpinfo.params[4]\n    κ = qpinfo.params[5]\n    s = qpinfo.params[6]\n\n    result[1] = α * max(0, u[1] - y[1]) - f                                             # pattern: 1 7\n    result[2:3] = ∇u                                                                      # pattern: 2 / 3\n    result[4] = k * T[1] - g(y[1] - u[1], κ, s)                                               # pattern: 1 4 7\n    result[5:6] = ∇T                                                                      # pattern: 5 / 6\n    result[7] = y[1] - Φ0(qpinfo.x) - β * bumpInUnitSquare(qpinfo.x) * T[1]           # pattern: 4 7\n    return nothing\nend\n\n# custom sparsity pattern for the jacobians of the nonlinear_kernel (Symbolcs cannot handle conditional jumps)\n# note: jacobians are defined row-wise\nrows = [1, 1, 2, 3, 4, 4, 4, 5, 6, 7, 7]\ncols = [1, 7, 2, 3, 1, 4, 7, 5, 6, 4, 7]\nvals = ones(Bool, length(cols))\nsparsity_pattern = sparse(rows, cols, vals)\n\nfunction main(;\n        κ = 10,\n        s = 1,\n        α = 1.0e8,\n        k = 1,\n        β = 5.25e-3,\n        f = 100,\n        N = 32,\n        order = 1,\n        Plotter = nothing,\n        kwargs...\n    )\n\n    # choose mesh,\n    h = 1 / (N + 1)\n    xgrid = simplexgrid(0:h:1, 0:h:1)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"membrane position\")\n    y = Unknown(\"y\"; name = \"mould\")\n    T = Unknown(\"T\"; name = \"temperature\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, y)\n    assign_unknown!(PD, T)\n    assign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u), id(T), grad(T), id(y)]; bonus_quadorder = 2, params = [α, k, f, β, κ, s], sparse_jacobians_pattern = sparsity_pattern, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(y; regions = 1:4, kwargs...))\n\n    # create finite element space\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n    FESs = [FES, FES, FES]\n    sol = FEVector(FESs; tags = [u, y, T])\n\n    # initial guess for Newton\n    interpolate!(sol[u], (result, qpinfo) -> (result[1] = 0.9 * Φ0(qpinfo.x)))\n    interpolate!(sol[T], (result, qpinfo) -> (result[1] = 0.2))\n    interpolate!(sol[y], (result, qpinfo) -> (result[1] = 10.0))\n\n    # solve\n    sol = solve(PD, FESs; init = sol, maxiterations = 420, target_residual = 1.0e-8, kwargs...)\n\n    # plot\n    plt = plot([id(u), id(T), id(y)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"","category":"page"},{"location":"module_examples/Example226_Thermoforming/","page":"Example226_Thermoforming","title":"Example226_Thermoforming","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/#260-:-Axisymmetric-Stokes","page":"Example260_AxisymmetricNavierStokesProblem","title":"260 : Axisymmetric Stokes","text":"","category":"section"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This example solves the 3D stagnation point flow via the 2.5D axisymmetric formulation of the Navier–Stokes problem that seeks a velocity mathbfu = (u_z u_r) and pressure p such that","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z - r^-2 right) u_r\n+ (u_r partial_r + u_z partial_z) u_r + partial_r p  = mathbff_r\n- muleft(partial^2_r + r^-1 partial_r + partial^2_z right) u_z\n+ (u_r partial_r + u_z partial_z) u_z + partial_z p  = mathbff_z\n(partial_r + r^-1)u_r + partial_z u_z  = 0\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"with exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"The axisymmetric formulation assumes that the velocity in some 3D-domain, that is obtained by rotation of a 2D domain Omega, only depends on the distance r to the rotation axis and the z-coordinate tangential to the x-axis, but not on the angular coordinate of the cylindric coordinates. The implementation employs r-dependent bilinear forms and a Cartesian grid for the 2D (zr) domain that is assumed to be rotated around the r=0-axis.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This leads to the weak formulation","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\na(uv) + b(pv)  = (fv) \n         b(qu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"with the bilinear forms","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"beginaligned\na(uv) = int_Omega left( nabla u  nabla v + r^-2 u_r v_r right) r dr dz\nb(qv) = int_Omega q left( mathrmdiv(v) + r^-1 u_r right) r dr dz\nendaligned","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"where the usual Cartesian differential operators can be used. The factor 2pi from the integral over the rotation angle drops out on both sides.","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"module Example260_AxisymmetricNavierStokesProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n\nfunction kernel_convection!(result, input, qpinfo)\n    u, ∇u = view(input, 1:2), view(input, 3:6)\n    r = qpinfo.x[1]\n    result[1] = r * (∇u[1] * u[1] + ∇u[2] * u[2])\n    result[2] = r * (∇u[3] * u[1] + ∇u[4] * u[2])\n    return nothing\nend\n\nfunction kernel_stokes_axisymmetric!(result, u_ops, qpinfo)\n    u, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n    r = qpinfo.x[1]\n    μ = qpinfo.params[1]\n    # add Laplacian\n    result[1] = μ / r * u[1] - p[1]\n    result[2] = 0\n    result[3] = μ * r * ∇u[1] - r * p[1]\n    result[4] = μ * r * ∇u[2]\n    result[5] = μ * r * ∇u[3]\n    result[6] = μ * r * ∇u[4] - r * p[1]\n    result[7] = -(r * (∇u[1] + ∇u[4]) + u[1])\n    return nothing\nend\n\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = x[1]\n    result[2] = -2 * x[2]\n    return nothing\nend\n\nfunction kernel_l2div(result, u_ops, qpinfo)\n    u, divu = view(u_ops, 1:2), view(u_ops, 3)\n    result[1] = (qpinfo.x[1] * divu[1] + u[1])^2\n    return nothing\nend\n\n\nfunction main(; μ = 0.1, nrefs = 4, nonlinear = false, uniform = false, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_axisymmetric!, [id(u), grad(u), id(p)]; params = [μ], kwargs...)) #; jacobian = kernel_jacobian!))\n    if nonlinear\n        assign_operator!(PD, NonlinearOperator(kernel_convection!, [id(u)], [id(u), grad(u)]; bonus_quadorder = 1, kwargs...)) #; jacobian = kernel_jacobian!))\n    end\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = [3]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [4], mask = (1, 0, 1)))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = (0, 1, 1)))\n\n    # grid\n    if uniform\n        xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    else\n        xgrid = simplexgrid(\n            Triangulate;\n            points = [0 0 ; 5 0 ; 5 1 ; 0 1]',\n            bfaces = [1 2 ; 2 3 ; 3 4 ; 4 1 ]',\n            bfaceregions = [1, 2, 3, 4],\n            regionpoints = [0.5 0.5;]',\n            regionnumbers = [1],\n            regionvolumes = [4.0^(-nrefs - 1)]\n        )\n    end\n\n    # solve\n    FES = [FESpace{H1P2B{2, 2}}(xgrid), FESpace{L2P1{1}}(xgrid)]\n    sol = ExtendableFEM.solve(PD, FES; kwargs...)\n\n    # compute divergence in cylindrical coordinates by volume integrals\n    DivIntegrator = ItemIntegrator(kernel_l2div, [id(u), div(u)]; quadorder = 4, resultdim = 1)\n    div_error = sqrt(sum(evaluate(DivIntegrator, sol)))\n    @info \"||div(u_h)|| = $div_error\"\n\n    # compute L2error\n    function kernel_l2error(result, u_ops, qpinfo)\n        u!(result, qpinfo)\n        return result .= (result - u_ops) .^ 2\n    end\n    ErrorIntegratorExact = ItemIntegrator(kernel_l2error, [id(1)]; entities = ON_BFACES, regions = [3], quadorder = 4, kwargs...)\n    error = evaluate(ErrorIntegratorExact, sol)\n    L2error = sqrt(sum(view(error, 1, :)) + sum(view(error, 2, :)))\n    @info \"||u - u_h|| = $L2error\"\n\n    # plot\n    plt = plot([id(u)], sol; Plotter = Plotter)\n\n    return [div_error, L2error], plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"","category":"page"},{"location":"module_examples/Example260_AxisymmetricNavierStokesProblem/","page":"Example260_AxisymmetricNavierStokesProblem","title":"Example260_AxisymmetricNavierStokesProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example285_CahnHilliard/#285-:-Cahn-Hilliard-Equations","page":"Example285_CahnHilliard","title":"285 : Cahn-Hilliard Equations","text":"","category":"section"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"(source code)","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"This example studies the mixed form of the Cahn-Hilliard equations that seeks (cmu) such that","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"beginaligned\nc_t - mathbfdiv (M nabla mu)  = 0\nmu - partial f  partial c + lambda nabla^2c  = 0\nendaligned","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"with f(c) = 100c^2(1-c)^2, constant parameters M and lambda and (random) initial concentration as defined in the code below.","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"The computed solution at different timesteps for the default parameters and a randomized initial state look like this:","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"(Image: )","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"module Example285_CahnHilliard\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing ForwardDiff\nusing Random\nRandom.seed!(135791113)\n\n# parameters and initial condition\nconst f = (c) -> 100 * c^2 * (1 - c)^2\nconst dfdc = (c) -> ForwardDiff.derivative(f, c)\n\nfunction c0!(result, qpinfo)\n    result[1] = 0.63 + 0.02 * (0.5 - rand())\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(;\n        order = 2,                              # finite element order for c and μ\n        nref = 4,                               # refinement level\n        M = 1.0,\n        λ = 1.0e-2,\n        iterations_until_next_plot = 20,\n        τ = 5 / 1000000,                        # time step (for main evolution phase)\n        τ_increase = 1.1,                      # increase factor for τ after each plot\n        Plotter = nothing,                      # Plotter (e.g. PyPlot)\n        kwargs...,\n    )\n\n    # initial grid and final time\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nref)\n\n    # define unknowns\n    c = Unknown(\"c\"; name = \"concentration\", dim = 1)\n    μ = Unknown(\"μ\"; name = \"chemical potential\", dim = 1)\n\n    # define main level set problem\n    PD = ProblemDescription(\"Cahn-Hilliard equation\")\n    assign_unknown!(PD, c)\n    assign_unknown!(PD, μ)\n    assign_operator!(PD, BilinearOperator([grad(c)], [grad(μ)]; factor = M, store = true))\n    assign_operator!(PD, BilinearOperator([id(μ)]; store = true))\n    assign_operator!(PD, BilinearOperator([grad(μ)], [grad(c)]; factor = -λ, store = true))\n\n    # add nonlinear reaction part (= -df/dc times test function)\n    function kernel_dfdc!(result, input, qpinfo)\n        return result[1] = -dfdc(input[1])\n    end\n    assign_operator!(PD, NonlinearOperator(kernel_dfdc!, [id(μ)], [id(c)]; bonus_quadorder = 1))\n\n    # generate FESpace and solution vector and interpolate initial state\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n    sol = FEVector([FES, FES]; tags = PD.unknowns)\n    interpolate!(sol[c], c0!)\n\n    # init plot (if order > 1, solution is upscaled to finer grid for plotting)\n    plt = GridVisualizer(; Plotter = Plotter, layout = (4, 3), clear = true, resolution = (900, 1200))\n    if order > 1\n        xgrid_upscale = uniform_refine(xgrid, order - 1)\n        SolutionUpscaled = FEVector(FESpace{H1P1{1}}(xgrid_upscale))\n        lazy_interpolate!(SolutionUpscaled[1], sol)\n    else\n        xgrid_upscale = xgrid\n        SolutionUpscaled = sol\n    end\n    nodevals = nodevalues_view(SolutionUpscaled[1])\n    scalarplot!(plt[1, 1], xgrid_upscale, nodevals[1]; limits = (0.61, 0.65), xlabel = \"\", ylabel = \"\", levels = 1, title = \"c (t = 0)\")\n\n    # prepare backward Euler time derivative\n    M = FEMatrix(FES)\n    b = FEVector(FES)\n    assemble!(M, BilinearOperator([id(1)]; factor = 1.0 / τ))\n    assign_operator!(PD, BilinearOperator(M, [c]; kwargs...))\n    assign_operator!(PD, LinearOperator(b, [c]; kwargs...))\n\n    # generate solver configuration\n    SC = SolverConfiguration(PD, [FES, FES]; init = sol, maxiterations = 50, target_residual = 1.0e-6, kwargs...)\n\n    # advance in time, plot from time to time\n    t = 0\n    for j in 1:11\n        # do some timesteps until next plot\n        for it in 1:iterations_until_next_plot\n            t += τ\n            # update time derivative\n            b.entries .= M.entries * view(sol[c])\n            ExtendableFEM.solve(PD, [FES, FES], SC; time = t)\n        end\n\n        # enlarge time step a little bit\n        τ *= τ_increase\n        M.entries.cscmatrix.nzval ./= τ_increase\n\n        # plot at current time\n        if order > 1\n            lazy_interpolate!(SolutionUpscaled[1], sol)\n        end\n        scalarplot!(plt[1 + Int(floor((j) / 3)), 1 + (j) % 3], xgrid_upscale, nodevals[1]; xlabel = \"\", ylabel = \"\", limits = (-0.1, 1.1), levels = 1, title = \"c (t = $(Float32(t)))\")\n    end\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"","category":"page"},{"location":"module_examples/Example285_CahnHilliard/","page":"Example285_CahnHilliard","title":"Example285_CahnHilliard","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example330_HyperElasticity/#330-:-Hyperelasticity","page":"Example330_HyperElasticity","title":"330 : Hyperelasticity","text":"","category":"section"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"This examples computes the solution of a nonlinear elasticity problem for hyperelastic media via minimisation of the (neo-Hookian) energy functional","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"beginaligned\n\tW(u F(mathbfu)) = int_Omega fracmu2 (FF - 3 - 2log(mathrmdet(F))) + fraclambda2 log(mathrmdet(F))^2 - B cdot mathbfu textitdx - int_partial Omega T cdot mathbfu textitds\nendaligned","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"where F(mathbfu) = I + nabla u is the deformation gradient and mu and lambda are the Lame parameters. The energy is differentiated twice by automatic differentiation to setup a Newton scheme for a Lagrangian finite element approximation of mathbfu, once in the code below to define the kernel for the NonlinearOperator and this kernel is differentiated again in the assembly of the Newton scheme for the nonlinear operator.","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"The deformed unit cube and the displacement for the default parameters and inhomogeneous boundary conditions as defined in the code looks like this:","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"module Example330_HyperElasticity\n\nusing ExtendableFEM\nusing LinearAlgebra\nusing DiffResults\nusing ForwardDiff\nusing SimplexGridFactory\nusing TetGen\n\n# inhomogeneous boundary conditions for bregion 1\nfunction bnd_1!(result, qpinfo)\n    x, y, z = qpinfo.x[1], qpinfo.x[2], qpinfo.x[3]\n    angle = pi / 3\n    result[1] = 0.0\n    result[2] = (0.5 + (y - 0.5) * cos(angle) - (z - 0.5) * sin(angle) - y) / 2.0\n    return result[3] = (0.5 + (y - 0.5) * sin(angle) + (z - 0.5) * cos(angle) - x) / 2.0\nend\n\n# kernel for body and traction forces\nfunction apply_force!(result, qpinfo)\n    return result .= qpinfo.params[1]\nend\n\n# energy functional (only nonlinear part, without exterior forces)\nfunction W!(result, F, qpinfo)\n    F[1] += 1\n    F[5] += 1\n    F[9] += 1\n    μ, λ = qpinfo.params[1], qpinfo.params[2]\n    detF = -(F[3] * (F[5] * F[7] - F[4] * F[8]) + F[2] * ((-F[6]) * F[7] + F[4] * F[9]) + F[1] * (F[6] * F[8] - F[5] * F[9]))\n    result[1] = μ / 2 * (dot(F, F) - 3 - 2 * log(detF)) + λ / 2 * (log(detF))^2\n    return nothing\nend\n\n# derivative of energy functional (by ForwardDiff)\nfunction nonlinkernel_DW!()\n    Dresult = nothing\n    cfg = nothing\n    result_dummy = nothing\n    W(qpinfo) = (a, b) -> W!(a, b, qpinfo)\n\n    return function closure(result, input, qpinfo)\n        if Dresult === nothing\n            # first initialization of DResult when type of input = F is known\n            result_dummy = zeros(eltype(input), 1)\n            Dresult = DiffResults.JacobianResult(result_dummy, input)\n            cfg = ForwardDiff.JacobianConfig(W(qpinfo), result_dummy, input, ForwardDiff.Chunk{length(input)}())\n        end\n        Dresult = ForwardDiff.vector_mode_jacobian!(Dresult, W(qpinfo), result_dummy, input, cfg)\n        copyto!(result, DiffResults.jacobian(Dresult))\n        return nothing\n    end\nend\n\n\nfunction main(;\n        maxvolume = 0.001,  # parameter for grid generator\n        E = 10,             # Young modulus\n        ν = 0.3,            # Poisson ratio\n        order = 3,             # finite element order\n        B = [0, -0.5, 0],     # body force\n        T = [0.1, 0, 0],      # traction force\n        Plotter = nothing,\n        kwargs...\n    )\n\n    # compute Lame parameters\n    μ = E / (2 * (1 + ν))\n    λ = E * ν / ((1 + ν) * (1 - 2 * ν))\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"displacement\")\n\n    # define problem\n    PD = ProblemDescription(\"Hyperelasticity problem\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(nonlinkernel_DW!(), [grad(u)]; sparse_jacobians = false, params = [μ, λ]))\n    assign_operator!(PD, LinearOperator(apply_force!, [id(u)]; params = [B]))\n    assign_operator!(PD, LinearOperator(apply_force!, [id(u)]; entities = ON_BFACES, store = true, regions = 1:6, params = [T]))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [2]))\n    assign_operator!(PD, InterpolateBoundaryData(u, bnd_1!; regions = [1], quadorder = 10))\n\n    # grid\n    xgrid = tetrahedralization_of_cube(maxvolume = maxvolume)\n\n    # solve\n    FES = FESpace{H1P1{3}}(xgrid)\n    sol = solve(PD, FES; maxiterations = 20)\n\n    # displace mesh and plot final result\n    displace_mesh!(xgrid, sol[u])\n    plt = plot([grid(u), id(u)], sol; Plotter = Plotter, do_vector_plots = false)\n\n    return sol, plt\nend\n\n\nfunction tetrahedralization_of_cube(; maxvolume = 0.1)\n    builder = SimplexGridBuilder(; Generator = TetGen)\n\n    p1 = point!(builder, 0, 0, 0)\n    p2 = point!(builder, 1, 0, 0)\n    p3 = point!(builder, 1, 1, 0)\n    p4 = point!(builder, 0, 1, 0)\n    p5 = point!(builder, 0, 0, 1)\n    p6 = point!(builder, 1, 0, 1)\n    p7 = point!(builder, 1, 1, 1)\n    p8 = point!(builder, 0, 1, 1)\n\n    facetregion!(builder, 1)\n    facet!(builder, p1, p2, p3, p4)\n    facetregion!(builder, 2)\n    facet!(builder, p5, p6, p7, p8)\n    facetregion!(builder, 3)\n    facet!(builder, p1, p2, p6, p5)\n    facetregion!(builder, 4)\n    facet!(builder, p2, p3, p7, p6)\n    facetregion!(builder, 5)\n    facet!(builder, p3, p4, p8, p7)\n    facetregion!(builder, 6)\n    facet!(builder, p4, p1, p5, p8)\n\n    return simplexgrid(builder; maxvolume = maxvolume)\nend\n\nend # module","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"","category":"page"},{"location":"module_examples/Example330_HyperElasticity/","page":"Example330_HyperElasticity","title":"Example330_HyperElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"itemintegrators/#Item-Integrators","page":"Item Integrators","title":"Item Integrators","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Item integrators compute certain quantities of the Solution, like a posteriori errors estimators, norms, drag/lift coefficients or other statistics.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegrator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegrator","text":"function ItemIntegrator(\n\t[kernel!::Function],\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs). If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nparallel: assemble operator in parallel using partitions information. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.L2NormIntegrator-Tuple{Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.L2NormIntegrator","text":"function L2NormIntegrator(\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nItemIntegrator with a fixed kernel that computes the (componentwise) L2Norm of the arguments.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegrator''\nparallel: assemble operator in parallel using partitions information. Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegrator{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegrator,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegrator, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegrator,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegrator for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ItemIntegratorDG","page":"Item Integrators","title":"ItemIntegratorDG","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"ItemIntegratorDG is intended for quantities that involve jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions or jumps of broken FESpaces. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/item_integrator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"itemintegrators/#ExtendableFEM.ItemIntegratorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"Item Integrators","title":"ExtendableFEM.ItemIntegratorDG","text":"function ItemIntegratorDG(\n\tkernel::Function,\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates an ItemIntegrator that evaluates the specified (discontinuous) operator evaluations, puts it into the kernel function and integrates the results over the entities (see kwargs) along cell boundaries. If no kernel is given, the arguments are integrated directly. If a kernel is provided it has be conform to the interface\n\nkernel!(result, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point. Additionally the length of the result needs to be specified via the kwargs.\n\nEvaluation can be triggered via the evaluate function.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONFACES\nfactor: factor that should be multiplied during assembly. Default: 1\nname: name for operator used in printouts. Default: ''ItemIntegratorDG''\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\npiecewise: returns piecewise integrations, otherwise a global integration. Default: true\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where the item integrator should be evaluated. Default: Any[]\nresultdim: dimension of result field (default = length of arguments). Default: 0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEM.evaluate-Union{Tuple{UT}, Tuple{Tv}, Tuple{ItemIntegratorDG{Tv, UT}, Any}} where {Tv, UT}","page":"Item Integrators","title":"ExtendableFEM.evaluate","text":"function evaluate(\n\tO::ItemIntegratorDG,\n\tsol;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution and returns an matrix of size resultdim x num_items.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, FEVector}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::FEVector;\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#ExtendableFEMBase.evaluate!-Tuple{Any, ItemIntegratorDG, Vector{<:ExtendableFEMBase.FEVectorBlock}}","page":"Item Integrators","title":"ExtendableFEMBase.evaluate!","text":"function evaluate(\n\tb::AbstractMatrix,\n\tO::ItemIntegratorDG,\n\tsol::Array{FEVEctorBlock};\n\ttime = 0,\n\tkwargs...)\n\nEvaluates the ItemIntegratorDG for the specified solution into the matrix b.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/#210-:-Poisson-L-shape-Adaptive-Mesh-Refinement","page":"Example210_LshapeAdaptivePoissonProblem","title":"210 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"section"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This example computes the standard-residual error estimator for the H^1 error e = u - u_h of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"eta^2(u_h) = sum_T in mathcalT lvert T rvert  f + Delta u_h ^2_L^2(T)\n+ sum_F in mathcalF lvert F rvert  nabla u_h cdot mathbfn ^2_L^2(F)","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This example script showcases the evaluation of 2nd order derivatives like the Laplacian and adaptive mesh refinement.","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"The resulting mesh and error convergence history for the default parameters looks like:","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"module Example210_LshapeAdaptivePoissonProblem\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\n# exact solution u for the Poisson problem\nfunction u!(result, qpinfo)\n    x = qpinfo.x\n    r2 = x[1]^2 + x[2]^2\n    φ = atan(x[2], x[1])\n    if φ < 0\n        φ += 2 * pi\n    end\n    result[1] = r2^(1 / 3) * sin(2 * φ / 3)\n    return nothing\nend\n\n# gradient of exact solution\nfunction ∇u!(result, qpinfo)\n    x = qpinfo.x\n    φ = atan(x[2], x[1])\n    r2 = x[1]^2 + x[2]^2\n    if φ < 0\n        φ += 2 * pi\n    end\n    ∂r = 2 / 3 * r2^(-1 / 6) * sin(2 * φ / 3)\n    ∂φ = 2 / 3 * r2^(-1 / 6) * cos(2 * φ / 3)\n    result[1] = cos(φ) * ∂r - sin(φ) * ∂φ\n    result[2] = sin(φ) * ∂r + cos(φ) * ∂φ\n    return nothing\nend\n\n# kernel for exact error calculation\nfunction exact_error!(result, u, qpinfo)\n    u!(result, qpinfo)\n    ∇u!(view(result, 2:3), qpinfo)\n    result .-= u\n    result .= result .^ 2\n    return nothing\nend\n\n# kernel for face interpolation of normal jumps of gradient\nfunction gradnormalflux!(result, ∇u, qpinfo)\n    result[1] = dot(∇u, qpinfo.normal)\n    return nothing\nend\n\n# kernel for face refinement indicator\nfunction η_face!(result, gradjump, qpinfo)\n    result .= qpinfo.volume * gradjump .^ 2\n    return nothing\nend\n\n# kernel for cell refinement indicator\nfunction η_cell!(result, Δu, qpinfo)\n    result .= qpinfo.volume * Δu .^ 2\n    return nothing\nend\n\nfunction main(; maxdofs = 4000, θ = 0.5, μ = 1.0, nrefs = 1, order = 2, Plotter = nothing, kwargs...)\n\n    # problem description\n    PD = ProblemDescription(\"Poisson problem\")\n    u = Unknown(\"u\"; name = \"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; factor = μ, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u!; regions = 2:7, bonus_quadorder = 4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 8]))\n\n    # discretize\n    xgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n\n    # define interpolators and item integrators for error estimation and calculation\n    NormalJumpProjector = FaceInterpolator(gradnormalflux!, [jump(grad(u))]; resultdim = 1, order = order, only_interior = true, kwargs...)\n    ErrorIntegratorFace = ItemIntegrator(η_face!, [id(1)]; quadorder = 2 * order, entities = ON_FACES, kwargs...)\n    ErrorIntegratorCell = ItemIntegrator(η_cell!, [Δ(1)]; quadorder = 2 * (order - 2), entities = ON_CELLS, kwargs...)\n    ErrorIntegratorExact = ItemIntegrator(exact_error!, [id(1), grad(1)]; quadorder = 2 * order, kwargs...)\n\n    NDofs = zeros(Int, 0)\n    ResultsL2 = zeros(Float64, 0)\n    ResultsH1 = zeros(Float64, 0)\n    Resultsη = zeros(Float64, 0)\n    sol = nothing\n    ndofs = 0\n    level = 0\n    while ndofs < maxdofs\n        level += 1\n\n        # SOLVE : create a solution vector and solve the problem\n        println(\"------- LEVEL $level\")\n        if ndofs < 1000\n            println(stdout, unicode_gridplot(xgrid))\n        end\n        @time begin\n            # solve\n            FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n            sol = ExtendableFEM.solve(PD, FES; u = [u], kwargs...)\n            ndofs = length(sol[1])\n            push!(NDofs, ndofs)\n            println(\"\\t ndof =  $ndofs\")\n            print(\"@time  solver =\")\n        end\n\n        # ESTIMATE : calculate local error estimator contributions\n        @time begin\n            # calculate error estimator\n            Jumps4Faces = evaluate!(NormalJumpProjector, sol)\n            η_F = evaluate(ErrorIntegratorFace, Jumps4Faces)\n\n            η_T = evaluate(ErrorIntegratorCell, sol)\n            facecells = xgrid[FaceCells]\n            for face in 1:size(facecells, 2)\n                η_F[face] += η_T[facecells[1, face]]\n                if facecells[2, face] > 0\n                    η_F[face] += η_T[facecells[2, face]]\n                end\n            end\n\n            # calculate total estimator\n            push!(Resultsη, sqrt(sum(η_F)))\n            print(\"@time  η eval =\")\n        end\n\n        # calculate exact L2 error, H1 error\n        @time begin\n            error = evaluate(ErrorIntegratorExact, sol)\n            push!(ResultsL2, sqrt(sum(view(error, 1, :))))\n            push!(ResultsH1, sqrt(sum(view(error, 2, :)) + sum(view(error, 3, :))))\n            print(\"@time  e eval =\")\n        end\n\n        if ndofs >= maxdofs\n            break\n        end\n\n        # MARK+REFINE : mesh refinement\n        @time begin\n            if θ >= 1 ## uniform mesh refinement\n                xgrid = uniform_refine(xgrid)\n            else ## adaptive mesh refinement\n                # refine by red-green-blue refinement (incl. closuring)\n                facemarker = bulk_mark(xgrid, view(η_F, :), θ; indicator_AT = ON_FACES)\n                xgrid = RGB_refine(xgrid, facemarker)\n            end\n            print(\"@time  refine =\")\n        end\n        println(\"\\t    η =  $(Resultsη[level])\\n\\t    e =  $(ResultsH1[level])\")\n    end\n\n    # plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (2, 2), clear = true, size = (1000, 1000))\n    scalarplot!(plt[1, 1], id(u), sol; levels = 7, title = \"u_h\")\n    plot_convergencehistory!(plt[1, 2], NDofs, [ResultsL2 ResultsH1 Resultsη]; add_h_powers = [order, order + 1], X_to_h = X -> order * X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n    gridplot!(plt[2, 1], xgrid; linewidth = 1)\n    gridplot!(plt[2, 2], xgrid; linewidth = 1, xlimits = [-0.0005, 0.0005], ylimits = [-0.0005, 0.0005])\n\n    # print convergence history\n    print_convergencehistory(NDofs, [ResultsL2 ResultsH1 Resultsη]; X_to_h = X -> X .^ (-1 / 2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"","category":"page"},{"location":"module_examples/Example210_LshapeAdaptivePoissonProblem/","page":"Example210_LshapeAdaptivePoissonProblem","title":"Example210_LshapeAdaptivePoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bilinearoperator/#BilinearOperator","page":"BilinearOperator","title":"BilinearOperator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluat more than the degrees of freedom on the face) there is the possibility to use BilinearOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.","category":"page"},{"location":"bilinearoperator/#Constructors","page":"BilinearOperator","title":"Constructors","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-2","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tA::AbstractMatrix,\n\tu_test,\n\tu_ansatz = u_test;\n\tkwargs...)\n\nGenerates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments utest and uansatz specify where to put the (blocks of the) matrix in the system.\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperator-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperator","text":"function BilinearOperator(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#BilinearOperatorDG","page":"BilinearOperator","title":"BilinearOperatorDG","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/bilinear_operator_dg.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\t[kernel!::Function],\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;\n\tkwargs...)\n\nGenerates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nExample: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\ncallback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing\nentities: assemble operator on these grid entities (default = ONFACES). Default: ONFACES\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: lump the operator (= only assemble the diagonal). Default: false\nname: name for operator used in printouts. Default: ''BilinearOperatorDG''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"bilinearoperator/#ExtendableFEM.BilinearOperatorDG-Tuple{Any, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}, Vector{<:Tuple{Union{Int64, Unknown}, DataType}}}","page":"BilinearOperator","title":"ExtendableFEM.BilinearOperatorDG","text":"function BilinearOperatorDG(\n\tkernel::Function,\n\toa_test::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_ansatz::Array{<:Tuple{Union{Unknown,Int}, DataType},1},\n\toa_args::Array{<:Tuple{Union{Unknown,Int}, DataType},1};\n\tkwargs...)\n\nGenerates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface\n\nkernel!(result, eval_ansatz, eval_args, qpinfo)\n\nwhere qpinfo allows to access information at the current quadrature point.\n\nOperator evaluations are tuples that pair an unknown identifier or integer with a Function operator.\n\nKeyword arguments:\n\nbonus_quadorder: additional quadrature order added to quadorder. Default: 0\nentities: assemble operator on these grid entities (default = ONCELLS). Default: ONCELLS\nentry_tolerance: threshold to add entry to sparse matrix. Default: 0\nfactor: factor that should be multiplied during assembly. Default: 1\nlump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0\nname: name for operator used in printouts. Default: ''BilinearOperator''\nparallel: assemble operator in parallel using colors/partitions information (assembles into full matrix directly). Default: false\nparallel_groups: assemble operator in parallel using CellAssemblyGroups (assembles separated matrices that are added together sequantially). Default: false\nparams: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing\nquadorder: quadrature order. Default: ''auto''\nregions: subset of regions where operator should be assembly only. Default: Any[]\nstore: store matrix separately (and copy from there when reassembly is triggered). Default: false\ntime_dependent: operator is time-dependent ?. Default: false\ntransposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0\nuse_sparsity_pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: ''auto''\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"bilinearoperator/#Examples","page":"BilinearOperator","title":"Examples","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"Below two examples illustrate some use cases.","category":"page"},{"location":"bilinearoperator/#Example-Stokes-operator","page":"BilinearOperator","title":"Example - Stokes operator","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"For the linear operator of a Stokes problem a kernel could look like","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"μ = 0.1 # viscosity parameter\nfunction kernel!(result, input, qpinfo)\n    ∇u, p = view(input,1:4), view(input, 5)\n    result[1] = μ*∇u[1] - p[1]\n    result[2] = μ*∇u[2]\n    result[3] = μ*∇u[3]\n    result[4] = μ*∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the coressponding BilinearOperator constructor call reads","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\"; name = \"velocity\")\np = Unknown(\"p\"; name = \"pressure\")\nBilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since input[5] does not couple with result[5].","category":"page"},{"location":"bilinearoperator/#Example-interior-penalty-stabilization","page":"BilinearOperator","title":"Example - interior penalty stabilization","text":"","category":"section"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"function stab_kernel!(result, input, qpinfo)\n    result .= input .* qpinfo.volume^2\nend","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"and the BilinearOperatorDG constructor call","category":"page"},{"location":"bilinearoperator/","page":"BilinearOperator","title":"BilinearOperator","text":"u = Unknown(\"u\")\nassign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))","category":"page"},{"location":"combinedofs/#CombineDofs","page":"CombineDofs","title":"CombineDofs","text":"","category":"section"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"Modules = [ExtendableFEM]\nPages = [\"common_operators/combinedofs.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"combinedofs/#ExtendableFEM.CombineDofs","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, dofsX, dofsY, factors; kwargs...)\n\nWhen assembled, the dofsX of the unknown uX will be coupled with the dofsY of uY, e.g., for periodic boundary conditions.\n\nKeyword arguments:\n\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"combinedofs/#ExtendableFEM.CombineDofs-Tuple{Any, Any, AbstractMatrix}","page":"CombineDofs","title":"ExtendableFEM.CombineDofs","text":"function CombineDofs(uX, uY, coupling_matrix::AbstractMatrix; kwargs...)\n\nInput:     uX: FEVectorBlock of the \"from\" boundary region     uY: FEVectorBlock of the \"to\" boundary region (usually the same as uX)     couplingmatrix: coupling matrix computed from `getperiodiccouplingmatrix`\n\nKeyword arguments:\n\npenalty: penalty for fixed degrees of freedom. Default: 1.0e30\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"method"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"The following function might be useful to find out the dofs the need to be coupled for periodic boundary conditions:","category":"page"},{"location":"combinedofs/","page":"CombineDofs","title":"CombineDofs","text":"get_periodic_coupling_info","category":"page"},{"location":"combinedofs/#ExtendableFEM.get_periodic_coupling_info","page":"CombineDofs","title":"ExtendableFEM.get_periodic_coupling_info","text":"function get_periodic_coupling_info(FES, xgrid, b1, b2, is_opposite::Function; factor_vectordofs = \"auto\")\n\ncomputes the dofs that have to be coupled for periodic boundary conditions on the given xgrid for boundary regions b1, b2. The isopposite function evaluates if two provided face midpoints are on opposite sides to each other (the mesh xgrid should be appropriate). For vector-valued FETypes the user can provide factorvectordofs to incorporate a sign change if needed. This is automatically done for all Hdiv-conforming elements and (for the normal-weighted face bubbles of) the Bernardi-Raugel element H1BR. \n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example201_PoissonProblem/#201-:-Poisson-Problem","page":"Example201_PoissonProblem","title":"201 : Poisson-Problem","text":"","category":"section"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"This example computes the solution u of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"with right-hand side f(xy) equiv xy and homogeneous Dirichlet boundary conditions on the unit square domain Omega on a given grid.","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"module Example201_PoissonProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing Metis\n\n# define variables\nu = Unknown(\"u\"; name = \"potential\")\n\n# define data functions\nfunction f!(fval, qpinfo)\n    fval[1] = qpinfo.x[1] * qpinfo.x[2]\n    return nothing\nend\n\nfunction main(; μ = 1.0, nrefs = 4, order = 2, Plotter = nothing, parallel = false, npart = parallel ? 8 : 1, kwargs...)\n    # problem description\n    PD = ProblemDescription()\n    assign_unknown!(PD, u)\n    assign_operator!(PD, BilinearOperator([grad(u)]; parallel = parallel, factor = μ, kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]; parallel = parallel, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n    # discretize\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n    if npart > 1\n        xgrid = partition(xgrid, PlainMetisPartitioning(npart = npart))\n    end\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # plot\n    plt = plot([id(u), grad(u)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"","category":"page"},{"location":"module_examples/Example201_PoissonProblem/","page":"Example201_PoissonProblem","title":"Example201_PoissonProblem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example103_BurgersEquation/#103-:-Burger's-Equation","page":"Example103_BurgersEquation","title":"103 : Burger's Equation","text":"","category":"section"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"This example solves the Burger's equation","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"beginaligned\nu_t - mu Delta u + mathrmdiv f(u)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"with periodic boundary conditions. This script demonstrates how a time-dependent PDE can be solved with DifferentialEquations or by a manual implicit Euler scheme.","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"The initial condition and the final solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"module Example103_BurgersEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing OrdinaryDiffEqRosenbrock\n\n# nonlinear kernel, i.e. f(u)\nfunction f!(result, input, qpinfo)\n    result[1] = input[1]^2 / 2\n    return nothing\nend\n\n# initial condition\nfunction uinit!(result, qpinfo)\n    result[1] = abs(qpinfo.x[1]) < 0.5 ? 1 : 0\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(;\n        ν = 0.01,\n        h = 0.005,\n        T = 2,\n        order = 2,\n        τ = 0.01,\n        Plotter = nothing,\n        use_diffeq = true,\n        solver = Rosenbrock23(autodiff = false),\n        kwargs...\n    )\n\n    # load mesh and exact solution\n    xgrid = simplexgrid(-2:h:2)\n\n    # generate empty PDEDescription for three unknowns (h, u)\n    PD = ProblemDescription(\"Burger's Equation\")\n    u = Unknown(\"u\"; name = \"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(f!, [grad(u)], [id(u)]; bonus_quadorder = 2))\n    assign_operator!(PD, BilinearOperator([grad(u)]; store = true, factor = ν))\n    assign_operator!(PD, CombineDofs(u, u, [1], [num_nodes(xgrid)], [1.0]; kwargs...))\n\n    # prepare solution vector and initial data\n    FES = FESpace{H1Pk{1, 1, order}}(xgrid)\n    sol = FEVector(FES; tags = PD.unknowns)\n    interpolate!(sol[u], uinit!)\n\n    # init plotter and plot u0\n    plt = plot([id(u), id(u)], sol; Plotter = Plotter, title_add = \" (t = 0)\")\n\n    # generate mass matrix\n    M = FEMatrix(FES)\n    assemble!(M, BilinearOperator([id(1)]; lump = 2))\n\n    if (use_diffeq)\n        # generate DifferentialEquations.ODEProblem\n        prob = ExtendableFEM.generate_ODEProblem(PD, FES, (0.0, T); init = sol, mass_matrix = M)\n\n        # solve ODE problem\n        de_sol = solve(prob, solver, abstol = 1.0e-6, reltol = 1.0e-3, dt = τ, dtmin = 1.0e-6, adaptive = true)\n        @info \"#tsteps = $(length(de_sol))\"\n\n        # extract final solution\n        sol.entries .= de_sol[end]\n    else\n        # add backward Euler time derivative\n        assign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n        assign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n        # generate solver configuration\n        SC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n        # iterate tspan\n        t = 0\n        for it in 1:Int(floor(T / τ))\n            t += τ\n            ExtendableFEM.solve(PD, FES, SC; time = t)\n        end\n    end\n\n    # plot final state\n    plot!(plt, [id(u)], sol; keep = 1, title_add = \" (t = $T)\")\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"","category":"page"},{"location":"module_examples/Example103_BurgersEquation/","page":"Example103_BurgersEquation","title":"Example103_BurgersEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/#250-:-Navier–Stokes-Lid-driven-cavity","page":"Example250_NSELidDrivenCavity","title":"250 : Navier–Stokes Lid-driven cavity","text":"","category":"section"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"(source code)","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"beginaligned\n- mu Delta mathbfu + left(mathbfu cdot nablaright) mathbfu+ nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"in a lid driven cavity example over a cone and plots the solution and the formed eddies.","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"(Image: )","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"module Example250_NSELidDrivenCavity\n\nusing ExtendableFEM\nusing GridVisualize\nusing ExtendableGrids\nusing LinearAlgebra\n\nfunction kernel_nonlinear!(result, u_ops, qpinfo)\n    u, ∇u, p = view(u_ops, 1:2), view(u_ops, 3:6), view(u_ops, 7)\n    μ = qpinfo.params[1]\n    result[1] = dot(u, view(∇u, 1:2))\n    result[2] = dot(u, view(∇u, 3:4))\n    result[3] = μ * ∇u[1] - p[1]\n    result[4] = μ * ∇u[2]\n    result[5] = μ * ∇u[3]\n    result[6] = μ * ∇u[4] - p[1]\n    result[7] = -(∇u[1] + ∇u[4])\n    return nothing\nend\n\nfunction boundarydata!(result, qpinfo)\n    result[1] = 1\n    result[2] = 0\n    return nothing\nend\n\nfunction initialgrid_cone()\n    xgrid = ExtendableGrid{Float64, Int32}()\n    xgrid[Coordinates] = Array{Float64, 2}([-1 0; 0 -2; 1 0]')\n    xgrid[CellNodes] = Array{Int32, 2}([1 2 3]')\n    xgrid[CellGeometries] = VectorOfConstants{ElementGeometries, Int}(Triangle2D, 1)\n    xgrid[CellRegions] = ones(Int32, 1)\n    xgrid[BFaceRegions] = Array{Int32, 1}([1, 2, 3])\n    xgrid[BFaceNodes] = Array{Int32, 2}([1 2; 2 3; 3 1]')\n    xgrid[BFaceGeometries] = VectorOfConstants{ElementGeometries, Int}(Edge1D, 3)\n    xgrid[CoordinateSystem] = Cartesian2D\n    return xgrid\nend\n\nfunction main(; μ_final = 0.0005, order = 2, nrefs = 5, Plotter = nothing, kwargs...)\n\n    # prepare parameter field\n    extra_params = Array{Float64, 1}([max(μ_final, 0.05)])\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"velocity\")\n    p = Unknown(\"p\"; name = \"pressure\")\n\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [id(u), grad(u), id(p)]; params = extra_params, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, boundarydata!; regions = 3))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 2]))\n    assign_operator!(PD, FixDofs(p; dofs = [1]))\n\n\n    # grid\n    xgrid = uniform_refine(initialgrid_cone(), nrefs)\n\n    # prepare FESpace\n    FES = [FESpace{H1Pk{2, 2, order}}(xgrid), FESpace{H1Pk{1, 2, order - 1}}(xgrid)]\n\n    # prepare plots\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, size = (1600, 800))\n\n    # solve by μ embedding\n    step = 0\n    sol = nothing\n    SC = nothing\n    PE = PointEvaluator([id(1)])\n    while (true)\n        step += 1\n        @info \"Step $step : solving for μ=$(extra_params[1])\"\n        sol, SC = ExtendableFEM.solve(PD, FES, SC; return_config = true, target_residual = 1.0e-10, maxiterations = 20, kwargs...)\n        if step == 1\n            initialize!(PE, sol)\n        end\n        scalarplot!(plt[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n        vectorplot!(plt[1, 1], xgrid, eval_func_bary(PE), rasterpoints = 20, clear = false)\n        streamplot!(plt[1, 2], xgrid, eval_func_bary(PE), rasterpoints = 50, density = 2, title = \"streamlines\")\n\n        if extra_params[1] <= μ_final\n            break\n        else\n            extra_params[1] = max(μ_final, extra_params[1] / 2)\n        end\n    end\n\n    scalarplot!(plt[1, 1], xgrid, nodevalues(sol[1]; abs = true)[1, :]; title = \"velocity (μ = $(extra_params[1]))\", Plotter = Plotter)\n    vectorplot!(plt[1, 1], xgrid, eval_func_bary(PE), rasterpoints = 20, clear = false)\n    streamplot!(plt[1, 2], xgrid, eval_func_bary(PE), rasterpoints = 50, density = 2, title = \"streamlines\")\n\n    return sol, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"","category":"page"},{"location":"module_examples/Example250_NSELidDrivenCavity/","page":"Example250_NSELidDrivenCavity","title":"Example250_NSELidDrivenCavity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/#105-:-Nonlinear-Poisson-Equation","page":"Example105_NonlinearPoissonEquation","title":"105 : Nonlinear Poisson Equation","text":"","category":"section"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"(source code)","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"This examples solves the nonlinear Poisson problem","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"beginaligned\n- epsilon partial^2 u  partial x^2 + e^u - e^-u  = f  textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"where","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"f(x) = begincases\n1  x geq 05\n-1  x  05\nendcases","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"on the domain Omega = (01) with Dirichlet boundary conditions u(0) = 0 and u(1) = 1.","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"(Image: )","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"module Example105_NonlinearPoissonEquation\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# rigt-hand side data\nfunction f!(result, qpinfo)\n    result[1] = qpinfo.x[1] < 0.5 ? -1 : 1\n    return nothing\nend\n# boundary data\nfunction boundary_data!(result, qpinfo)\n    result[1] = qpinfo.x[1]\n    return nothing\nend\n\n# kernel for the (nonlinear) reaction-convection-diffusion operator\nfunction nonlinear_kernel!(result, input, qpinfo)\n    u, ∇u, ϵ = input[1], input[2], qpinfo.params[1]\n    result[1] = exp(u) - exp(-u)\n    result[2] = ϵ * ∇u\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, h = 1.0e-2, ϵ = 1.0e-3, order = 2, kwargs...)\n\n    # problem description\n    PD = ProblemDescription(\"Nonlinear Poisson Equation\")\n    u = Unknown(\"u\"; name = \"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(nonlinear_kernel!, [id(u), grad(u)]; params = [ϵ], kwargs...))\n    assign_operator!(PD, LinearOperator(f!, [id(u)]; store = true, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, boundary_data!; kwargs...))\n\n    # discretize: grid + FE space\n    xgrid = simplexgrid(0:h:1)\n    FES = FESpace{H1Pk{1, 1, order}}(xgrid)\n\n    # generate a solution vector and solve\n    sol = solve(PD, FES; kwargs...)\n\n    # plot discrete and exact solution (on finer grid)\n    plt = plot([id(u)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"","category":"page"},{"location":"module_examples/Example105_NonlinearPoissonEquation/","page":"Example105_NonlinearPoissonEquation","title":"Example105_NonlinearPoissonEquation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Exported","page":"Index","title":"Exported","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"ExtendableFEM","category":"page"},{"location":"allindex/#ExtendableFEM","page":"Index","title":"ExtendableFEM","text":"ExtendableFEM\n\n(Image: Build status) (Image: ) (Image: ) (Image: DOI) (Image: code style: runic)\n\nExtendableFEM\n\nHigh Level API Finite Element Methods based on ExtendableGrids.jl (for grid management) and ExtendableFEMBase.jl (for finite element basis functions and dof management).  It offers a ProblemDescription interface, that basically involves assigning Unknowns and Operators. Such operators usually stem from a weak formulation of the problem and mainly consist of three types that can be customized via kernel functions:\n\nBilinearOperator,\nLinearOperator,\nNonlinearOperator (that automatically assemble Newton's method by automatic differentiation)\n\nQuick Example\n\nThe following minimal example demonstrates how to setup a Poisson problem.\n\nusing ExtendableFEM\nusing ExtendableGrids\n\n# build/load any grid (here: a uniform-refined 2D unit square into triangles)\nxgrid = uniform_refine(grid_unitsquare(Triangle2D), 4)\n\n# create empty PDE description\nPD = ProblemDescription()\n\n# create and assign unknown\nu = Unknown(\"u\"; name = \"potential\")\nassign_unknown!(PD, u)\n\n# assign Laplace operator\nassign_operator!(PD, BilinearOperator([grad(u)]; factor = 1e-3))\n\n# assign right-hand side data\nfunction f!(fval, qpinfo)\n    x = qpinfo.x # global coordinates of quadrature point\n    fval[1] = x[1] * x[2]\nend\nassign_operator!(PD, LinearOperator(f!, [id(u)]))\n\n# assign boundary data (here: u = 0)\nassign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4))\n\n# discretise = choose FESpace\nFEType = H1Pk{1,2,3} # cubic H1-conforming element with 1 component in 2D\nFES = FESpace{FEType}(xgrid)\n\n# solve\nsol = solve!(Problem, [FES])\n\n# plot\nusing PyPlot\nplot(id(u), sol; Plotter = PyPlot)\n\n\n\n\n\n","category":"module"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [ExtendableFEM]\nOrder=[:function]","category":"page"},{"location":"problemdescription/#Problem-Description","page":"Problem Description","title":"Problem Description","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Central object is the ProblemDescription which is given as a weak form of your problem and usually does not need any information on the discretisation at this point (but of course can depend on region numbers).","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"ProblemDescription","category":"page"},{"location":"problemdescription/#ExtendableFEM.ProblemDescription","page":"Problem Description","title":"ExtendableFEM.ProblemDescription","text":"struct ProblemDescription\n\nStructure holding data for a problem description with the following fields:\n\nname::String: The name of the problem used for printout messages. Default: \"My Problem\"\n\nunknowns::Vector{Unknown}: A vector of Unknowns that are involved in the problem.\n\noperators::Vector{ExtendableFEM.AbstractOperator}: A vector of operators that are involved in the problem.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#Constructors-and-assign-functions","page":"Problem Description","title":"Constructors and assign functions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"problemdescription.jl\"]\nOrder   = [:function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.assign_operator!-Tuple{ProblemDescription, ExtendableFEM.AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.assign_operator!","text":"assign_operator!(PD::ProblemDescription, o::AbstractOperator)\n\nAssigns the AbstractOperator o to the ProblemDescription PD and returns its position in the operators array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.assign_unknown!-Tuple{ProblemDescription, Unknown}","page":"Problem Description","title":"ExtendableFEM.assign_unknown!","text":"assign_unknown!(PD::ProblemDescription, u::Unknown)\n\nAssigns the Unknown u to the ProblemDescription PD and returns its position in the unknowns array of the ProblemDescription.\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.replace_operator!-Tuple{ProblemDescription, Any, ExtendableFEM.AbstractOperator}","page":"Problem Description","title":"ExtendableFEM.replace_operator!","text":"replace_operator!(PD::ProblemDescription, j::Int, o::AbstractOperator)\n\nReplaces the j-th operator of the ProblemDescription PD by the new operator o. Here, j is the position in operator array returned by the assign_operator! function. Nothing is returned (as the new operator gets position j).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Unknowns","page":"Problem Description","title":"Unknowns","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"An Unknown is an identifies that encodes a physical quantity in the ProblemDescription.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"unknowns.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Unknown","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"struct Unknown\n\nStructure holding information for an unknown with the following fields:\n\nname::String: The name of the unknown used for printout messages.\n\nidentifier::Any: The identifier of the unknown used for assignments to operators.\n\nparameters::Dict{Symbol, Any}: Further properties of the unknown can be stored in a Dict, see constructor.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Unknown-Tuple{String}","page":"Problem Description","title":"ExtendableFEM.Unknown","text":"function Unknown(\n\tu::String;\n\tidentifier = Symbol(u),\n\tname = u,\n\tkwargs...)\n\nGenerates and returns an Unknown with the specified name, identifier and other traits.\n\nExample: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.\n\nKeyword arguments:\n\nalgebraic_constraint: is this unknown an algebraic constraint?. Default: nothing\ndimension: dimension of the unknown. Default: nothing\nsymbol_ansatz: symbol for ansatz functions of this unknown in printouts. Default: nothing\nsymbol_test: symbol for test functions of this unknown in printouts. Default: nothing\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Base.div-Tuple{Any}","page":"Problem Description","title":"Base.div","text":"div(u)\n\nalias for (u, Divergence)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.apply-Tuple{Any, Type{<:??}}","page":"Problem Description","title":"ExtendableFEM.apply","text":"apply(u, FO::Type{<:AbstractFunctionOperator})\n\nalias for (u, FO)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.average-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.average","text":"average(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Average{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl1-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl1","text":"curl1(u)\n\nalias for (u, CurlScalar)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl2-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl2","text":"curl2(u)\n\nalias for (u, Curl2D)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.curl3-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.curl3","text":"curl3(u)\n\nalias for (u, Curl3D)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.dofgrid-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.dofgrid","text":"dofgrid(u)\n\nalias for (u, \"dofgrid\") (triggers gridplot for the dofgrid in plot)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.grad-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.grad","text":"grad(u)\n\nalias for (u, Gradient)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.grid-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.grid","text":"grid(u)\n\nalias for (u, \"grid\") (triggers gridplot in plot)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.hessian-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.hessian","text":"hessian(u)\n\nalias for (u, Hessian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.id-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.id","text":"id(u)\n\nalias for (u, Identity)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.jump-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.jump","text":"jump(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Jump{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.laplace-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.laplace","text":"laplace(u)\n\nalias for (u, Laplacian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.normalflux-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.normalflux","text":"normalflux(u)\n\nalias for (u, NormalFlux)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.other-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.other","text":"other(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Right{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.symgrad_voigt-Tuple{Any, Any}","page":"Problem Description","title":"ExtendableFEM.symgrad_voigt","text":"symgrad_voigt(u, factor)\n\nalias for (u, SymmetricGradient{factor}) in Voigt notation.\n\nThe factor is a real number applied to the (summed) off-diagonal entries. In the current implementation in ExtendableFEMBase, factor = 0.5 represents the Voigt strain mapping [σ₁₁ σ₂₂ σ₃₃ σ₁₃ σ₂₃ σ₁₂], while factor = 1.0 represents the Voigt strain mapping [ε₁₁ ε₂₂ ε₃₃ 2ε₁₃ 2ε₂₃ 2ε₁₂].\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.tangentialflux-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.tangentialflux","text":"tangentialflux(u)\n\nalias for (u, TangentFlux)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.tangentialgrad-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.tangentialgrad","text":"tangentialgrad(u)\n\nalias for (u, TangentialGradient)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.this-Tuple{Tuple{Union{Int64, Unknown}, DataType}}","page":"Problem Description","title":"ExtendableFEM.this","text":"this(o:Tuple{Union{Unknown, Int}, StandardFunctionOperator})\n\nalias for (o[1], Left{o[2]})\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.Δ-Tuple{Any}","page":"Problem Description","title":"ExtendableFEM.Δ","text":"Δ(u)\n\nalias for (u, Laplacian)\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#ExtendableFEM.εV-Tuple{Any, Any}","page":"Problem Description","title":"ExtendableFEM.εV","text":"εV(u, factor)\n\nunicode alias for symgrad_voigt(u, factor).\n\n\n\n\n\n","category":"method"},{"location":"problemdescription/#Operators","page":"Problem Description","title":"Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Operator is a quite general concept and is everything that makes modifications to the system matrix, hence classical representations of weak discretisations of differential operators, penalisations for boundary conditions or constraints, or stabilisation terms.","category":"page"},{"location":"problemdescription/#Types-of-operators","page":"Problem Description","title":"Types of operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The three most important operator classes are:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"NonlinearOperator (e.g. the convection term in a Navier-Stokes problem)\nBilinearOperator (e.g. the Laplacian in a Poisson problem)\nLinearOperator (e.g. the right-hand side in a Poisson or Navier-Stokes problem)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"To assign boundary conditions or global constraints there are three possibilities:","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"InterpolateBoundaryData\nHomogeneousData\nFixDofs\nCombineDofs","category":"page"},{"location":"problemdescription/#Entities-and-Regions","page":"Problem Description","title":"Entities and Regions","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Each operator assembles on certain entities of the mesh, the default is a cell-wise assembly. Most operators have the entities kwarg to changes that. Restrictions to subsets of the entities can be made via the regions kwarg.","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Entities Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate on the cells of the mesh\nON_FACES assemble/interpolate on all faces of the mesh\nON_IFACES assemble/interpolate on the interior faces of the mesh\nON_BFACES assemble/interpolate on the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate on all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate on the boundary edges of the mesh (in 3D)","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"problemdescription/#Function-Operators","page":"Problem Description","title":"Function Operators","text":"","category":"section"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"The definition of operators often involves paris of an Unknown and a FunctionOperator (or an alias as listed above). FunctionOperators are something like Identity, Gradient etc. (see here for a complete list). Additional FunctionOperators for the evaluation of discontinuous operators on faces available (needed in particular for defining operators in  DG context or face terms in a posteriori error estimators):","category":"page"},{"location":"problemdescription/","page":"Problem Description","title":"Problem Description","text":"Modules = [ExtendableFEM]\nPages = [\"jump_operators.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"problemdescription/#ExtendableFEM.Average","page":"Problem Description","title":"ExtendableFEM.Average","text":"Average{StandardFunctionOperator}\n\nevaluates the average of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.DiscontinuousFunctionOperator","page":"Problem Description","title":"ExtendableFEM.DiscontinuousFunctionOperator","text":"DiscontinuousFunctionOperator\n\nSubtype of AbstractFunctionOperator dedicated to evaluations of discontinuous quantities on faces like jumps, averages etc.\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Jump","page":"Problem Description","title":"ExtendableFEM.Jump","text":"Jump{StandardFunctionOperator}\n\nevaluates the jump of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Left","page":"Problem Description","title":"ExtendableFEM.Left","text":"Left{StandardFunctionOperator}\n\nevaluates the left (w.r.t. orientation of the face) value of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"problemdescription/#ExtendableFEM.Right","page":"Problem Description","title":"ExtendableFEM.Right","text":"Average{StandardFunctionOperator}\n\nevaluates the right (w.r.t. orientation of the face) value of a StandardFunctionOperator\n\n\n\n\n\n","category":"type"},{"location":"module_examples/Example106_NonlinearDiffusion/#106-:-Nonlinear-Diffusion","page":"Example106_NonlinearDiffusion","title":"106 : Nonlinear Diffusion","text":"","category":"section"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"(source code)","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"This example solves the nonlinear diffusion equation","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"beginaligned\nu_t - Delta u^m  = 0\nendaligned","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"in Omega = (-11) with homogeneous Neumann boundary conditions.","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"The solution looks like this:","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"(Image: )","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"module Example106_NonlinearDiffusion\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing OrdinaryDiffEqSDIRK\nusing GridVisualize\n\n# Barenblatt solution\n# (see Barenblatt, G. I. \"On nonsteady motions of gas and fluid in porous medium.\" Appl. Math. and Mech.(PMM) 16.1 (1952): 67-78.)\nfunction u_exact!(result, qpinfo)\n    t = qpinfo.time\n    x = qpinfo.x[1]\n    m = qpinfo.params[1]\n    tx = t^(-1.0 / (m + 1.0))\n    xx = x * tx\n    xx = xx * xx\n    xx = 1 - xx * (m - 1) / (2.0 * m * (m + 1))\n    if xx < 0.0\n        xx = 0.0\n    end\n    result[1] = tx * xx^(1.0 / (m - 1.0))\n    return nothing\nend\n\nfunction kernel_nonlinear!(result, input, qpinfo)\n    u, ∇u = input[1], input[2]\n    m = qpinfo.params[1]\n    result[1] = m * u^(m - 1) * ∇u\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(;\n        m = 2,\n        h = 0.05,\n        t0 = 0.001,\n        T = 0.01,\n        order = 1,\n        τ = 0.0001,\n        Plotter = nothing,\n        use_diffeq = true,\n        use_masslumping = true,\n        solver = ImplicitEuler(autodiff = false),\n        kwargs...\n    )\n\n    # load mesh and exact solution\n    xgrid = simplexgrid(-1:h:1)\n\n    # set finite element types [surface height, velocity]\n    FEType = H1Pk{1, 1, order}\n\n    # generate empty PDEDescription for three unknowns (h, u)\n    PD = ProblemDescription(\"Nonlinear Diffusion Equation\")\n    u = Unknown(\"u\"; name = \"u\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(kernel_nonlinear!, [grad(u)], [id(u), grad(u)]; params = [m], bonus_quadorder = 2))\n\n    # prepare solution vector and initial data\n    FES = FESpace{FEType}(xgrid)\n    sol = FEVector(FES; tags = PD.unknowns)\n    interpolate!(sol[u], u_exact!; time = t0, params = [m])\n\n    # init plotter and plot u0\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), size = (800, 400))\n    scalarplot!(plt[1, 1], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1, title = \"t = $t0\")\n\n    # generate mass matrix (with mass lumping)\n    M = FEMatrix(FES)\n    assemble!(M, BilinearOperator([id(1)]; lump = 2 * use_masslumping))\n\n    if (use_diffeq)\n        # generate ODE problem\n        prob = ExtendableFEM.generate_ODEProblem(PD, FES, (t0, T); init = sol, mass_matrix = M.entries.cscmatrix)\n\n        # solve ODE problem\n        de_sol = solve(prob, solver, abstol = 1.0e-6, reltol = 1.0e-3, dt = τ, dtmin = 1.0e-8, adaptive = true)\n        @info \"#tsteps = $(length(de_sol))\"\n\n        # get final solution\n        sol.entries .= de_sol[end]\n    else\n        # add backward Euler time derivative\n        assign_operator!(PD, BilinearOperator(M, [u]; factor = 1 / τ, kwargs...))\n        assign_operator!(PD, LinearOperator(M, [u], [u]; factor = 1 / τ, kwargs...))\n\n        # generate solver configuration\n        SC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, kwargs...)\n\n        # iterate tspan\n        t = 0\n        for it in 1:Int(floor((T - t0) / τ))\n            t += τ\n            ExtendableFEM.solve(PD, FES, SC; time = t)\n        end\n    end\n\n    # plot final state and exact solution for comparison\n    scalarplot!(plt[1, 2], id(u), sol; label = \"u_h\", markershape = :circle, markevery = 1)\n    interpolate!(sol[1], u_exact!; time = T, params = [m])\n    scalarplot!(plt[1, 2], id(u), sol; clear = false, color = :green, label = \"u\", title = \"t = $T\", legend = :best)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"","category":"page"},{"location":"module_examples/Example106_NonlinearDiffusion/","page":"Example106_NonlinearDiffusion","title":"Example106_NonlinearDiffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/#275-:-Optimal-Control-Stokes","page":"Example275_OptimalControlStokes","title":"275 : Optimal Control Stokes","text":"","category":"section"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"(source code)","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This example studies the optimal control problem for the Stokes operator with divergence-free velocity space mathbfV_0 subset mathbfH^1_0, i.e., for given data mathbfu^d minimize the functional","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"beginaligned\nmin_(mathbfumathbfq) in mathbfV_0 times mathbfL^2  mathbfu - mathbfu^d ^2 + fracalpha2  mathbfq ^2\nquad textst  (mu nabla mathbfu nabla mathbfv) = (mathbfq mathbfv) quad textfor all  mathbfv in mathbfV_0\nendaligned","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This results in the set of variational equations that seeks (mathbfu mathbfz p  lambda) such that","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"beginaligned\n(mu nabla mathbfu nabla mathbfv) + (p mathrmdiv mathbfv)  = - alpha^-12 (mathbfz mathbfv)\n                                             (q mathrmdiv mathbfu)  = 0\n(mu nabla mathbfz nabla mathbfw) + (λ mathrmdiv mathbfw)  = alpha^-12 (mathbfu - mathbfu^d mathbfw)\n                                             (φ mathrmdiv mathbfz)  = 0\nendaligned","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"for all test functions (mathbfv mathbfw q  varphi).","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"Here, we study pressure-robustness with the given data","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"mathbfu^d = mathrmcurl left(x^4y^4(x-1)^4(y-1)^4right) + epsilon nabla(cos(x)sin(y))","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"with a gradient field distortion that can be steered by ϵ geq 0 which was an example in the reference below.","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"reference: Reference\n\"Pressure-robustness in the context of optimal control\",\nC. Merdon and W. Wollner,\nSIAM Journal on Control and Optimization 61:1, 342-360 (2023),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"(Image: )","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"module Example275_OptimalControlStokes\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Symbolics\n\nfunction prepare_data!(; ϵ = 0)\n    @variables x y\n\n    # stream function ξ\n    ξ = x^4 * y^4 * (x - 1)^4 * (y - 1)^4\n    ∇ξ = Symbolics.gradient(ξ, [x, y])\n\n    # irrotational perturbation (to study pressure-robustness)\n    ϕ = cos(x) * sin(y)\n    ∇ϕ = Symbolics.gradient(ϕ, [x, y])\n\n    # final data = curl ξ + ϵ ∇ϕ\n    d = [-∇ξ[2], ∇ξ[1]] + ϵ * ∇ϕ\n    d_eval = build_function(d, x, y, expression = Val{false})\n\n    return d_eval[2]\nend\n\n# standard Stokes kernel\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops, 1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ * ∇u[1] + p[1]\n    result[2] = μ * ∇u[2]\n    result[3] = μ * ∇u[3]\n    result[4] = μ * ∇u[4] + p[1]\n    result[5] = (∇u[1] + ∇u[4])\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, μ = 1, α = 1.0e-6, ϵ = 0, kwargs...)\n\n    # prepare target data\n    d_eval = prepare_data!(; ϵ = ϵ)\n    data!(result, qpinfo) = (d_eval(result, qpinfo.x[1], qpinfo.x[2]);)\n\n    # load mesh and refine\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nrefs)\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    z = Unknown(\"z\"; name = \"control\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    λ = Unknown(\"λ\"; name = \"control pressure\", dim = 1)\n\n    # prepare reconstruction operator (if reconstruct = true)\n    idR(u) = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define optimal control problem\n    PD = ProblemDescription(\"Stokes optimal control problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, z)\n    assign_unknown!(PD, p)\n    assign_unknown!(PD, λ)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(z), id(λ)]; params = [μ], kwargs...))\n    assign_operator!(PD, BilinearOperator([idR(z)], [idR(u)]; factor = -1 / sqrt(α), transposed_copy = -1, kwargs...))\n    assign_operator!(PD, LinearOperator(data!, [idR(z)]; factor = -1 / sqrt(α), bonus_quadorder = 5, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = 1:4, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(z; regions = 1:4, kwargs...))\n\n    # solve with Bernardi--Raugel method\n    FETypes = [H1BR{2}, L2P0{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j in 1:2]\n    sol = solve(PD, [FES[1], FES[1], FES[2], FES[2]]; kwargs...)\n\n    # plot solution\n    plt = plot([id(u), id(p), id(z), id(λ)], sol; add = 1, Plotter = Plotter)\n\n    # plot target data\n    I = FEVector(FES[1]; name = \"u^d\")\n    interpolate!(I[1], data!)\n    plot!(plt, [id(1)], I; keep = 1:4)\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"","category":"page"},{"location":"module_examples/Example275_OptimalControlStokes/","page":"Example275_OptimalControlStokes","title":"Example275_OptimalControlStokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)\nprinted assembly and solving times (especially in a first iteration) can be much larger due to first-run compilation times, the printouts in the documentation are taken from a second run after compilations are done","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, perform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/#230-:-Nonlinear-Elasticity","page":"Example230_NonlinearElasticity","title":"230 : Nonlinear Elasticity","text":"","category":"section"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"(source code)","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This example computes the displacement field u of the nonlinear elasticity problem","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"beginaligned\n-mathrmdiv(mathbbC (epsilon(u)-epsilon_T))  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"where an isotropic stress tensor mathbbC is applied to the nonlinear strain epsilon(u) = frac12(nabla u + (nabla u)^T + (nabla u)^T nabla u) and a misfit strain  epsilon_T = Delta T alpha due to thermal load caused by temperature(s) Delta T and thermal expansion coefficients alpha (that may be different) in the two regions of the bimetal.","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This example demonstrates how to setup a (parameter- and region-dependent) nonlinear expression and how to assign it to the problem description.","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"(Image: )","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"module Example230_NonlinearElasticity\n\nusing ExtendableFEM\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing GridVisualize\nusing UnicodePlots\n\n# parameter-dependent nonlinear operator uses a callable struct to reduce allocations\nmutable struct nonlinear_operator{T}\n    λ::Vector{T}\n    μ::Vector{T}\n    ϵT::Vector{T}\nend\n\nfunction strain!(result, input)\n    result[1] = input[1]\n    result[2] = input[4]\n    result[3] = input[2] + input[3]\n\n    # add nonlinear part of the strain 1/2 * (grad(u)'*grad(u))\n    result[1] += 1 // 2 * (input[1]^2 + input[3]^2)\n    result[2] += 1 // 2 * (input[2]^2 + input[4]^2)\n    result[3] += input[1] * input[2] + input[3] * input[4]\n    return nothing\nend\n\n# kernel for nonlinear operator\n(op::nonlinear_operator)(result, input, qpinfo) = (\n    # input = grad(u) written as a vector\n    # compute strain and subtract thermal strain (all in Voigt notation)\n    region = qpinfo.region;\n    strain!(result, input);\n    result[1] -= op.ϵT[region];\n    result[2] -= op.ϵT[region];\n\n    # multiply with isotropic stress tensor\n    # (stored in input[5:7] using Voigt notation)\n    a = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[1];\n    b = op.λ[region] * (result[1] + result[2]) + 2 * op.μ[region] * result[2];\n    c = 2 * op.μ[region] * result[3];\n\n    # write strain into result\n    result[1] = a;\n    result[2] = c;\n    result[3] = c;\n    result[4] = b;\n    return nothing\n)\n\nconst op = nonlinear_operator([0.0, 0.0], [0.0, 0.0], [0.0, 0.0])\n\n# everything is wrapped in a main function\nfunction main(;\n        ν = [0.3, 0.3],          # Poisson number for each region/material\n        E = [2.1, 1.1],          # Elasticity modulus for each region/material\n        ΔT = [580, 580],         # temperature for each region/material\n        α = [1.3e-5, 2.4e-4],    # thermal expansion coefficients\n        scale = [20, 500],       # scale of the bimetal, i.e. [thickness, width]\n        nrefs = 0,              # refinement levels\n        order = 2,              # finite element order\n        periodic = false,       # use periodic boundary conditions?\n        Plotter = nothing,\n        kwargs...\n    )\n\n    # compute Lame' coefficients μ and λ from ν and E\n    # and thermal misfit strain and assign to operator operator\n    @. op.μ = E / (2 * (1 + ν))\n    @. op.λ = E * ν / ((1 - 2 * ν) * (1 + ν))\n    @. op.ϵT = ΔT * α\n\n    # generate bimetal mesh\n    xgrid = bimetal_strip2D(; scale = scale, n = 2 * (nrefs + 1))\n    println(stdout, unicode_gridplot(xgrid))\n\n    # create finite element space and solution vector\n    FES = FESpace{H1Pk{2, 2, order}}(xgrid)\n\n    # problem description\n    PD = ProblemDescription()\n    u = Unknown(\"u\"; name = \"displacement\")\n    assign_unknown!(PD, u)\n    assign_operator!(PD, NonlinearOperator(op, [grad(u)]; kwargs...))\n    if periodic\n        # periodic boundary conditions\n        # 1) couple dofs left (bregion 1) and right (bregion 3) in y-direction\n        function give_opposite!(y, x)\n            y .= x\n            y[1] = -x[1]\n            return nothing\n        end\n        coupling_matrix = get_periodic_coupling_matrix(FES, xgrid, 1, 3, give_opposite!; mask = [0, 1])\n        assign_operator!(PD, CombineDofs(u, u, coupling_matrix; kwargs...))\n\n        # 2) find and fix point at [0, scale[1]]\n        xCoordinates = xgrid[Coordinates]\n        closest::Int = 0\n        mindist::Float64 = 1.0e30\n        for j in 1:num_nodes(xgrid)\n            dist = xCoordinates[1, j]^2 + (xCoordinates[2, j] - scale[1])^2\n            if dist < mindist\n                mindist = dist\n                closest = j\n            end\n        end\n        assign_operator!(PD, FixDofs(u; dofs = [closest], vals = [0]))\n    else\n        assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1], mask = [1, 0], kwargs...))\n    end\n\n    # solve\n    sol = solve(PD, FES; kwargs...)\n\n    # displace mesh and plot\n    plt = GridVisualizer(; Plotter = Plotter, layout = (3, 1), clear = true, size = (1000, 1500))\n    grad_nodevals = nodevalues(grad(u), sol)\n    strain_nodevals = zeros(Float64, 3, num_nodes(xgrid))\n    for j in 1:num_nodes(xgrid)\n        strain!(view(strain_nodevals, :, j), view(grad_nodevals, :, j))\n    end\n    scalarplot!(plt[1, 1], xgrid, view(strain_nodevals, 1, :), levels = 3, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_xx + displacement\")\n    scalarplot!(plt[2, 1], xgrid, view(strain_nodevals, 2, :), levels = 1, colorbarticks = 7, xlimits = [-scale[2] / 2 - 10, scale[2] / 2 + 10], ylimits = [-30, scale[1] + 20], title = \"ϵ(u)_yy + displacement\")\n    vectorplot!(plt[1, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), rasterpoints = 20, clear = false)\n    vectorplot!(plt[2, 1], xgrid, eval_func_bary(PointEvaluator([id(u)], sol)), rasterpoints = 20, clear = false)\n    displace_mesh!(xgrid, sol[u])\n    gridplot!(plt[3, 1], xgrid, linewidth = 1, title = \"displaced mesh\")\n    println(stdout, unicode_gridplot(xgrid))\n\n    return strain_nodevals, plt\nend\n\n# grid\nfunction bimetal_strip2D(; scale = [1, 1], n = 2, anisotropy_factor::Int = Int(ceil(scale[2] / (2 * scale[1]))))\n    X = linspace(-scale[2] / 2, 0, (n + 1) * anisotropy_factor)\n    X2 = linspace(0, scale[2] / 2, (n + 1) * anisotropy_factor)\n    append!(X, X2[2:end])\n    Y = linspace(0, scale[1], 2 * n + 1)\n    xgrid = simplexgrid(X, Y)\n    cellmask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, scale[1] / 2], 1)\n    cellmask!(xgrid, [-scale[2] / 2, scale[1] / 2], [scale[2] / 2, scale[1]], 2)\n    bfacemask!(xgrid, [-scale[2] / 2, 0.0], [-scale[2] / 2, scale[1] / 2], 1)\n    bfacemask!(xgrid, [-scale[2] / 2, scale[1] / 2], [-scale[2] / 2, scale[1]], 1)\n    bfacemask!(xgrid, [-scale[2] / 2, 0.0], [scale[2] / 2, 0.0], 2)\n    bfacemask!(xgrid, [-scale[2] / 2, scale[1]], [scale[2] / 2, scale[1]], 2)\n    bfacemask!(xgrid, [scale[2] / 2, 0.0], [scale[2] / 2, scale[1]], 3)\n    return xgrid\nend\n\n\n\nend","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"","category":"page"},{"location":"module_examples/Example230_NonlinearElasticity/","page":"Example230_NonlinearElasticity","title":"Example230_NonlinearElasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/#284-:-Level-Set-Method","page":"Example284_LevelSetMethod","title":"284 : Level Set Method","text":"","category":"section"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"(source code)","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"This example studies the level-set method of some level function mathbfphi convected in time via the equation","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"beginaligned\nphi_t + mathbfu cdot nabla phi  = 0\nendaligned","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"Here this is tested with the (conservative) initial level set function phi(x) = 05 tanh((lvert x - (05075) rvert - 015)(2ϵ) + 1) such that the level phi equiv 05 forms a circle which is then convected by the velocity mathbfu = mathrmcurl pi^-1 sin^2(pi x) sin^2(pi y). No reinitialisation step is performed.","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"The initial condition and the solution at T = 1 for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"(Image: )","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"module Example284_LevelSetMethod\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\nusing OrdinaryDiffEqSDIRK\n\nfunction ϕ_init!(result, qpinfo)\n    x = qpinfo.x\n    ϵ = qpinfo.params[1]\n    result[1] = 1 / 2 * (tanh((sqrt((x[1] - 0.5)^2 + (x[2] - 0.75)^2) - 0.15) / (2 * ϵ)) + 1)\n    return nothing\nend\n\nfunction velocity!(result, qpinfo)\n    result[1] = 0.5\n    result[2] = 1.0\n    result[1] = -2 * cos(π * qpinfo.x[2]) * sin(π * qpinfo.x[2]) * sin(π * qpinfo.x[1])^2\n    result[2] = 2 * cos(π * qpinfo.x[1]) * sin(π * qpinfo.x[1]) * sin(π * qpinfo.x[2])^2\n    return nothing\nend\n\n\nfunction kernel_convection!()\n    u = zeros(Float64, 2)\n    return function closure(result, input, qpinfo)\n        velocity!(u, qpinfo)\n        result[1] = dot(u, input)\n        return nothing\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(;\n        Plotter = nothing, ϵ = 0.05, τ = 1.0e-2, T = 1.0, order = 2, nref = 6, use_diffeq = false,\n        solver = ImplicitEuler(autodiff = false), verbosity = -1, kwargs...\n    )\n\n    # initial grid and final time\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), nref)\n\n    # define main level set problem\n    PD = ProblemDescription(\"level set problem\")\n    ϕ = Unknown(\"ϕ\"; name = \"level set function\")\n    assign_unknown!(PD, ϕ)\n    assign_operator!(PD, BilinearOperator(kernel_convection!(), [id(ϕ)], [grad(ϕ)]; kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(ϕ; value = 1, regions = 1:4, kwargs...))\n\n    # generate FESpace and solution vector and interpolate initial state\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n    sol = FEVector(FES; tags = PD.unknowns)\n    interpolate!(sol[ϕ], ϕ_init!; params = [ϵ])\n\n    # prepare plot and plot init solution\n    plt = GridVisualizer(; Plotter = Plotter, layout = (1, 2), clear = true, resolution = (800, 400))\n    scalarplot!(plt[1, 1], id(ϕ), sol; levels = [0.5], flimits = [-0.05, 1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = 0)\")\n\n    if (use_diffeq)\n        # generate DifferentialEquations.ODEProblem\n        prob = generate_ODEProblem(PD, FES, (0.0, T); init = sol, constant_matrix = true)\n\n        # solve ODE problem\n        de_sol = DifferentialEquations.solve(prob, solver, abstol = 1.0e-6, reltol = 1.0e-4, dt = τ, dtmin = 1.0e-8, adaptive = true)\n        @info \"#tsteps = $(length(de_sol))\"\n\n        # get final solution\n        sol.entries .= de_sol[end]\n    else\n        # add backward Euler time derivative\n        M = FEMatrix(FES)\n        assemble!(M, BilinearOperator([id(1)]))\n        assign_operator!(PD, BilinearOperator(M, [ϕ]; factor = 1 / τ, kwargs...))\n        assign_operator!(PD, LinearOperator(M, [ϕ], [ϕ]; factor = 1 / τ, kwargs...))\n\n        # generate solver configuration\n        SC = SolverConfiguration(PD, FES; init = sol, maxiterations = 1, constant_matrix = true, verbosity = verbosity, kwargs...)\n\n        # iterate tspan\n        t = 0\n        for it in 1:Int(floor(T / τ))\n            t += τ\n            ExtendableFEM.solve(PD, FES, SC; time = t)\n            #scalarplot!(plt[1, 2], id(ϕ), sol; levels = [0.5], flimits = [-0.05, 1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = $t)\")\n        end\n    end\n\n    # plot final state\n    scalarplot!(plt[1, 2], id(ϕ), sol; levels = [0.5], flimits = [-0.05, 1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = $T)\")\n\n    return sol, plt\nend\n\nend","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"","category":"page"},{"location":"module_examples/Example284_LevelSetMethod/","page":"Example284_LevelSetMethod","title":"Example284_LevelSetMethod","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdesolvers/#Stationary-Solvers","page":"Stationary Solvers","title":"Stationary Solvers","text":"","category":"section"},{"location":"pdesolvers/#Meshes-and-FESpaces","page":"Stationary Solvers","title":"Meshes and FESpaces","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Meshes are expected in the form of an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl. There is also an extension to read meshes from gmsh files.","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"FESpace{FEType}(grid::ExtendableGrid)","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"Here, FEType denotes the type of finite element. A list of available FETypes can be found in the Documentation of ExtendableFEMBase.jl.","category":"page"},{"location":"pdesolvers/#Solve-(monolithic)","page":"Stationary Solvers","title":"Solve (monolithic)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. ","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"solve\nresidual","category":"page"},{"location":"pdesolvers/#CommonSolve.solve","page":"Stationary Solvers","title":"CommonSolve.solve","text":"function solve(\n\tPD::ProblemDescription,\n\t[FES::Union{<:FESpace,Vector{<:FESpace}}],\n\tSC = nothing;\n\tunknowns = PD.unknowns,\n\tkwargs...)\n\nReturns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nThis function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.\n\nKeyword arguments:\n\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\nprecon_linear: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_config: show configuration at the beginning of solve. Default: false\nshow_matrix: show system matrix after assembly. Default: false\nspy: show unicode spy plot of system matrix during solve. Default: false\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\ntime: current time to be used in all time-dependent operators. Default: 0.0\nverbosity: verbosity level. Default: 0\n\nDepending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#ExtendableFEM.residual","page":"Stationary Solvers","title":"ExtendableFEM.residual","text":"residual(S::SolverConfiguration)\n\nreturns the residual of the last solve\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"note: Note\nThe type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat customized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.","category":"page"},{"location":"pdesolvers/#Solve-(iterating-subproblems)","page":"Stationary Solvers","title":"Solve (iterating subproblems)","text":"","category":"section"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"SolverConfiguration\nget_unknown_id","category":"page"},{"location":"pdesolvers/#ExtendableFEM.SolverConfiguration","page":"Stationary Solvers","title":"ExtendableFEM.SolverConfiguration","text":"function iterate_until_stationarity(\n\tSolverConfiguration(Problem::ProblemDescription\n\t[FES::Union{<:FESpace, Vector{<:FESpace}}];\n\tinit = nothing,\n\tunknowns = Problem.unknowns,\n\tkwargs...)\n\nReturns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).\n\nKeyword arguments:\n\nabstol: abstol for linear solver (if iterative). Default: 1.0e-11\ncheck_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false\nconstant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false\nconstant_rhs: right-hand side is constant (skips reassembly). Default: false\ndamping: amount of damping, value should be between in (0,1). Default: 0\ninactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]\ninit: initial solution (also used to save the new solution). Default: nothing\ninitialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false\nis_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: ''auto''\nmaxiterations: maximal number of nonlinear iterations/linear solves. Default: 10\nmethod_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)\nplot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false\nprecon_linear: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing\nreltol: reltol for linear solver (if iterative). Default: 1.0e-11\nrestrict_dofs: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]\nreturn_config: solver returns solver configuration (including A and b of last iteration). Default: false\nshow_config: show configuration at the beginning of solve. Default: false\nshow_matrix: show system matrix after assembly. Default: false\nspy: show unicode spy plot of system matrix during solve. Default: false\nsymmetrize: make system matrix symmetric (replace by (A+A')/2). Default: false\nsymmetrize_structure: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false\ntarget_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10\ntime: current time to be used in all time-dependent operators. Default: 0.0\nverbosity: verbosity level. Default: 0\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#ExtendableFEM.get_unknown_id","page":"Stationary Solvers","title":"ExtendableFEM.get_unknown_id","text":"get_unknown_id(SC::SolverConfiguration, u::Unknown)\n\nreturns the id of the unknown u in SC\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:","category":"page"},{"location":"pdesolvers/","page":"Stationary Solvers","title":"Stationary Solvers","text":"iterate_until_stationarity","category":"page"},{"location":"pdesolvers/#ExtendableFEM.iterate_until_stationarity","page":"Stationary Solvers","title":"ExtendableFEM.iterate_until_stationarity","text":"function iterate_until_stationarity(\n\tSCs::Array{<:SolverConfiguration, 1},\n\tFES = nothing;\n\tmaxsteps = 1000,\n\tinit = nothing,\n\tunknowns = [SC.PD.unknowns for SC in SCs],\n\tkwargs...)\n\nIterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corresponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.\n\nUsing the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by\n\nSolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)\n\nwith the usual keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example206_CoupledSubGridProblems/#206-:-CoupledSubGridProblems","page":"Example206_CoupledSubGridProblems","title":"206 : CoupledSubGridProblems","text":"","category":"section"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"(source code)","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"This example demonstrates how to solve a coupled problem where two variables only live on a sub-domain and are coupled through an interface condition. Consider the unit square domain cut in half through on of its diagonals. On each subdomain a solutiong u_j of the two-dimensional Poisson problem","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"with inhomogeneous boundary conditions on the former boundaries of the full square is searched. Along the common boundary between the two subdomains a new interface region is assigned (appended to BFaceNodes) and an interface condition is assembled that couples the two solutions u_1 and u_2 to each other. In this toy example, this interface conditions penalizes the jump between the two solutions on each side of the diagonal. Oberserve, that if the penalization factor tau is large, the two solutions are almost equal along the interface.","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"The computed solution(s) looks like this:","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"(Image: )","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"Each column of the plot shows the solution, the subgrid it lives on. The last row shows the full grid.","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"module Example206_CoupledSubGridProblems\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing Test #\n\n\nfunction boundary_conditions!(result, qpinfo)\n    result[1] = 1 - qpinfo.x[1] - qpinfo.x[2] # used for both subsolutions\n    return nothing\nend\n\nfunction interface_condition!(result, u, qpinfo)\n    result[1] = u[1] - u[2]\n    result[2] = -result[1]\n    return nothing\nend\n\nfunction interface_condition_LM!(result, u, qpinfo)\n    result[1] = (u[1] - u[2])\n    return nothing\nend\n\n\nfunction main(; μ = [1.0, 1.0], f = [10, -10], τ = 1, use_LM = true, nref = 4, order = 2, Plotter = nothing, kwargs...)\n\n    # Finite element type\n    FEType = H1Pk{1, 2, order}\n    FETypeLM = H1Pk{1, 1, order}\n\n    # generate mesh\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # define regions\n    xgrid[CellRegions] = Int32[1, 2, 2, 1]\n\n    # add an interface between region 1 and 2\n    # (one can use the BFace storages for that)\n    xgrid[BFaceNodes] = Int32[xgrid[BFaceNodes] [2 5; 5 4]]\n    append!(xgrid[BFaceRegions], [5, 5])\n    xgrid[FaceRegions][xgrid[BFaceFaces][(end - 1):end]] .= 5\n    xgrid[BFaceGeometries] = VectorOfConstants{ElementGeometries, Int}(Edge1D, 6)\n\n    # refine\n    xgrid = uniform_refine(xgrid, nref)\n\n    # define an FESpace just on region 1 and one just on region 2\n    FES1 = FESpace{FEType}(xgrid; regions = [1])\n    FES2 = FESpace{FEType}(xgrid; regions = [2])\n    if use_LM\n        FES3 = FESpace{FETypeLM, ON_FACES}(xgrid; regions = [5])\n        @show FES3.xgrid FES3.dofgrid\n    end\n\n    # define variables\n    u1 = Unknown(\"u1\"; name = \"potential in region 1\")\n    u2 = Unknown(\"u2\"; name = \"potential in region 2\")\n    p = Unknown(\"p\"; name = \"LM for interface condition\")\n\n    # problem description\n    PD = ProblemDescription()\n    assign_unknown!(PD, u1)\n    assign_unknown!(PD, u2)\n    assign_operator!(PD, BilinearOperator([grad(u1)]; regions = [1], factor = μ[1], kwargs...))\n    assign_operator!(PD, BilinearOperator([grad(u2)]; regions = [2], factor = μ[2], kwargs...))\n    assign_operator!(PD, LinearOperator([id(u1)]; regions = [1], factor = f[1]))\n    assign_operator!(PD, LinearOperator([id(u2)]; regions = [2], factor = f[2]))\n    if use_LM\n        assign_unknown!(PD, p)\n        assign_operator!(PD, BilinearOperator(interface_condition_LM!, [id(p)], [id(u1), id(u2)]; regions = [5], transposed_copy = 1, entities = ON_FACES, kwargs...))\n    else\n        assign_operator!(PD, BilinearOperator(interface_condition!, [id(u1), id(u2)]; regions = [5], factor = τ, entities = ON_FACES, kwargs...))\n    end\n    assign_operator!(PD, InterpolateBoundaryData(u1, boundary_conditions!; regions = 1:4))\n    assign_operator!(PD, InterpolateBoundaryData(u2, boundary_conditions!; regions = 1:4))\n\n    sol = solve(PD, use_LM ? [FES1, FES2, FES3] : [FES1, FES2])\n\n    plt = plot([id(u1), id(u2), dofgrid(u1), dofgrid(u2), grid(u1)], sol; Plotter = Plotter)\n\n    return sol, plt\nend\n\n\nend #module","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"","category":"page"},{"location":"module_examples/Example206_CoupledSubGridProblems/","page":"Example206_CoupledSubGridProblems","title":"Example206_CoupledSubGridProblems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tensordescription/#Tensor-Description","page":"Tensor Description","title":"Tensor Description","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"To be able to construct reshaped views  of the test functions and their derivates, we can describe the  shape of the view through a TensorDescription{R,D}  where R is the rank of the tensor and D is the dimension  or extent of the tensor in each of the R directions.  That means a real valued R-tensor is an element of  underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.  Specifically, we can identify the following mathematical objects with  tensors of different ranks:","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"math. object R-Tensor\nscalar inmathbbR 0-Tensor\nvector inmathbbR^D 1-Tensor\nmatrix inmathbbR^DtimesmathbbR^D 2-Tensor","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For finite elements, D usually matches the spatial dimension of  the problem we want to solve, i.e. D=2 for 2D and D=3 for 3D.","category":"page"},{"location":"tensordescription/#Tensor-Types","page":"Tensor Description","title":"Tensor Types","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"ExtendableFEM.TensorDescription\nExtendableFEM.TDScalar\nExtendableFEM.TDVector\nExtendableFEM.TDMatrix\nExtendableFEM.TDRank3\nExtendableFEM.TDRank4","category":"page"},{"location":"tensordescription/#ExtendableFEM.TensorDescription","page":"Tensor Description","title":"ExtendableFEM.TensorDescription","text":"TensorDescription{R,D}\n\nGeneral type for an R-tensor of dimension/extent D. Mathematically, this describes the shape of an element  in underbracemathbbR^DtimescdotstimesmathbbR^D_R text times.\n\nSee also:  TDScalar{D}, TDVector{D}, TDMatrix{D}, TDRank3{D}, TDRank4{D}\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDScalar","page":"Tensor Description","title":"ExtendableFEM.TDScalar","text":"TDScalar{D}\n\nSpecification for a 0-tensor or scalar, i.e. TensorDescription{0,D}, to improve readability.\n\nNote that in this case D has no greater effect  and is only provided to have a matching interface  between all the specifications.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDVector","page":"Tensor Description","title":"ExtendableFEM.TDVector","text":"TDVector{D}\n\nSpecification for a 1-tensor or vector, i.e. TensorDescription{1,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDMatrix","page":"Tensor Description","title":"ExtendableFEM.TDMatrix","text":"TDMatrix{D}\n\nSpecification for a 2-tensor or matrix, i.e. TensorDescription{2,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank3","page":"Tensor Description","title":"ExtendableFEM.TDRank3","text":"TDRank3{D}\n\nSpecification for a 3-tensor, i.e. TensorDescription{3,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#ExtendableFEM.TDRank4","page":"Tensor Description","title":"ExtendableFEM.TDRank4","text":"TDRank4{D}\n\nSpecification for a 4-tensor, i.e. TensorDescription{4,D}, to improve readability.\n\n\n\n\n\n","category":"type"},{"location":"tensordescription/#Reshaped-views","page":"Tensor Description","title":"Reshaped views","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"Modules = [ExtendableFEM]\nPages = [\"tensors.jl\"]\nOrder   = [:function]","category":"page"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDMatrix{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{2,dim})\n\nReturns a view of input[i:i+dim^2-1] reshaped as a (dim,dim) matrix.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank3{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{3,dim})\n\nReturns a view of input[i:i+dim^3-1] reshaped as a (dim,dim,dim) 3-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDRank4{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{4,dim})\n\nReturns a view of input[i:i+dim^4-1] reshaped as (dim,dim,dim,dim) 4-tensor.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDScalar{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{0,dim})\n\nReturns a view of input[i] reshaped as a vector of length 1.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{Any, Int64, TDVector{dim}}} where dim","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{1,dim})\n\nReturns a view of input[i:i+dim-1] reshaped as a vector of length dim.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#ExtendableFEM.tensor_view-Union{Tuple{dim}, Tuple{rank}, Tuple{Any, Int64, TensorDescription{rank, dim}}} where {rank, dim}","page":"Tensor Description","title":"ExtendableFEM.tensor_view","text":"function tensor_view(input,i::Int,::TensorDescription{rank,dim})\n\nReturns a view of input[i] and subsequent entries,  reshaped as a rank-tensor of dimension dim.\n\nNote that this general implementation is a fallback for rank>4 that will likely produce allocations and slow assembly  times if used in a kernel function.\n\n\n\n\n\n","category":"method"},{"location":"tensordescription/#Which-tensor-for-which-unknown?","page":"Tensor Description","title":"Which tensor for which unknown?","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For an unknown variable u of tensor rank r  a derivative of order n has rank r+n, i.e. the hessian (n=2) of a scalar unknown (rank 0) and the gradient (n=1) of a vector valued (rank 1)  variable are both matrices (rank 2).","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"For a more comprehensive list see the following table","category":"page"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"derivative order scalar-valued vector-valued matrix-valued\n0 (value/id) TDScalar(D) TDVector(D) TDMatrix(D)\n1 (grad) TDVector(D) TDMatrix(D) TDRank3(D)\n2 (hessian) TDMatrix(D) TDRank3(D) TDRank4(D)\n3 TDRank3(D) TDRank4(D) TensorDescription(5,D)\n4 TDRank4(D) TensorDescription(5,D) TensorDescription(6,D)\nvdots vdots vdots vdots","category":"page"},{"location":"tensordescription/#Helpers","page":"Tensor Description","title":"Helpers","text":"","category":"section"},{"location":"tensordescription/","page":"Tensor Description","title":"Tensor Description","text":"tmul!","category":"page"},{"location":"tensordescription/#ExtendableFEM.tmul!","page":"Tensor Description","title":"ExtendableFEM.tmul!","text":"function tmul!(y,A,x,α=1.0,β=0.0)\n\nCombined inplace  matrix-vector multiply-add A^T x α + y β. The result is stored in y by overwriting it.  Note that y must not be aliased with either A or x.\n\n\n\n\n\nfunction tmul!(y::AbstractVector{T}, A::AbstractMatrix{T}, x::AbstractVector{T}, α=1.0, β=0.0) where {T<:AbstractFloat}\n\nOverload of the generic function for types supported by  LinearAlgebra.BLAS.gemv! to avoid slow run times for large inputs.\n\n\n\n\n\n","category":"function"},{"location":"module_examples/Example265_FlowTransport/#265-:-Flow-Transport","page":"Example265_FlowTransport","title":"265 : Flow + Transport","text":"","category":"section"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"(source code)","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"This example solve the Stokes problem in an Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a stationary species concentration mathbfc such that","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(mathbfu)  = 0\nmathbfc_t - kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"with some viscosity parameter and diffusion parameter kappa.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation three possibilities can be chosen:","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Classical Bernardi–Raugel stationary finite element discretisations mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = false]\nAs in 1. but with divergence-free reconstruction operator in convection term Pi_textreconst mathbfu_h cdot nabla mathbfc_h [set FVtransport = false, reconstruct = true]\nTime-dependent upwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces [set FVtransport = true]","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Observe that the divergence-free postprocessing helps a lot for mass conservation, but is still not perfect. The finite volume upwind discretisation ensures mass conservation.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to artificial diffusion.","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"The computed solution for the default parameters looks like this:","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"(Image: )","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"module Example265_FlowTransport\n\nusing ExtendableFEM\nusing ExtendableFEMBase\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\n\n# boundary data\nfunction u_inlet!(result, qpinfo)\n    x = qpinfo.x\n    result[1] = 4 * x[2] * (1 - x[2])\n    result[2] = 0\n    return nothing\nend\nfunction c_inlet!(result, qpinfo)\n    result[1] = (1 - qpinfo.x[2]) * qpinfo.x[2]\n    return nothing\nend\n\nfunction kernel_stokes_standard!(result, u_ops, qpinfo)\n    ∇u, p = view(u_ops, 1:4), view(u_ops, 5)\n    μ = qpinfo.params[1]\n    result[1] = μ * ∇u[1] - p[1]\n    result[2] = μ * ∇u[2]\n    result[3] = μ * ∇u[3]\n    result[4] = μ * ∇u[4] - p[1]\n    result[5] = -(∇u[1] + ∇u[4])\n    return nothing\nend\n\nfunction kernel_convection!(result, ∇T, u, qpinfo)\n    result[1] = ∇T[1] * u[1] + ∇T[2] * u[2]\n    return nothing\nend\n\nfunction kernel_inlet!(result, input, qpinfo)\n    c_inlet!(result, qpinfo)\n    result[1] *= -input[1]\n    return nothing\nend\n\n\n# everything is wrapped in a main function\nfunction main(; nrefs = 4, Plotter = nothing, reconstruct = true, FVtransport = true, parallel = false, npart = 8, μ = 1, kwargs...)\n\n    # load mesh and refine\n    xgrid = uniform_refine(\n        simplexgrid(\n            Triangulate;\n            points = [0 0; 3 0; 3 -3; 7 -3; 7 0; 10 0; 10 1; 6 1; 6 -2; 4 -2; 4 1; 0 1]',\n            bfaces = [1 2; 2 3; 3 4; 4 5; 5 6; 6 7; 7 8; 8 9; 9 10; 10 11; 11 12; 12 1]',\n            bfaceregions = [1; 1; 1; 1; 1; 2; 3; 3; 3; 3; 3; 4],\n            regionpoints = [0.5 0.5;]',\n            regionnumbers = [1],\n            regionvolumes = [1.0]\n        ), nrefs\n    )\n\n    if parallel\n        xgrid = partition(xgrid, RecursiveMetisPartitioning(npart = npart))\n    end\n\n    # define unknowns\n    u = Unknown(\"u\"; name = \"velocity\", dim = 2)\n    p = Unknown(\"p\"; name = \"pressure\", dim = 1)\n    T = Unknown(\"T\"; name = \"temperature\", dim = 1)\n\n    id_u = reconstruct ? apply(u, Reconstruct{HDIVBDM1{2}, Identity}) : id(u)\n\n    # define first sub-problem: Stokes equations to solve for velocity u\n    PD = ProblemDescription(\"Stokes problem\")\n    assign_unknown!(PD, u)\n    assign_unknown!(PD, p)\n    assign_operator!(PD, BilinearOperator(kernel_stokes_standard!, [grad(u), id(p)]; params = [μ], parallel = parallel, kwargs...))\n    assign_operator!(PD, InterpolateBoundaryData(u, u_inlet!; regions = 4, parallel = parallel, kwargs...))\n    assign_operator!(PD, HomogeneousBoundaryData(u; regions = [1, 3], kwargs...))\n\n    # add transport equation of species\n    PDT = ProblemDescription(\"transport problem\")\n    assign_unknown!(PDT, T)\n    if FVtransport ## FVM discretisation of transport equation (pure upwind convection)\n        τ = 1.0e3\n        assign_operator!(PDT, CallbackOperator(assemble_fv_operator!(), [u]; kwargs...))\n        assign_operator!(PDT, BilinearOperator([id(T)]; store = true, factor = 1 / τ, parallel = parallel, kwargs...))\n        assign_operator!(PDT, LinearOperator([id(T)], [id(T)]; factor = 1 / τ, parallel = parallel, kwargs...))\n    else ## FEM discretisation of transport equation (with small diffusion term)\n        assign_operator!(PDT, BilinearOperator([grad(T)]; factor = 1.0e-6, parallel = parallel, kwargs...))\n        assign_operator!(PDT, BilinearOperator(kernel_convection!, [id(T)], [grad(T)], [id_u]; parallel = parallel, kwargs...))\n        assign_operator!(PDT, InterpolateBoundaryData(T, c_inlet!; regions = [4], kwargs...))\n    end\n\n    # generate FESpaces and a solution vector for all 3 unknowns\n    FETypes = [H1BR{2}, L2P0{1}, FVtransport ? L2P0{1} : H1P1{1}]\n    FES = [FESpace{FETypes[j]}(xgrid) for j in 1:3]\n    sol = FEVector(FES; tags = [u, p, T])\n\n    # solve the two problems separately\n    sol = solve(PD; init = sol, kwargs...)\n    sol = solve(PDT; init = sol, maxiterations = 20, target_residual = 1.0e-12, constant_matrix = true, kwargs...)\n\n    # print minimal and maximal concentration to check max principle (should be in [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(view(sol[T]))),$(maximum(view(sol[T])))]\")\n\n    # plot\n    plt = plot([id(u), id(T)], sol; Plotter = Plotter, ncols = 1, rasterpoints = 40, width = 800, height = 800)\n\n    return sol, plt\nend\n\n# pure convection finite volume operator for transport\nfunction assemble_fv_operator!()\n\n    BndFluxIntegrator = ItemIntegrator(kernel_inflow!, [normalflux(1)]; entities = ON_BFACES)\n    FluxIntegrator = ItemIntegrator([normalflux(1)]; entities = ON_FACES)\n    fluxes::Matrix{Float64} = zeros(Float64, 1, 0)\n\n    return function closure(A, b, args; assemble_matrix = true, assemble_rhs = true, kwargs...)\n\n        # prepare grid and stash\n        xgrid = args[1].FES.xgrid\n        nfaces = size(xgrid[FaceCells], 2)\n        if size(fluxes, 2) < nfaces\n            fluxes = zeros(Float64, 1, nfaces)\n        end\n\n        # right-hand side = boundary inflow fluxes if velocity points inward\n        if assemble_rhs\n            fill!(fluxes, 0)\n            evaluate!(fluxes, BndFluxIntegrator, [args[1]])\n            facecells = xgrid[FaceCells]\n            bface2face = xgrid[BFaceFaces]\n            for bface in 1:lastindex(bface2face)\n                b[facecells[1, bface2face[bface]]] -= fluxes[bface]\n            end\n        end\n\n        # assemble upwind finite volume fluxes over cell faces into matrix\n        if assemble_matrix\n            # integrate normalfux of velocity\n            fill!(fluxes, 0)\n            evaluate!(fluxes, FluxIntegrator, [args[1]])\n\n            cellfaces = xgrid[CellFaces]\n            cellfacesigns = xgrid[CellFaceSigns]\n            for cell in 1:num_cells(xgrid)\n                nfaces4cell = num_targets(cellfaces, cell)\n                for cf in 1:nfaces4cell\n                    face = cellfaces[cf, cell]\n                    other_cell = facecells[1, face]\n                    if other_cell == cell\n                        other_cell = facecells[2, face]\n                    end\n                    flux = fluxes[face] * cellfacesigns[cf, cell]\n                    if (other_cell > 0)\n                        flux *= 1 // 2 # because it will be accumulated on two cells\n                    end\n                    if flux > 0 # flow from cell to other_cell or out of domain\n                        _addnz(A, cell, cell, flux, 1)\n                        if other_cell > 0\n                            _addnz(A, other_cell, cell, -flux, 1)\n                            # otherwise flow goes out of domain\n                        end\n                    else # flow from other_cell into cell or into domain\n                        _addnz(A, cell, cell, 1.0e-16, 1) # add zero to keep pattern for LU\n                        if other_cell > 0 # flow comes from neighbour cell\n                            _addnz(A, other_cell, other_cell, -flux, 1)\n                            _addnz(A, cell, other_cell, flux, 1)\n                        end\n                        # otherwise flow comes from outside into domain, handled in rhs side loop above\n                    end\n                end\n            end\n        end\n        return nothing\n    end\nend\n\n\nfunction kernel_inflow!(result, input, qpinfo)\n    return if input[1] < 0 # if velocity points into domain\n        c_inlet!(result, qpinfo)\n        result[1] *= input[1]\n    else\n        result[1] = 0\n    end\nend\n\nend # module","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"","category":"page"},{"location":"module_examples/Example265_FlowTransport/","page":"Example265_FlowTransport","title":"Example265_FlowTransport","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/#204-:-Eigenvalue-problem-for-the-Laplacian","page":"Example204_LaplaceEVProblem","title":"204 : Eigenvalue problem for the Laplacian","text":"","category":"section"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"(source code)","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"This example computes the pairs of eigenvalues and eigenvectors (lambdau) in mathbbR times H^1_0(Omega) of the Laplacian, i.e,","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"beginaligned\n-Delta u  = lambda u quad textin  Omega\nendaligned","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"on a two-dimensional L-shaped domain with homogeneous boundary conditions with the help of an iterative solver from KrylovKit.jl. The first twelve computed eigenvectors look like this:","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"(Image: )","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"module Example204_LaplaceEVProblem\n\nusing ExtendableFEM\nusing ExtendableGrids\nusing ExtendableSparse\nusing LinearAlgebra\nusing GridVisualize\nusing KrylovKit\n\nfunction main(; which = 1:12, ncols = 3, nrefs = 4, order = 1, Plotter = nothing, kwargs...)\n\n    # discretize\n    xgrid = uniform_refine(grid_lshape(Triangle2D), nrefs)\n    FES = FESpace{H1Pk{1, 2, order}}(xgrid)\n\n    # assemble operators\n    A = FEMatrix(FES)\n    B = FEMatrix(FES)\n    u = FEVector(FES; name = \"u\")\n    assemble!(A, BilinearOperator([grad(1)]; kwargs...))\n    assemble!(A, BilinearOperator([id(1)]; entities = ON_BFACES, factor = 1.0e4, kwargs...))\n    assemble!(B, BilinearOperator([id(1)]; kwargs...))\n\n    # solver generalized eigenvalue problem iteratively with KrylovKit\n    λs, x, info = geneigsolve((A.entries, B.entries), maximum(which), :SR; maxiter = 4000, issymmetric = true, tol = 1.0e-8)\n    @show info\n    @assert info.converged >= maximum(which)\n\n    # plot requested eigenvalue pairs\n    nEVs = length(which)\n    nrows = Int(ceil(nEVs / ncols))\n    plt = GridVisualizer(; Plotter = Plotter, layout = (nrows, ncols), clear = true, resolution = (900, 900 / ncols * nrows))\n    col, row = 0, 1\n    for j in which\n        col += 1\n        if col == ncols + 1\n            col, row = 1, row + 1\n        end\n        λ = λs[j]\n        @info \"λ[$j] = $λ, residual = $(sum(info.residual[j]))\"\n        u.entries .= Real.(x[j])\n        scalarplot!(plt[row, col], id(1), u; Plotter = Plotter, title = \"λ[$j] = $(Float16(λ))\")\n    end\n\n    return u, plt\nend\n\nend # module","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"","category":"page"},{"location":"module_examples/Example204_LaplaceEVProblem/","page":"Example204_LaplaceEVProblem","title":"Example204_LaplaceEVProblem","text":"This page was generated using Literate.jl.","category":"page"}]
}
