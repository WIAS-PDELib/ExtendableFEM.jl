<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LinearOperator · ExtendableFEM.jl</title><meta name="title" content="LinearOperator · ExtendableFEM.jl"/><meta property="og:title" content="LinearOperator · ExtendableFEM.jl"/><meta property="twitter:title" content="LinearOperator · ExtendableFEM.jl"/><meta name="description" content="Documentation for ExtendableFEM.jl."/><meta property="og:description" content="Documentation for ExtendableFEM.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../tensordescription/">Tensor Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li><a class="tocitem" href="../bilinearoperator/">BilinearOperator</a></li><li class="is-active"><a class="tocitem" href>LinearOperator</a><ul class="internal"><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Example:-Right-hand-Side-Operator"><span>Example: Right-hand Side Operator</span></a></li><li><a class="tocitem" href="#LinearOperatorDG"><span>LinearOperatorDG</span></a></li></ul></li><li><a class="tocitem" href="../restrictions/">Restrictions</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Stationary Solvers</a></li><li><a class="tocitem" href="../pdesolvers_dt/">Time-dependent Solvers</a></li><li><a class="tocitem" href="../parallel_assembly/">Parallel Assembly</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Postprocessing and Visualization</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../faceinterpolator/">Face Interpolator</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../module_examples/Example103_BurgersEquation/">Example103_BurgersEquation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoissonEquation/">Example105_NonlinearPoissonEquation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion/">Example106_NonlinearDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example108_RobinBoundaryCondition/">Example108_RobinBoundaryCondition</a></li><li><a class="tocitem" href="../module_examples/Example201_PoissonProblem/">Example201_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example202_MixedPoissonProblem/">Example202_MixedPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example203_PoissonProblemDG/">Example203_PoissonProblemDG</a></li><li><a class="tocitem" href="../module_examples/Example204_LaplaceEVProblem/">Example204_LaplaceEVProblem</a></li><li><a class="tocitem" href="../module_examples/Example205_HeatEquation/">Example205_HeatEquation</a></li><li><a class="tocitem" href="../module_examples/Example206_CoupledSubGridProblems/">Example206_CoupledSubGridProblems</a></li><li><a class="tocitem" href="../module_examples/Example207_AdvectionUpwindDG/">Example207_AdvectionUpwindDG</a></li><li><a class="tocitem" href="../module_examples/Example210_LshapeAdaptivePoissonProblem/">Example210_LshapeAdaptivePoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example211_LshapeAdaptiveEQPoissonProblem/">Example211_LshapeAdaptiveEQPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example212_PeriodicBoundary2D/">Example212_PeriodicBoundary2D</a></li><li><a class="tocitem" href="../module_examples/Example220_ReactionConvectionDiffusion/">Example220_ReactionConvectionDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example225_ObstacleProblem/">Example225_ObstacleProblem</a></li><li><a class="tocitem" href="../module_examples/Example226_Thermoforming/">Example226_Thermoforming</a></li><li><a class="tocitem" href="../module_examples/Example227_ObstacleProblemLVPP/">Example227_ObstacleProblemLVPP</a></li><li><a class="tocitem" href="../module_examples/Example230_NonlinearElasticity/">Example230_NonlinearElasticity</a></li><li><a class="tocitem" href="../module_examples/Example235_StokesIteratedPenalty/">Example235_StokesIteratedPenalty</a></li><li><a class="tocitem" href="../module_examples/Example240_SVRTEnrichment/">Example240_SVRTEnrichment</a></li><li><a class="tocitem" href="../module_examples/Example245_NSEFlowAroundCylinder/">Example245_NSEFlowAroundCylinder</a></li><li><a class="tocitem" href="../module_examples/Example250_NSELidDrivenCavity/">Example250_NSELidDrivenCavity</a></li><li><a class="tocitem" href="../module_examples/Example252_NSEPlanarLatticeFlow/">Example252_NSEPlanarLatticeFlow</a></li><li><a class="tocitem" href="../module_examples/Example260_AxisymmetricNavierStokesProblem/">Example260_AxisymmetricNavierStokesProblem</a></li><li><a class="tocitem" href="../module_examples/Example264_StokesDarcy/">Example264_StokesDarcy</a></li><li><a class="tocitem" href="../module_examples/Example265_FlowTransport/">Example265_FlowTransport</a></li><li><a class="tocitem" href="../module_examples/Example270_NaturalConvectionProblem/">Example270_NaturalConvectionProblem</a></li><li><a class="tocitem" href="../module_examples/Example275_OptimalControlStokes/">Example275_OptimalControlStokes</a></li><li><a class="tocitem" href="../module_examples/Example280_CompressibleStokes/">Example280_CompressibleStokes</a></li><li><a class="tocitem" href="../module_examples/Example282_IncompressibleMHD/">Example282_IncompressibleMHD</a></li><li><a class="tocitem" href="../module_examples/Example284_LevelSetMethod/">Example284_LevelSetMethod</a></li><li><a class="tocitem" href="../module_examples/Example285_CahnHilliard/">Example285_CahnHilliard</a></li><li><a class="tocitem" href="../module_examples/Example290_PoroElasticity/">Example290_PoroElasticity</a></li><li><a class="tocitem" href="../module_examples/Example295_SlidingDroplet/">Example295_SlidingDroplet</a></li><li><a class="tocitem" href="../module_examples/Example301_PoissonProblem/">Example301_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example310_DivFreeBasis/">Example310_DivFreeBasis</a></li><li><a class="tocitem" href="../module_examples/Example312_PeriodicBoundary3D/">Example312_PeriodicBoundary3D</a></li><li><a class="tocitem" href="../module_examples/Example330_HyperElasticity/">Example330_HyperElasticity</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>LinearOperator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>LinearOperator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/master/docs/src/linearoperator.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LinearOperator"><a class="docs-heading-anchor" href="#LinearOperator">LinearOperator</a><a id="LinearOperator-1"></a><a class="docs-heading-anchor-permalink" href="#LinearOperator" title="Permalink"></a></h1><p><code>LinearOperator</code> provides a flexible interface for defining linear forms (right-hand side vectors) in finite element problems. These operators typically represent source terms, boundary data, or linearizations of nonlinear operators. The interface supports both standard and discontinuous Galerkin (DG) forms, and allows for custom assembly on cells, faces, or other grid entities. It is also possible to assign a pre-computed vector as a LinearOperator.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Vector{&lt;:Union{Int64, Unknown}}, Vector{&lt;:Union{Int64, Unknown}}}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperator-Tuple{AbstractMatrix, Vector{&lt;:Union{Int64, Unknown}}, Vector{&lt;:Union{Int64, Unknown}}}"><code>ExtendableFEM.LinearOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearOperator(
    A::AbstractMatrix,
    u_test::Vector{&lt;:Union{Int64, Unknown}},
    u_args::Vector{&lt;:Union{Int64, Unknown}};
    kwargs...
) -&gt; Union{ExtendableFEM.LinearOperatorFromMatrix{Int64, &lt;:AbstractMatrix{T}} where T, ExtendableFEM.LinearOperatorFromMatrix{Unknown{IT}, &lt;:AbstractMatrix{T}} where {IT, T}}
</code></pre><p>Construct a linear form (right-hand side operator) from a user-provided matrix.</p><p>This wraps an explicit matrix <code>A</code> (which can be an <code>AbstractMatrix</code> or a block-structured <code>FEMatrix</code>) as a linear operator for finite element assembly. The arguments <code>u_args</code> specify which coefficients of the current solution should be multiplied with the matrix, and <code>u_test</code> specifies where to place the (blocks of the) resulting vector in the system right-hand side.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: The matrix to use (can be an <code>AbstractMatrix</code> or a <code>FEMatrix</code> with multiple blocks).</li><li><code>u_test</code>: Array specifying which unknowns or blocks the result should be assigned to.</li><li><code>u_args</code>: Array specifying which unknowns or blocks are used as arguments (i.e., which solution coefficients are multiplied by <code>A</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator.jl#L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperator-Tuple{Any, Any}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperator-Tuple{Any, Any}"><code>ExtendableFEM.LinearOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearOperator(
    b,
    u_test;
    kwargs...
) -&gt; Union{LinearOperator{Float64, _A, typeof(ExtendableFEMBase.standard_kernel), Nothing} where _A&lt;:Union{Integer, Unknown}, LinearOperator{Float64, _A, typeof(ExtendableFEMBase.standard_kernel), Vector{Float64}} where _A&lt;:Union{Integer, Unknown}}
</code></pre><p>Construct a linear form (right-hand side operator) from a user-provided vector.</p><p>This wraps an explicit vector <code>b</code> (which can be an <code>AbstractVector</code> or a block-structured <code>FEVector</code>) as a linear operator for finite element assembly. The argument <code>u_test</code> specifies where to place the (blocks of the) vector in the system right-hand side.</p><p><strong>Arguments</strong></p><ul><li><code>b</code>: The vector to use as the right-hand side. Can be an <code>AbstractVector</code> or an <code>FEVector</code> with multiple blocks.</li><li><code>u_test</code>: Array specifying which unknowns or blocks the vector should be assigned to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator.jl#L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperator-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperator-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.LinearOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LinearOperator(
    kernel,
    oa_test::Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}},
    oa_args::Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}};
    kwargs...
) -&gt; Union{LinearOperator{Float64, _A, _B, Nothing} where {_A&lt;:Union{Integer, Unknown}, _B}, LinearOperator{Float64, _A, _B, Vector{Float64}} where {_A&lt;:Union{Integer, Unknown}, _B}}
</code></pre><p>Construct a nonlinear linear form (right-hand side operator) for finite element assembly, suitable for linearizations or forms depending on the current solution.</p><p>This operator evaluates, at each quadrature point, the provided <code>kernel!</code> function, which depends on the operator evaluations of the current solution (the &quot;argument&quot; unknowns). The result of the kernel is then used in a vector product with the operator evaluation(s) of the test function(s).</p><p>The kernel function should have the signature:</p><pre><code class="language-julia hljs">kernel!(result, eval_args, qpinfo)</code></pre><p>where <code>result</code> is the output array, <code>eval_args</code> contains the evaluated operator arguments at the quadrature point, and <code>qpinfo</code> provides information about the current quadrature point (e.g., <code>qpinfo.x</code> for global coordinates).</p><p>Operator evaluations are specified as tuples pairing an unknown identifier (or integer) with a function operator (such as those generated by <code>grad(u)</code>, <code>id(u)</code>, etc).</p><p><strong>Arguments</strong></p><ul><li><code>kernel!</code>: Function to evaluate at each quadrature point, depending on the current solution.</li><li><code>oa_test</code>: Array of tuples <code>(unknown, operator)</code> specifying test function operator evaluations.</li><li><code>oa_args</code>: Array of tuples <code>(unknown, operator)</code> specifying argument operator evaluations (from the current solution).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>bonus_quadorder</code>: additional quadrature order added to quadorder. Default: 0</p></li><li><p><code>entities</code>: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p><code>factor</code>: factor that should be multiplied during assembly. Default: 1</p></li><li><p><code>name</code>: name for operator used in printouts. Default: &#39;&#39;LinearOperator&#39;&#39;</p></li><li><p><code>parallel</code>: assemble operator in parallel using colors/partitions information. Default: false</p></li><li><p><code>parallel_groups</code>: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p><code>params</code>: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p><code>quadorder</code>: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>regions</code>: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p><code>store</code>: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li><li><p><code>time_dependent</code>: operator is time-dependent ?. Default: false</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator.jl#L201-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperator-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperator-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.LinearOperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function LinearOperator(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Construct a linear form (right-hand side operator) for finite element assembly.</p><p>This operator evaluates, at each quadrature point, the provided <code>kernel!</code> function (or a constant function if none is given) and computes the vector product with the operator evaluation(s) of the test function(s). The kernel function should have the signature:</p><pre><code class="language-julia hljs">kernel!(result, qpinfo)</code></pre><p>where <code>result</code> is the output array and <code>qpinfo</code> provides information about the current quadrature point (e.g., <code>qpinfo.x</code> for global coordinates).</p><p>Operator evaluations are specified as tuples pairing an unknown identifier (or integer) with a function operator (such as those generated by <code>grad(u)</code>, <code>id(u)</code>, etc).</p><p><strong>Arguments</strong></p><ul><li><code>kernel!</code> (optional): Function to evaluate at each quadrature point. If omitted, a constant kernel is used.</li><li><code>oa_test</code>: Array of tuples <code>(unknown, operator)</code> specifying test function operator evaluations.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>bonus_quadorder</code>: additional quadrature order added to quadorder. Default: 0</p></li><li><p><code>entities</code>: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p><code>factor</code>: factor that should be multiplied during assembly. Default: 1</p></li><li><p><code>name</code>: name for operator used in printouts. Default: &#39;&#39;LinearOperator&#39;&#39;</p></li><li><p><code>parallel</code>: assemble operator in parallel using colors/partitions information. Default: false</p></li><li><p><code>parallel_groups</code>: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p><code>params</code>: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p><code>quadorder</code>: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>regions</code>: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p><code>store</code>: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li><li><p><code>time_dependent</code>: operator is time-dependent ?. Default: false</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Standard load vector with right-hand side f(x)
kernel!(result, qpinfo) = (result[1] = f(qpinfo.x))
O = LinearOperator(kernel!, [id(u)]; entities=ON_CELLS)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator.jl#L118-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEM.assemble!-Union{Tuple{UT}, Tuple{Tv}, Tuple{FEVector, LinearOperator{Tv, UT}}, Tuple{FEVector, LinearOperator{Tv, UT}, Any}} where {Tv, UT}"><a class="docstring-binding" href="#ExtendableFEM.assemble!-Union{Tuple{UT}, Tuple{Tv}, Tuple{FEVector, LinearOperator{Tv, UT}}, Tuple{FEVector, LinearOperator{Tv, UT}, Any}} where {Tv, UT}"><code>ExtendableFEM.assemble!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble!(
    b::FEVector,
    O::LinearOperator{Tv, UT};
    ...
) -&gt; Any
assemble!(
    b::FEVector,
    O::LinearOperator{Tv, UT},
    sol;
    assemble_rhs,
    kwargs...
) -&gt; Any
</code></pre><p>Assembles the right-hand side vector for a linear form (i.e., applies the <code>LinearOperator</code> to the current solution and accumulates the result in <code>b</code>). If the operator depends on the current solution (i.e., has argument unknowns), the solution vector(s) <code>sol</code> must be provided.</p><p><strong>Arguments</strong></p><ul><li><code>b::FEVector</code>: The right-hand side vector to assemble into (can be block-structured).</li><li><code>O::LinearOperator</code>: The linear operator to assemble.</li><li><code>sol</code>: (Optional) Solution vector(s) for argument unknowns, required if the operator depends on the current solution.</li><li><code>assemble_rhs</code>: (Keyword, default = <code>true</code>) If <code>false</code>, assembly is skipped.</li><li><code>kwargs...</code>: Additional keyword arguments passed to the assembler (e.g., time, custom parameters).</li></ul><p><strong>Returns</strong></p><ul><li>The assembled right-hand side vector <code>b</code> (modified in-place).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator.jl#L717">source</a></section></details></article><h2 id="Example:-Right-hand-Side-Operator"><a class="docs-heading-anchor" href="#Example:-Right-hand-Side-Operator">Example: Right-hand Side Operator</a><a id="Example:-Right-hand-Side-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Right-hand-Side-Operator" title="Permalink"></a></h2><p>For a right-hand side operator of a Poisson problem with a given function <code>f(x)</code>, the kernel could look like:</p><pre><code class="language-julia hljs">function kernel!(result, qpinfo)
    result[1] = f(qpinfo.x)
end
u = Unknown(&quot;u&quot;)
LinearOperator(kernel!, [id(u)])</code></pre><p>The argument <code>[id(u)]</code> specifies that the result of the kernel is multiplied with the identity evaluation of the test function.</p><h2 id="LinearOperatorDG"><a class="docs-heading-anchor" href="#LinearOperatorDG">LinearOperatorDG</a><a id="LinearOperatorDG-1"></a><a class="docs-heading-anchor-permalink" href="#LinearOperatorDG" title="Permalink"></a></h2><p><code>LinearOperatorDG</code> is intended for linear forms that involve jumps or averages of discontinuous quantities on faces, requiring access to all degrees of freedom on neighboring cells.</p><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperatorDG-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperatorDG-Tuple{Any, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.LinearOperatorDG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function LinearOperatorDG(
	kernel::Function,
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_args::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a nonlinear linear form that evaluates a kernel function that depends on the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface</p><pre><code class="language-julia hljs">kernel!(result, eval_args, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Keyword arguments:</p><ul><li><p><code>bonus_quadorder</code>: additional quadrature order added to quadorder. Default: 0</p></li><li><p><code>entities</code>: assemble operator on these grid entities (default = ON<em>FACES). Default: ON</em>FACES</p></li><li><p><code>entry_tolerance</code>: threshold to add entry to sparse matrix. Default: 0</p></li><li><p><code>factor</code>: factor that should be multiplied during assembly. Default: 1</p></li><li><p><code>name</code>: name for operator used in printouts. Default: &#39;&#39;LinearOperatorDG&#39;&#39;</p></li><li><p><code>parallel</code>: assemble operator in parallel using colors/partitions information. Default: false</p></li><li><p><code>parallel_groups</code>: assemble operator in parallel using FaceAssemblyGroups. Default: false</p></li><li><p><code>params</code>: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p><code>quadorder</code>: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>regions</code>: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p><code>store</code>: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li><li><p><code>time_dependent</code>: operator is time-dependent ?. Default: false</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator_dg.jl#L158-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExtendableFEM.LinearOperatorDG-Tuple{Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><a class="docstring-binding" href="#ExtendableFEM.LinearOperatorDG-Tuple{Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.LinearOperatorDG</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function LinearOperatorDG(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a linear form that evaluates, in each quadrature point, the kernel function (if non is provided, a constant function one is used) and computes the vector product of the result with with the (discontinuous) operator evaluation(s) of the test function(s). The header of the kernel functions needs to be conform to the interface</p><pre><code class="language-julia hljs">kernel!(result, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point, e.g. qpinfo.x are the global coordinates of the quadrature point.</p><p>Keyword arguments:</p><ul><li><p><code>bonus_quadorder</code>: additional quadrature order added to quadorder. Default: 0</p></li><li><p><code>entities</code>: assemble operator on these grid entities (default = ON<em>FACES). Default: ON</em>FACES</p></li><li><p><code>entry_tolerance</code>: threshold to add entry to sparse matrix. Default: 0</p></li><li><p><code>factor</code>: factor that should be multiplied during assembly. Default: 1</p></li><li><p><code>name</code>: name for operator used in printouts. Default: &#39;&#39;LinearOperatorDG&#39;&#39;</p></li><li><p><code>parallel</code>: assemble operator in parallel using colors/partitions information. Default: false</p></li><li><p><code>parallel_groups</code>: assemble operator in parallel using FaceAssemblyGroups. Default: false</p></li><li><p><code>params</code>: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p><code>quadorder</code>: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>regions</code>: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p><code>store</code>: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li><li><p><code>time_dependent</code>: operator is time-dependent ?. Default: false</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/1a8df5860940dcda753f42341f0e099ff9a45706/src/common_operators/linear_operator_dg.jl#L127-L150">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bilinearoperator/">« BilinearOperator</a><a class="docs-footer-nextpage" href="../restrictions/">Restrictions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 5 January 2026 16:47">Monday 5 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
