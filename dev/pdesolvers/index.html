<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stationary Solvers · ExtendableFEM.jl</title><meta name="title" content="Stationary Solvers · ExtendableFEM.jl"/><meta property="og:title" content="Stationary Solvers · ExtendableFEM.jl"/><meta property="twitter:title" content="Stationary Solvers · ExtendableFEM.jl"/><meta name="description" content="Documentation for ExtendableFEM.jl."/><meta property="og:description" content="Documentation for ExtendableFEM.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../tensordescription/">Tensor Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li><a class="tocitem" href="../bilinearoperator/">BilinearOperator</a></li><li><a class="tocitem" href="../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li class="is-active"><a class="tocitem" href>Stationary Solvers</a><ul class="internal"><li><a class="tocitem" href="#Meshes-and-FESpaces"><span>Meshes and FESpaces</span></a></li><li><a class="tocitem" href="#Solve-(monolithic)"><span>Solve (monolithic)</span></a></li><li><a class="tocitem" href="#Solve-(iterating-subproblems)"><span>Solve (iterating subproblems)</span></a></li></ul></li><li><a class="tocitem" href="../pdesolvers_dt/">Time-dependent Solvers</a></li><li><a class="tocitem" href="../parallel_assembly/">Parallel Assembly</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Other packages</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../faceinterpolator/">Face interpolator</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../module_examples/Example103_BurgersEquation/">Example103_BurgersEquation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoissonEquation/">Example105_NonlinearPoissonEquation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion/">Example106_NonlinearDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example108_RobinBoundaryCondition/">Example108_RobinBoundaryCondition</a></li><li><a class="tocitem" href="../module_examples/Example201_PoissonProblem/">Example201_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example202_MixedPoissonProblem/">Example202_MixedPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example203_PoissonProblemDG/">Example203_PoissonProblemDG</a></li><li><a class="tocitem" href="../module_examples/Example204_LaplaceEVProblem/">Example204_LaplaceEVProblem</a></li><li><a class="tocitem" href="../module_examples/Example205_HeatEquation/">Example205_HeatEquation</a></li><li><a class="tocitem" href="../module_examples/Example206_CoupledSubGridProblems/">Example206_CoupledSubGridProblems</a></li><li><a class="tocitem" href="../module_examples/Example207_AdvectionUpwindDG/">Example207_AdvectionUpwindDG</a></li><li><a class="tocitem" href="../module_examples/Example210_LshapeAdaptivePoissonProblem/">Example210_LshapeAdaptivePoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example211_LshapeAdaptiveEQPoissonProblem/">Example211_LshapeAdaptiveEQPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example212_PeriodicBoundary2D/">Example212_PeriodicBoundary2D</a></li><li><a class="tocitem" href="../module_examples/Example220_ReactionConvectionDiffusion/">Example220_ReactionConvectionDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example225_ObstacleProblem/">Example225_ObstacleProblem</a></li><li><a class="tocitem" href="../module_examples/Example226_Thermoforming/">Example226_Thermoforming</a></li><li><a class="tocitem" href="../module_examples/Example230_NonlinearElasticity/">Example230_NonlinearElasticity</a></li><li><a class="tocitem" href="../module_examples/Example235_StokesIteratedPenalty/">Example235_StokesIteratedPenalty</a></li><li><a class="tocitem" href="../module_examples/Example240_SVRTEnrichment/">Example240_SVRTEnrichment</a></li><li><a class="tocitem" href="../module_examples/Example245_NSEFlowAroundCylinder/">Example245_NSEFlowAroundCylinder</a></li><li><a class="tocitem" href="../module_examples/Example250_NSELidDrivenCavity/">Example250_NSELidDrivenCavity</a></li><li><a class="tocitem" href="../module_examples/Example252_NSEPlanarLatticeFlow/">Example252_NSEPlanarLatticeFlow</a></li><li><a class="tocitem" href="../module_examples/Example260_AxisymmetricNavierStokesProblem/">Example260_AxisymmetricNavierStokesProblem</a></li><li><a class="tocitem" href="../module_examples/Example264_StokesDarcy/">Example264_StokesDarcy</a></li><li><a class="tocitem" href="../module_examples/Example265_FlowTransport/">Example265_FlowTransport</a></li><li><a class="tocitem" href="../module_examples/Example270_NaturalConvectionProblem/">Example270_NaturalConvectionProblem</a></li><li><a class="tocitem" href="../module_examples/Example275_OptimalControlStokes/">Example275_OptimalControlStokes</a></li><li><a class="tocitem" href="../module_examples/Example280_CompressibleStokes/">Example280_CompressibleStokes</a></li><li><a class="tocitem" href="../module_examples/Example282_IncompressibleMHD/">Example282_IncompressibleMHD</a></li><li><a class="tocitem" href="../module_examples/Example284_LevelSetMethod/">Example284_LevelSetMethod</a></li><li><a class="tocitem" href="../module_examples/Example285_CahnHilliard/">Example285_CahnHilliard</a></li><li><a class="tocitem" href="../module_examples/Example290_PoroElasticity/">Example290_PoroElasticity</a></li><li><a class="tocitem" href="../module_examples/Example301_PoissonProblem/">Example301_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example310_DivFreeBasis/">Example310_DivFreeBasis</a></li><li><a class="tocitem" href="../module_examples/Example312_PeriodicBoundary3D/">Example312_PeriodicBoundary3D</a></li><li><a class="tocitem" href="../module_examples/Example330_HyperElasticity/">Example330_HyperElasticity</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solving</a></li><li class="is-active"><a href>Stationary Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stationary Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/master/docs/src/pdesolvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stationary-Solvers"><a class="docs-heading-anchor" href="#Stationary-Solvers">Stationary Solvers</a><a id="Stationary-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-Solvers" title="Permalink"></a></h1><h2 id="Meshes-and-FESpaces"><a class="docs-heading-anchor" href="#Meshes-and-FESpaces">Meshes and FESpaces</a><a id="Meshes-and-FESpaces-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-and-FESpaces" title="Permalink"></a></h2><p>To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).</p><p>Meshes are expected in the form of an ExtendableGrid, see <a href="https://github.com/WIAS-PDELib/ExtendableGrids.jl">ExtendableGrids.jl</a> for details and constructors. Grid generators for simplex grids can be found e.g. in the external module <a href="https://github.com/WIAS-PDELib/SimplexGridFactory.jl">SimplexGridFactory.jl</a>. There is also an extension to read meshes from gmsh files.</p><p>Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by</p><pre><code class="language-julia hljs">FESpace{FEType}(grid::ExtendableGrid)</code></pre><p>Here, FEType denotes the type of finite element. A <a href="https://wias-pdelib.github.io/ExtendableFEMBase.jl/dev/fems/">list of available FETypes</a> can be found in the <a href="https://wias-pdelib.github.io/ExtendableFEMBase.jl/dev/">Documentation of ExtendableFEMBase.jl</a>.</p><h2 id="Solve-(monolithic)"><a class="docs-heading-anchor" href="#Solve-(monolithic)">Solve (monolithic)</a><a id="Solve-(monolithic)-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-(monolithic)" title="Permalink"></a></h2><p>If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function solve(
	PD::ProblemDescription,
	[FES::Union{&lt;:FESpace,Vector{&lt;:FESpace}}],
	SC = nothing;
	unknowns = PD.unknowns,
	kwargs...)</code></pre><p>Returns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).</p><p>This function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.</p><p>Keyword arguments:</p><ul><li><p><code>abstol</code>: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>check_matrix</code>: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p><code>constant_matrix</code>: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li><li><p><code>constant_rhs</code>: right-hand side is constant (skips reassembly). Default: false</p></li><li><p><code>damping</code>: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p><code>inactive</code>: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p><code>init</code>: initial solution (also used to save the new solution). Default: nothing</p></li><li><p><code>initialized</code>: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p><code>is_linear</code>: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>maxiterations</code>: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p><code>method_linear</code>: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p><code>plot</code>: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p><code>precon_linear</code>: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing</p></li><li><p><code>reltol</code>: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>restrict_dofs</code>: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]</p></li><li><p><code>return_config</code>: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p><code>show_config</code>: show configuration at the beginning of solve. Default: false</p></li><li><p><code>show_matrix</code>: show system matrix after assembly. Default: false</p></li><li><p><code>spy</code>: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p><code>symmetrize</code>: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p><code>symmetrize_structure</code>: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false</p></li><li><p><code>target_residual</code>: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p><code>time</code>: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul><p>Depending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/fa0c1ee3b363498dabf5d0a47d13bf015bb3f263/src/solvers.jl#L14-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.residual" href="#ExtendableFEM.residual"><code>ExtendableFEM.residual</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual(S::SolverConfiguration)</code></pre><p>returns the residual of the last solve</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/fa0c1ee3b363498dabf5d0a47d13bf015bb3f263/src/solver_config.jl#L31-L38">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat customized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.</p></div></div><h2 id="Solve-(iterating-subproblems)"><a class="docs-heading-anchor" href="#Solve-(iterating-subproblems)">Solve (iterating subproblems)</a><a id="Solve-(iterating-subproblems)-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-(iterating-subproblems)" title="Permalink"></a></h2><p>If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.SolverConfiguration" href="#ExtendableFEM.SolverConfiguration"><code>ExtendableFEM.SolverConfiguration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function iterate_until_stationarity(
	SolverConfiguration(Problem::ProblemDescription
	[FES::Union{&lt;:FESpace, Vector{&lt;:FESpace}}];
	init = nothing,
	unknowns = Problem.unknowns,
	kwargs...)</code></pre><p>Returns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).</p><p>Keyword arguments:</p><ul><li><p><code>abstol</code>: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>check_matrix</code>: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p><code>constant_matrix</code>: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li><li><p><code>constant_rhs</code>: right-hand side is constant (skips reassembly). Default: false</p></li><li><p><code>damping</code>: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p><code>inactive</code>: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p><code>init</code>: initial solution (also used to save the new solution). Default: nothing</p></li><li><p><code>initialized</code>: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p><code>is_linear</code>: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p><code>maxiterations</code>: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p><code>method_linear</code>: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p><code>plot</code>: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p><code>precon_linear</code>: function that computes preconditioner for method_linear in case an iterative solver is chosen. Default: nothing</p></li><li><p><code>reltol</code>: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p><code>restrict_dofs</code>: array of dofs for each unknown that should be solved (default: all dofs). Default: Any[]</p></li><li><p><code>return_config</code>: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p><code>show_config</code>: show configuration at the beginning of solve. Default: false</p></li><li><p><code>show_matrix</code>: show system matrix after assembly. Default: false</p></li><li><p><code>spy</code>: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p><code>symmetrize</code>: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p><code>symmetrize_structure</code>: make the system sparse matrix structurally symmetric (e.g. if [j,k] is also [k,j] must be set, all diagonal entries must be set). Default: false</p></li><li><p><code>target_residual</code>: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p><code>time</code>: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p><code>verbosity</code>: verbosity level. Default: 0</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/fa0c1ee3b363498dabf5d0a47d13bf015bb3f263/src/solver_config.jl#L84-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.get_unknown_id" href="#ExtendableFEM.get_unknown_id"><code>ExtendableFEM.get_unknown_id</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_unknown_id(SC::SolverConfiguration, u::Unknown)</code></pre><p>returns the id of the unknown u in SC</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/fa0c1ee3b363498dabf5d0a47d13bf015bb3f263/src/solvers.jl#L1-L8">source</a></section></article><p>If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.iterate_until_stationarity" href="#ExtendableFEM.iterate_until_stationarity"><code>ExtendableFEM.iterate_until_stationarity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function iterate_until_stationarity(
	SCs::Array{&lt;:SolverConfiguration, 1},
	FES = nothing;
	maxsteps = 1000,
	init = nothing,
	unknowns = [SC.PD.unknowns for SC in SCs],
	kwargs...)</code></pre><p>Iterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corresponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.</p><p>Using the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by</p><pre><code class="language-julia hljs">SolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)</code></pre><p>with the usual keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/ExtendableFEM.jl/blob/fa0c1ee3b363498dabf5d0a47d13bf015bb3f263/src/solvers.jl#L457-L484">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../allindex/">« Index</a><a class="docs-footer-nextpage" href="../pdesolvers_dt/">Time-dependent Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 14:38">Monday 28 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
