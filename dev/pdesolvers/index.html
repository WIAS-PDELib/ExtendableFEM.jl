<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stationary Solvers · ExtendableFEM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li><a class="tocitem" href="../bilinearoperator/">BilinearOperator</a></li><li><a class="tocitem" href="../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li class="is-active"><a class="tocitem" href>Stationary Solvers</a><ul class="internal"><li><a class="tocitem" href="#Meshes-and-FESpaces"><span>Meshes and FESpaces</span></a></li><li><a class="tocitem" href="#Solve-(monolithic)"><span>Solve (monolithic)</span></a></li><li><a class="tocitem" href="#Solve-(iterating-subproblems)"><span>Solve (iterating subproblems)</span></a></li></ul></li><li><a class="tocitem" href="../pdesolvers_dt/">Time-dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Other packages</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example103_BurgersEquation/">103 : Burger&#39;s Equation</a></li><li><a class="tocitem" href="../examples/Example105_NonlinearPoissonEquation/">105 : Nonlinear Poisson Equation</a></li><li><a class="tocitem" href="../examples/Example106_NonlinearDiffusion/">106 : Nonlinear Diffusion</a></li><li><a class="tocitem" href="../examples/Example108_RobinBoundaryCondition/">108 : Robin Boundary Condition</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem/">201 : Poisson-Problem</a></li><li><a class="tocitem" href="../examples/Example202_MixedPoissonProblem/">202 : Poisson-Problem (Mixed)</a></li><li><a class="tocitem" href="../examples/Example205_HeatEquation/">205 : Heat equation</a></li><li><a class="tocitem" href="../examples/Example210_LshapeAdaptivePoissonProblem/">210 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example211_LshapeAdaptiveEQPoissonProblem/">211 : Poisson L-shape Local Equilibrated Fluxes</a></li><li><a class="tocitem" href="../examples/Example220_ReactionConvectionDiffusion/">220 : Reaction-Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/Example225_ObstacleProblem/">225 : Obstacle Problem</a></li><li><a class="tocitem" href="../examples/Example230_NonlinearElasticity/">230 : Nonlinear Elasticity</a></li><li><a class="tocitem" href="../examples/Example235_StokesIteratedPenalty/">235 : Stokes iterated penalty method</a></li><li><a class="tocitem" href="../examples/Example240_SVRTEnrichment/">240 : Stokes <span>$RT$</span> enrichment</a></li><li><a class="tocitem" href="../examples/Example245_NSEFlowAroundCylinder/">245 : Flow around a cylinder</a></li><li><a class="tocitem" href="../examples/Example250_NSELidDrivenCavity/">250 : Navier–Stokes Lid-driven cavity</a></li><li><a class="tocitem" href="../examples/Example252_NSEPlanarLatticeFlow/">252 : Navier–Stokes Planar Lattice Flow</a></li><li><a class="tocitem" href="../examples/Example260_AxisymmetricNavierStokesProblem/">260 : Axisymmetric Stokes</a></li><li><a class="tocitem" href="../examples/Example265_FlowTransport/">265 : Flow + Transport</a></li><li><a class="tocitem" href="../examples/Example270_NaturalConvectionProblem/">270 : Natural convection</a></li><li><a class="tocitem" href="../examples/Example280_CompressibleStokes/">240 : Compressible Stokes 2D</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solving</a></li><li class="is-active"><a href>Stationary Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stationary Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="github.com/chmerdon/ExtendableFEM.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stationary-Solvers"><a class="docs-heading-anchor" href="#Stationary-Solvers">Stationary Solvers</a><a id="Stationary-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Stationary-Solvers" title="Permalink"></a></h1><h2 id="Meshes-and-FESpaces"><a class="docs-heading-anchor" href="#Meshes-and-FESpaces">Meshes and FESpaces</a><a id="Meshes-and-FESpaces-1"></a><a class="docs-heading-anchor-permalink" href="#Meshes-and-FESpaces" title="Permalink"></a></h2><p>To solve a ProblemDescription the user needs to provide some discretisation information. The most important one is the mesh (that should be conforming with the region information used in the problem description).</p><p>Meshes are expected in the form of an ExtendableGrid, see <a href="https://github.com/j-fu/ExtendableGrids.jl">ExtendableGrids.jl</a> for details and constructors. Grid generators for simplex grids can be found e.g. in the external module <a href="https://github.com/j-fu/SimplexGridFactory.jl">SimplexGridFactory.jl</a>. There is also an extension to read meshes from gmsh files.</p><p>Secondly, the user needs to decide how to discretize the unknowns by providing a FESpace for each unknown, which can be generated by</p><pre><code class="language-julia hljs">FESpace{FEType}(grid::ExtendableGrid)</code></pre><p>Here, FEType denotes the type of finite element. A <a href="https://chmerdon.github.io/ExtendableFEMBase.jl/dev/fems/">list of available FETypes</a> can be found in the <a href="https://chmerdon.github.io/ExtendableFEMBase.jl/dev/">Documentation of ExtendableFEMBase.jl</a>.</p><h2 id="Solve-(monolithic)"><a class="docs-heading-anchor" href="#Solve-(monolithic)">Solve (monolithic)</a><a id="Solve-(monolithic)-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-(monolithic)" title="Permalink"></a></h2><p>If solve is applied to a PDEDescription and an array of FESpaces (that specify the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. The solver attempts to bring the (nonlinear) residual to the prescribed target tolerance. </p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function solve(
	PD::ProblemDescription,
	[FES::Union{&lt;:FESpace,Vector{&lt;:FESpace}}],
	SC = nothing;
	unknowns = PD.unknowns,
	kwargs...)</code></pre><p>Returns a solution of the PDE as an FEVector for the provided FESpace(s) FES (to be used to discretised the unknowns of the PDEs). If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).</p><p>This function extends the CommonSolve.solve interface and the PDEDescription takes the role of the ProblemType and FES takes the role of the SolverType.</p><p>Keyword arguments:</p><ul><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>method_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p>time: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p>spy: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p>show_config: show configuration at the beginning of solve. Default: false</p></li><li><p>precon<em>linear: function that computes preconditioner for method</em>linear incase an iterative solver is chosen. Default: nothing</p></li><li><p>init: initial solution (also used to save the new solution). Default: nothing</p></li><li><p>initialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p>return_config: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p>show_matrix: show system matrix after assembly. Default: false</p></li><li><p>reltol: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p>is_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>symmetrize: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p>inactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p>plot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p>damping: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p>check_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p>constant_rhs: right-hand side is constant (skips reassembly). Default: false</p></li><li><p>abstol: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p>target_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p>maxiterations: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p>constant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li></ul><p>Depending on the detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The type of fixed-point algorithm depends on the discretisation of the nonlinearities. If all of them are assembled as a NonlinearOperator, this will result in a Newton scheme (which can be somewhat costumized via the keywords arguments like damping). If all nonlinearities are linearized by LinearOperator and BilinearOperator, this will result in other types of fixed-point iterations.</p></div></div><h2 id="Solve-(iterating-subproblems)"><a class="docs-heading-anchor" href="#Solve-(iterating-subproblems)">Solve (iterating subproblems)</a><a id="Solve-(iterating-subproblems)-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-(iterating-subproblems)" title="Permalink"></a></h2><p>If the problem can be solved by iterating over subproblems this can be achieved as well. For that each subproblem must be configured separately via a SolverConfiguration (allowing different tolerances and keyword arguments for each subproblem solve). A SolverConfiguration can be constructed with this constructor:</p><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.SolverConfiguration" href="#ExtendableFEM.SolverConfiguration"><code>ExtendableFEM.SolverConfiguration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function iterate_until_stationarity(
	SolverConfiguration(Problem::ProblemDescription
	[FES::Union{&lt;:FESpace, Vector{&lt;:FESpace}}];
	init = nothing,
	unknowns = Problem.unknowns,
	kwargs...)</code></pre><p>Returns a solver configuration for the ProblemDescription that can be passed to the solve function. Here, FES are the FESpaces that should be used to discretize the selected unknowns. If no FES is provided an initial FEVector (see keyword init) must be provided (which is used to built the FES).</p><p>Keyword arguments:</p><ul><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>method_linear: any solver or custom LinearSolveFunction compatible with LinearSolve.jl (default = UMFPACKFactorization()). Default: LinearSolve.UMFPACKFactorization(true, true)</p></li><li><p>time: current time to be used in all time-dependent operators. Default: 0.0</p></li><li><p>spy: show unicode spy plot of system matrix during solve. Default: false</p></li><li><p>show_config: show configuration at the beginning of solve. Default: false</p></li><li><p>precon<em>linear: function that computes preconditioner for method</em>linear incase an iterative solver is chosen. Default: nothing</p></li><li><p>init: initial solution (also used to save the new solution). Default: nothing</p></li><li><p>initialized: linear system in solver configuration is already assembled (turns true after first solve). Default: false</p></li><li><p>return_config: solver returns solver configuration (including A and b of last iteration). Default: false</p></li><li><p>show_matrix: show system matrix after assembly. Default: false</p></li><li><p>reltol: reltol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p>is_linear: linear problem (avoid reassembly of nonlinear operators to check residual). Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>symmetrize: make system matrix symmetric (replace by (A+A&#39;)/2). Default: false</p></li><li><p>inactive: inactive unknowns (are made available in assembly, but not updated in solve). Default: ExtendableFEM.Unknown[]</p></li><li><p>plot: plot all solved unknowns with a (very rough but fast) unicode plot. Default: false</p></li><li><p>damping: amount of damping, value should be between in (0,1). Default: 0</p></li><li><p>check_matrix: check matrix for symmetry and positive definiteness and largest/smallest eigenvalues. Default: false</p></li><li><p>constant_rhs: right-hand side is constant (skips reassembly). Default: false</p></li><li><p>abstol: abstol for linear solver (if iterative). Default: 1.0e-11</p></li><li><p>target_residual: stop if the absolute (nonlinear) residual is smaller than this number. Default: 1.0e-10</p></li><li><p>maxiterations: maximal number of nonlinear iterations/linear solves. Default: 10</p></li><li><p>constant_matrix: matrix is constant (skips reassembly and refactorization in solver). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><p>If each subproblem has a SolverConfiguration the fixed-point iteration can be triggered with this function:</p><article class="docstring"><header><a class="docstring-binding" id="ExtendableFEM.iterate_until_stationarity" href="#ExtendableFEM.iterate_until_stationarity"><code>ExtendableFEM.iterate_until_stationarity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function iterate_until_stationarity(
	SCs::Array{&lt;:SolverConfiguration, 1},
	FES = nothing;
	maxsteps = 1000,
	init = nothing,
	unknowns = [SC.PD.unknowns for SC in SCs],
	kwargs...)</code></pre><p>Iterates consecutively over all SolverConfigurations (each contains the ProblemDescription of the corressponding subproblem) until the residuals of all subproblems are below their tolerances and returns the solution of the combined unknowns of all subproblems. The additional argument maxsteps limits the number of these iterations If an initial vector init is provided it should contain all unknowns of the subproblems.</p><p>Using the SolverConfiguration instead of the ProblemDescription in the first argument allows to use different kwargs for each subproblem. The SolverConfiguration for each subproblem can be generated by</p><pre><code class="language-julia hljs">SolverConfiguration(PD::ProblemDescription; init = sol, kwargs...)</code></pre><p>with the usual keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../callbackoperator/">« CallbackOperator</a><a class="docs-footer-nextpage" href="../pdesolvers_dt/">Time-dependent Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 7 September 2023 11:06">Thursday 7 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
