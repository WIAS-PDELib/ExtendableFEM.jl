<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BilinearOperator · ExtendableFEM.jl</title><meta name="title" content="BilinearOperator · ExtendableFEM.jl"/><meta property="og:title" content="BilinearOperator · ExtendableFEM.jl"/><meta property="twitter:title" content="BilinearOperator · ExtendableFEM.jl"/><meta name="description" content="Documentation for ExtendableFEM.jl."/><meta property="og:description" content="Documentation for ExtendableFEM.jl."/><meta property="twitter:description" content="Documentation for ExtendableFEM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableFEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../problemdescription/">Problem Description</a></li><li><a class="tocitem" href="../nonlinearoperator/">NonlinearOperator</a></li><li class="is-active"><a class="tocitem" href>BilinearOperator</a><ul class="internal"><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#BilinearOperatorDG"><span>BilinearOperatorDG</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../linearoperator/">LinearOperator</a></li><li><a class="tocitem" href="../interpolateboundarydata/">InterpolateBoundaryData</a></li><li><a class="tocitem" href="../homogeneousdata/">HomogeneousData</a></li><li><a class="tocitem" href="../fixdofs/">FixDofs</a></li><li><a class="tocitem" href="../combinedofs/">CombineDofs</a></li><li><a class="tocitem" href="../callbackoperator/">CallbackOperator</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Stationary Solvers</a></li><li><a class="tocitem" href="../pdesolvers_dt/">Time-dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../postprocessing/">Other packages</a></li><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../module_examples/Example103_BurgersEquation/">Example103_BurgersEquation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoissonEquation/">Example105_NonlinearPoissonEquation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion/">Example106_NonlinearDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example108_RobinBoundaryCondition/">Example108_RobinBoundaryCondition</a></li><li><a class="tocitem" href="../module_examples/Example201_PoissonProblem/">Example201_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example202_MixedPoissonProblem/">Example202_MixedPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example203_PoissonProblemDG/">Example203_PoissonProblemDG</a></li><li><a class="tocitem" href="../module_examples/Example204_LaplaceEVProblem/">Example204_LaplaceEVProblem</a></li><li><a class="tocitem" href="../module_examples/Example205_HeatEquation/">Example205_HeatEquation</a></li><li><a class="tocitem" href="../module_examples/Example206_CoupledSubGridProblems/">Example206_CoupledSubGridProblems</a></li><li><a class="tocitem" href="../module_examples/Example207_AdvectionUpwindDG/">Example207_AdvectionUpwindDG</a></li><li><a class="tocitem" href="../module_examples/Example210_LshapeAdaptivePoissonProblem/">Example210_LshapeAdaptivePoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example211_LshapeAdaptiveEQPoissonProblem/">Example211_LshapeAdaptiveEQPoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example220_ReactionConvectionDiffusion/">Example220_ReactionConvectionDiffusion</a></li><li><a class="tocitem" href="../module_examples/Example225_ObstacleProblem/">Example225_ObstacleProblem</a></li><li><a class="tocitem" href="../module_examples/Example226_Thermoforming/">Example226_Thermoforming</a></li><li><a class="tocitem" href="../module_examples/Example230_NonlinearElasticity/">Example230_NonlinearElasticity</a></li><li><a class="tocitem" href="../module_examples/Example235_StokesIteratedPenalty/">Example235_StokesIteratedPenalty</a></li><li><a class="tocitem" href="../module_examples/Example240_SVRTEnrichment/">Example240_SVRTEnrichment</a></li><li><a class="tocitem" href="../module_examples/Example245_NSEFlowAroundCylinder/">Example245_NSEFlowAroundCylinder</a></li><li><a class="tocitem" href="../module_examples/Example250_NSELidDrivenCavity/">Example250_NSELidDrivenCavity</a></li><li><a class="tocitem" href="../module_examples/Example252_NSEPlanarLatticeFlow/">Example252_NSEPlanarLatticeFlow</a></li><li><a class="tocitem" href="../module_examples/Example260_AxisymmetricNavierStokesProblem/">Example260_AxisymmetricNavierStokesProblem</a></li><li><a class="tocitem" href="../module_examples/Example265_FlowTransport/">Example265_FlowTransport</a></li><li><a class="tocitem" href="../module_examples/Example270_NaturalConvectionProblem/">Example270_NaturalConvectionProblem</a></li><li><a class="tocitem" href="../module_examples/Example275_OptimalControlStokes/">Example275_OptimalControlStokes</a></li><li><a class="tocitem" href="../module_examples/Example280_CompressibleStokes/">Example280_CompressibleStokes</a></li><li><a class="tocitem" href="../module_examples/Example282_IncompressibleMHD/">Example282_IncompressibleMHD</a></li><li><a class="tocitem" href="../module_examples/Example284_LevelSetMethod/">Example284_LevelSetMethod</a></li><li><a class="tocitem" href="../module_examples/Example285_CahnHilliard/">Example285_CahnHilliard</a></li><li><a class="tocitem" href="../module_examples/Example290_PoroElasticity/">Example290_PoroElasticity</a></li><li><a class="tocitem" href="../module_examples/Example301_PoissonProblem/">Example301_PoissonProblem</a></li><li><a class="tocitem" href="../module_examples/Example310_DivFreeBasis/">Example310_DivFreeBasis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>BilinearOperator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BilinearOperator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/chmerdon/ExtendableFEM.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BilinearOperator"><a class="docs-heading-anchor" href="#BilinearOperator">BilinearOperator</a><a id="BilinearOperator-1"></a><a class="docs-heading-anchor-permalink" href="#BilinearOperator" title="Permalink"></a></h1><p>A bilinear operator allows to add matrices to the system matrix that usually refer to linearisations of the PDE operators or stabilisations. If the bilinear operator lives on face entities, also jumps of operators can be involved, if they are naturally continuous for the finite element space in operation (also jumps for broken spaces) and only involve degrees of freedom on the face, e.g. normal jumps for Hdiv spaces or jumps for H1-conforming spaces or tangential jumps of Hcurl spaces. For all other discontinuous operator evaluations (that needs to evaluat more than the degrees of freedom on the face) there is the possibility to use BilinearOperatorDG. It is also possible to assign a matrix assembled by the user as a BilinearOperator.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.BilinearOperator" href="#ExtendableFEM.BilinearOperator"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;
	kwargs...)</code></pre><p>Generates a bilinear form that evaluates the vector product of the operator evaluation(s) of the test function(s) with the operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.BilinearOperator" href="#ExtendableFEM.BilinearOperator"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	A::AbstractMatrix,
	u_test,
	u_ansatz = u_test;
	kwargs...)</code></pre><p>Generates a bilinear form from a user-provided matrix, which can be a sparse matrix or a FEMatrix with multiple blocks. The arguments u<em>test and u</em>ansatz specify where to put the (blocks of the) matrix in the system.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.BilinearOperator-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}" href="#ExtendableFEM.BilinearOperator-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.BilinearOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperator(
	kernel::Function,
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_args::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a nonlinear bilinear form that evaluates a kernel function that depends on the operator evaluation(s) of the ansatz function(s) and the operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, eval_args, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperator([grad(1)], [grad(1)]; kwargs...) generates a weak Laplace operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><h2 id="BilinearOperatorDG"><a class="docs-heading-anchor" href="#BilinearOperatorDG">BilinearOperatorDG</a><a id="BilinearOperatorDG-1"></a><a class="docs-heading-anchor-permalink" href="#BilinearOperatorDG" title="Permalink"></a></h2><p>BilinearOperatorDG is intended for bilinear forms that involves jumps of discontinuous quantities on faces whose assembly requires evaluation of all degrees of freedom on the neighbouring cells, e.g. gradient jumps for H1 conforming functions. In this case the assembly loop triggers integration along the boundary of the cells.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.BilinearOperatorDG" href="#ExtendableFEM.BilinearOperatorDG"><code>ExtendableFEM.BilinearOperatorDG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperatorDG(
	[kernel!::Function],
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1} = oa_test;
	kwargs...)</code></pre><p>Generates a bilinear form that evaluates the vector product of the (discontinuous) operator evaluation(s) of the test function(s) with the (discontinuous) operator evaluation(s) of the ansatz function(s). If a function is provided in the first argument, the ansatz function evaluations can be customized by the kernel function and its result vector is then used in a dot product with the test function evaluations. In this case the header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Example: BilinearOperatorDG([jump(grad(1))], [jump(grad(1))]; kwargs...) generates an interior penalty stabilisation.</p><p>Keyword arguments:</p><ul><li><p>lump: lump the operator (= only assemble the diagonal). Default: false</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>callback!: function with interface (A, b, sol) that is called in each assembly step. Default: nothing</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperatorDG&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>FACES). Default: ON</em>FACES</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}" href="#ExtendableFEM.BilinearOperatorDG-Tuple{Function, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}, Vector{&lt;:Tuple{Union{Int64, Unknown}, DataType}}}"><code>ExtendableFEM.BilinearOperatorDG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function BilinearOperatorDG(
	kernel::Function,
	oa_test::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_ansatz::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1},
	oa_args::Array{&lt;:Tuple{Union{Unknown,Int}, DataType},1};
	kwargs...)</code></pre><p>Generates a nonlinear bilinear form that evaluates a kernel function that depends on the (discontinuou) operator evaluation(s) of the ansatz function(s) and the (discontinuous) operator evaluations of the current solution. The result of the kernel function is used in a vector product with the operator evaluation(s) of the test function(s). Hence, this can be used as a linearization of a nonlinear operator. The header of the kernel functions needs to be conform to the interface</p><pre><code class="nohighlight hljs">kernel!(result, eval_ansatz, eval_args, qpinfo)</code></pre><p>where qpinfo allows to access information at the current quadrature point.</p><p>Operator evaluations are tuples that pair an unknown identifier or integer with a Function operator.</p><p>Keyword arguments:</p><ul><li><p>lump: diagonal lumping (=0 no lumping, =1 only keep diagonal entry, =2 accumulate full row to diagonal). Default: 0</p></li><li><p>factor: factor that should be multiplied during assembly. Default: 1</p></li><li><p>verbosity: verbosity level. Default: 0</p></li><li><p>time_dependent: operator is time-dependent ?. Default: false</p></li><li><p>name: name for operator used in printouts. Default: &#39;&#39;BilinearOperator&#39;&#39;</p></li><li><p>entities: assemble operator on these grid entities (default = ON<em>CELLS). Default: ON</em>CELLS</p></li><li><p>quadorder: quadrature order. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>bonus_quadorder: additional quadrature order added to quadorder. Default: 0</p></li><li><p>entry_tolerance: threshold to add entry to sparse matrix. Default: 0</p></li><li><p>regions: subset of regions where operator should be assembly only. Default: Any[]</p></li><li><p>params: array of parameters that should be made available in qpinfo argument of kernel function. Default: nothing</p></li><li><p>parallel_groups: assemble operator in parallel using CellAssemblyGroups. Default: false</p></li><li><p>transposed_copy: assemble a transposed copy of that operator into the transposed matrix block(s), 0 = no, 1 = symmetric, -1 = skew-symmetric. Default: 0</p></li><li><p>use<em>sparsity</em>pattern: read sparsity pattern of jacobian of kernel to find out which components couple. Default: &#39;&#39;auto&#39;&#39;</p></li><li><p>store: store matrix separately (and copy from there when reassembly is triggered). Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/chmerdon/ExtendableFEM.jl">source</a></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Below two examples illustrate some use cases.</p><h3 id="Example-Stokes-operator"><a class="docs-heading-anchor" href="#Example-Stokes-operator">Example - Stokes operator</a><a id="Example-Stokes-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Stokes-operator" title="Permalink"></a></h3><p>For the linear operator of a Stokes problem a kernel could look like</p><pre><code class="language-julia hljs">μ = 0.1 # viscosity parameter
function kernel!(result, input, qpinfo)
    ∇u, p = view(input,1:4), view(input, 5)
    result[1] = μ*∇u[1] - p[1]
    result[2] = μ*∇u[2]
    result[3] = μ*∇u[3]
    result[4] = μ*∇u[4] - p[1]
    result[5] = -(∇u[1] + ∇u[4])
    return nothing
end</code></pre><p>and the coressponding BilinearOperator constructor call reads</p><pre><code class="language-julia hljs">u = Unknown(&quot;u&quot;; name = &quot;velocity&quot;)
p = Unknown(&quot;p&quot;; name = &quot;pressure&quot;)
BilinearOperator(kernel!, [grad(u), id(p)]; use_sparsity_pattern = true)</code></pre><p>The additional argument causes that the zero pressure-pressure block of the matrix is not (even tried to be) assembled, since <code>input[5]</code> does not couple with <code>result[5]</code>.</p><h3 id="Example-interior-penalty-stabilization"><a class="docs-heading-anchor" href="#Example-interior-penalty-stabilization">Example - interior penalty stabilization</a><a id="Example-interior-penalty-stabilization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-interior-penalty-stabilization" title="Permalink"></a></h3><p>A popular convection stabilization is based on the jumps of the gradient, which can be realised with the kernel</p><pre><code class="language-julia hljs">function stab_kernel!(result, input, qpinfo)
    result .= input .* qpinfo.volume^2
end</code></pre><p>and the BilinearOperatorDG constructor call</p><pre><code class="language-julia hljs">u = Unknown(&quot;u&quot;)
assign_operator!(PD, BilinearOperatorDG(stab_kernel!, [jump(grad(u))]; entities = ON_IFACES, factor = 0.01))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nonlinearoperator/">« NonlinearOperator</a><a class="docs-footer-nextpage" href="../linearoperator/">LinearOperator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 6 May 2024 15:36">Monday 6 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
